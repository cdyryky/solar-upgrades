<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Solar Upgrade Analyzer</title>
  <style>
    :root {
      --bg-0: #f6efe3;
      --bg-1: #fbe7c7;
      --bg-2: #fffaf3;
      --ink: #152016;
      --muted: #5f6a60;
      --accent: #0c7a52;
      --accent-2: #e08d00;
      --good: #0f8a4f;
      --bad: #b03b28;
      --card: rgba(255, 255, 255, 0.84);
      --border: rgba(21, 32, 22, 0.14);
      --shadow: 0 16px 34px rgba(40, 35, 20, 0.1);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Avenir Next", "Gill Sans", "Trebuchet MS", "Segoe UI", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(1600px 700px at 0% 0%, rgba(255, 191, 76, 0.26), transparent 50%),
        radial-gradient(1000px 640px at 100% 12%, rgba(19, 126, 86, 0.18), transparent 52%),
        linear-gradient(160deg, var(--bg-0), var(--bg-2));
      min-height: 100vh;
    }

    .shell {
      max-width: 1320px;
      margin: 0 auto;
      padding: 20px;
      animation: rise 0.48s ease;
    }

    @keyframes rise {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .title {
      margin: 0;
      font-size: clamp(1.5rem, 3.8vw, 2.4rem);
      line-height: 1.12;
      letter-spacing: 0.3px;
    }

    .subtitle {
      margin: 6px 0 18px;
      color: var(--muted);
      font-size: 0.98rem;
    }

    .layout {
      display: grid;
      grid-template-columns: 340px 1fr;
      gap: 16px;
      align-items: start;
    }

    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(2px);
    }

    .inputs {
      padding: 14px;
      position: sticky;
      top: 12px;
      max-height: calc(100vh - 24px);
      overflow: auto;
    }

    .inputs h2,
    .results h2 {
      margin: 0 0 12px;
      font-size: 1.05rem;
      letter-spacing: 0.2px;
    }

    .group {
      margin-bottom: 12px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.5);
    }

    .group h3 {
      margin: 0 0 8px;
      font-size: 0.88rem;
      letter-spacing: 0.28px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .field {
      display: grid;
      grid-template-columns: 1fr 110px;
      gap: 8px;
      margin-bottom: 7px;
      align-items: center;
    }

    .field:last-child {
      margin-bottom: 0;
    }

    label {
      font-size: 0.86rem;
      color: var(--ink);
    }

    input[type="number"],
    input[type="text"],
    select {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 7px;
      padding: 6px 8px;
      font: inherit;
      background: #fff;
      color: var(--ink);
    }

    input:disabled {
      background: #f2efe8;
      color: #7e837d;
      cursor: not-allowed;
    }

    input[type="checkbox"] {
      transform: translateY(1px);
    }

    .range-wrap {
      display: grid;
      grid-template-columns: 1fr 82px;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }

    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }

    .note {
      font-size: 0.76rem;
      color: var(--muted);
      margin-top: 6px;
    }

    .results {
      padding: 14px;
    }

    .cards {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 11px;
      background: rgba(255, 255, 255, 0.68);
      padding: 10px;
    }

    .card .k {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .card .v {
      font-size: 1.24rem;
      font-weight: 700;
      line-height: 1.1;
      font-family: "Rockwell", "Georgia", serif;
    }

    .card .sub {
      margin-top: 6px;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .good { color: var(--good); }
    .bad { color: var(--bad); }

    .section {
      margin-bottom: 14px;
      border: 1px solid var(--border);
      border-radius: 11px;
      background: rgba(255, 255, 255, 0.58);
      padding: 10px;
    }

    .section h3 {
      margin: 0 0 8px;
      font-size: 0.9rem;
      letter-spacing: 0.24px;
      text-transform: uppercase;
      color: var(--muted);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.82rem;
      background: rgba(255, 255, 255, 0.5);
    }

    th, td {
      border: 1px solid rgba(21, 32, 22, 0.1);
      padding: 6px 7px;
      text-align: right;
      white-space: nowrap;
    }

    th:first-child, td:first-child {
      text-align: left;
      position: sticky;
      left: 0;
      background: rgba(252, 249, 241, 0.95);
    }

    thead th {
      position: sticky;
      top: 0;
      background: #f2e7d5;
      z-index: 1;
    }

    .table-wrap {
      max-height: 290px;
      overflow: auto;
      border-radius: 9px;
      border: 1px solid var(--border);
    }

    .mini-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-bottom: 8px;
    }

    .best-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-size: 0.84rem;
    }

    .pill {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 5px 8px;
      background: #fff;
    }

    .status-line {
      font-size: 0.8rem;
      color: var(--muted);
      margin: 0 0 8px;
    }

    button {
      border: 1px solid rgba(12, 122, 82, 0.6);
      border-radius: 9px;
      background: linear-gradient(180deg, #22a86f, #0c7a52);
      color: #fff;
      padding: 8px 10px;
      font: inherit;
      cursor: pointer;
      transition: transform 120ms ease;
    }

    button:hover { transform: translateY(-1px); }

    .matrix-cell {
      cursor: pointer;
      transition: background 100ms ease;
    }

    .matrix-cell:hover {
      background: rgba(12, 122, 82, 0.12);
    }

    .cell-selected {
      background: rgba(224, 141, 0, 0.25);
      font-weight: 700;
    }

    .cell-best {
      box-shadow: inset 0 0 0 2px rgba(12, 122, 82, 0.7);
      font-weight: 700;
    }

    .projection {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 10px;
    }

    canvas {
      width: 100%;
      height: 240px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.65);
    }

    .checks {
      font-size: 0.8rem;
      color: var(--muted);
    }

    @media (max-width: 1080px) {
      .layout {
        grid-template-columns: 1fr;
      }
      .inputs {
        position: static;
        max-height: unset;
      }
      .cards {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .projection {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 700px) {
      .cards {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <h1 class="title">Solar Upgrade Analyzer</h1>
    <p class="subtitle">
      Compare solar + Powerwall sizes for a 4,200 sqft all-electric new build (PG&E, ZIP 95672 default). All rates and assumptions are editable.
    </p>

    <div class="layout">
      <aside class="panel inputs">
        <h2>Inputs</h2>

        <div class="group">
          <h3>Home + Solar Production</h3>
          <div class="field"><label for="annualLoadKwh">Annual load (kWh)</label><input id="annualLoadKwh" type="number" min="1000" step="100" value="24000" /></div>
          <div class="field"><label for="zipCode">ZIP code</label><input id="zipCode" type="text" value="95672" /></div>
          <div class="field"><label for="autoYieldFromZip">Auto-adjust yield from ZIP</label><input id="autoYieldFromZip" type="checkbox" checked /></div>
          <div class="field"><label for="annualYield">Solar yield (kWh/kW-yr)</label><input id="annualYield" type="number" min="800" step="10" value="1700" /></div>
          <div class="field"><label for="peakLoadShare">Load in peak window (%)</label><input id="peakLoadShare" type="number" min="0" max="100" step="1" value="40" /></div>
          <div class="field"><label for="exportPeakShare">Export in peak window (%)</label><input id="exportPeakShare" type="number" min="0" max="100" step="1" value="25" /></div>
          <div class="note" id="zipYieldNote"></div>
        </div>

        <div class="group">
          <h3>PG&amp;E TOU Rates ($/kWh)</h3>
          <div class="field"><label for="importOffPeak">Import off-peak</label><input id="importOffPeak" type="number" min="0" step="0.01" value="0.36" /></div>
          <div class="field"><label for="importPeak">Import peak</label><input id="importPeak" type="number" min="0" step="0.01" value="0.58" /></div>
          <div class="field"><label for="fixedMonthlyCharge">Fixed monthly charge ($)</label><input id="fixedMonthlyCharge" type="number" min="0" step="0.5" value="15" /></div>
          <div class="field"><label for="nbcPerImportKwh">NBC on imports ($/kWh)</label><input id="nbcPerImportKwh" type="number" min="0" step="0.001" value="0.03" /></div>
          <div class="field"><label for="useNem3Export">Use NEM 3.0 export override</label><input id="useNem3Export" type="checkbox" checked /></div>
          <div class="field"><label for="nem3ExportRate">NEM 3.0 export rate</label><input id="nem3ExportRate" type="number" min="0" step="0.01" value="0.04" /></div>
          <div class="field"><label for="exportOffPeak">Export off-peak</label><input id="exportOffPeak" type="number" min="0" step="0.01" value="0.05" /></div>
          <div class="field"><label for="exportPeak">Export peak</label><input id="exportPeak" type="number" min="0" step="0.01" value="0.12" /></div>
          <div class="note" id="nem3Note"></div>
        </div>

        <div class="group">
          <h3>System Pricing</h3>
          <div class="field"><label for="solarBaseCost">Solar base cost ($)</label><input id="solarBaseCost" type="number" min="0" step="50" value="2710" /></div>
          <div class="field"><label for="solarPerModuleCost">Solar cost per module ($)</label><input id="solarPerModuleCost" type="number" min="0" step="50" value="1100" /></div>
          <div class="field"><label for="batteryCost1">1 Powerwall cost ($)</label><input id="batteryCost1" type="number" min="0" step="50" value="16875" /></div>
          <div class="field"><label for="batteryCost2">2 Powerwalls cost ($)</label><input id="batteryCost2" type="number" min="0" step="50" value="31250" /></div>
        </div>

        <div class="group">
          <h3>Battery Model</h3>
          <div class="field"><label for="cyclesPerDay">Cycles/day</label><input id="cyclesPerDay" type="number" min="0" max="2" step="0.01" value="0.85" /></div>
          <div class="field"><label for="roundTripEff">Round-trip efficiency (%)</label><input id="roundTripEff" type="number" min="50" max="100" step="1" value="90" /></div>
        </div>

        <div class="group">
          <h3>Financing</h3>
          <div class="field"><label for="apr">APR (%)</label><input id="apr" type="number" min="0" step="0.01" value="6" /></div>
          <div class="field"><label for="financeYears">Loan term (years)</label><input id="financeYears" type="number" min="1" step="1" value="15" /></div>
          <div class="field"><label for="applyItc">Apply federal ITC</label><input id="applyItc" type="checkbox" checked /></div>
          <div class="field">
            <label for="itcTiming">ITC treatment</label>
            <select id="itcTiming">
              <option value="year1" selected>Year 1 lump-sum credit</option>
              <option value="upfront">Upfront principal reduction</option>
            </select>
          </div>
          <div class="field"><label for="itcRate">ITC rate (%)</label><input id="itcRate" type="number" min="0" max="100" step="1" value="30" /></div>
          <div class="field"><label for="opportunityRate">HYSA opportunity rate (%)</label><input id="opportunityRate" type="number" min="0" max="20" step="0.1" value="5.0" /></div>
        </div>

        <div class="group">
          <h3>Scenario Selection</h3>
          <div class="field"><label for="maxSolarKw">Max solar for sweep (kW)</label><input id="maxSolarKw" type="number" min="0" step="0.1" value="15" /></div>
          <div class="range-wrap">
            <input id="moduleRange" type="range" min="0" max="38" step="1" value="10" />
            <input id="moduleCount" type="number" min="0" max="38" step="1" value="10" />
          </div>
          <div class="field"><label for="batteryCount">Powerwalls</label>
            <select id="batteryCount">
              <option value="0" selected>0</option>
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>
          <div class="field">
            <label for="rankingObjective">Ranking objective</label>
            <select id="rankingObjective">
              <option value="netWithOpportunity">Lowest net + opportunity/mo</option>
              <option value="netMonthly">Lowest net/mo</option>
              <option value="annualSavings">Highest annual savings</option>
            </select>
          </div>
          <div class="note" id="sizingNote"></div>
        </div>

        <div class="group">
          <h3>15-Year Projection</h3>
          <div class="field"><label for="projectionYears">Projection years</label><input id="projectionYears" type="number" min="1" step="1" value="15" /></div>
          <div class="field"><label for="solarDeg">Solar degradation (%/yr)</label><input id="solarDeg" type="number" min="0" max="5" step="0.1" value="0.5" /></div>
          <div class="field"><label for="batteryDeg">Battery degradation (%/yr)</label><input id="batteryDeg" type="number" min="0" max="8" step="0.1" value="2.0" /></div>
          <div class="field"><label for="rateEsc">Utility escalation (%/yr)</label><input id="rateEsc" type="number" min="0" max="10" step="0.1" value="3.0" /></div>
          <div class="field"><label for="toggleSolarDeg">Apply solar degradation</label><input id="toggleSolarDeg" type="checkbox" checked /></div>
          <div class="field"><label for="toggleBatteryDeg">Apply battery degradation</label><input id="toggleBatteryDeg" type="checkbox" checked /></div>
          <div class="field"><label for="toggleRateEsc">Apply utility escalation</label><input id="toggleRateEsc" type="checkbox" checked /></div>
        </div>
      </aside>

      <section class="panel results">
        <h2>Results</h2>
        <div class="cards">
          <div class="card"><div class="k">Install Cost (Gross)</div><div class="v" id="cardInstallCost">$0</div></div>
          <div class="card"><div class="k">Financed Principal</div><div class="v" id="cardFinanced">$0</div><div class="sub" id="cardItcApplied">ITC not applied</div></div>
          <div class="card"><div class="k">Mortgage / Month</div><div class="v" id="cardMortgage">$0</div></div>
          <div class="card"><div class="k">PG&amp;E Before / Month</div><div class="v" id="cardPgeBefore">$0</div></div>
          <div class="card"><div class="k">PG&amp;E After / Month (True-Up)</div><div class="v" id="cardPgeAfter">$0</div><div class="sub" id="cardTrueUpNote"></div></div>
          <div class="card"><div class="k">Utility Savings / Month</div><div class="v good" id="cardSavings">$0</div></div>
          <div class="card"><div class="k">Net Monthly Change</div><div class="v" id="cardNet">$0</div></div>
          <div class="card"><div class="k">Net + HYSA Opp Cost / Month</div><div class="v" id="cardNetOpp">$0</div></div>
        </div>

        <div class="section">
          <h3>Best Monthly Outcome + Top 5 Alternatives</h3>
          <div class="status-line" id="selectionStatus"></div>
          <div class="best-row" id="bestSummary"></div>
          <div style="margin-top:8px;">
            <button id="applyBestBtn" type="button">Use best scenario as selection</button>
          </div>
          <div class="table-wrap" style="margin-top:10px; max-height: 230px;">
            <table>
              <thead>
                <tr>
                  <th>Rank</th>
                  <th>Modules</th>
                  <th>Solar kW</th>
                  <th>Battery</th>
                  <th>Install Cost</th>
                  <th>Financed</th>
                  <th>Mortgage/mo</th>
                  <th>Savings/mo</th>
                  <th>Net/mo</th>
                  <th>Net+HYSA/mo</th>
                  <th>Objective</th>
                </tr>
              </thead>
              <tbody id="topFiveBody"></tbody>
            </table>
          </div>
        </div>

        <div class="section">
          <h3>Annual Energy Breakdown (Selected)</h3>
          <div class="mini-grid">
            <div class="pill" id="energyImport"></div>
            <div class="pill" id="energyExport"></div>
            <div class="pill" id="energyDirectSolar"></div>
            <div class="pill" id="energyBatteryToLoad"></div>
          </div>
          <div class="note" id="energySelfConsumption"></div>
        </div>

        <div class="section">
          <h3 id="matrixHeading">Scenario Matrix</h3>
          <div class="table-wrap">
            <table id="matrixTable"></table>
          </div>
          <div class="note" id="matrixNote">Click a matrix cell to set scenario selection.</div>
        </div>

        <div class="section">
          <h3>15-Year Projection (Selected Scenario)</h3>
          <div class="projection">
            <canvas id="projectionChart" width="800" height="260" aria-label="15-year cumulative projection chart"></canvas>
            <div class="table-wrap" style="max-height:260px;">
              <table>
                <thead>
                  <tr>
                    <th>Year</th>
                    <th>Savings</th>
                    <th>Mortgage</th>
                    <th>Net</th>
                    <th>Cumulative</th>
                  </tr>
                </thead>
                <tbody id="projectionBody"></tbody>
              </table>
            </div>
          </div>
          <div class="mini-grid" style="margin-top:8px;">
            <div class="pill" id="projectionBreakEven">Break-even: --</div>
            <div class="pill" id="projectionCumulative">15-year cumulative: --</div>
          </div>
        </div>

        <div class="checks" id="checksOutput"></div>
      </section>
    </div>
  </div>

  <script>
    "use strict";

    const MODULE_KW = 0.395;
    const DEFAULT_PRICING = {
      solarBaseCost: 2710,
      solarPerModuleCost: 1100,
      0: 0,
      1: 16875,
      2: 31250
    };
    const BATTERY_USABLE_KWH = 13.5 * 0.9;
    const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    const MONTH_LABELS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const MONTHLY_DAYLIGHT_HOURS = [9.8, 10.7, 11.9, 13.1, 14.1, 14.6, 14.4, 13.5, 12.3, 11.1, 10.0, 9.5];
    const PEAK_HOURS = new Set([16, 17, 18, 19, 20]);

    const DEFAULT_LOAD_PROFILE_RAW = [1.02, 0.95, 0.91, 0.82, 0.79, 0.83, 0.96, 1.07, 0.96, 0.89, 0.91, 0.99];
    const DEFAULT_SOLAR_PROFILE_RAW = [0.58, 0.66, 0.86, 1.02, 1.12, 1.18, 1.16, 1.08, 0.98, 0.83, 0.64, 0.53];
    const BASE_LOAD_HOURLY_RAW = [
      0.021, 0.019, 0.018, 0.018, 0.018, 0.021,
      0.028, 0.037, 0.043, 0.045, 0.043, 0.041,
      0.04, 0.039, 0.04, 0.044, 0.054, 0.066,
      0.074, 0.078, 0.07, 0.056, 0.042, 0.031
    ];

    const ZIP_YIELD_HINTS = [
      { start: 90000, end: 93599, annualYield: 1850, label: "SoCal inland profile" },
      { start: 93600, end: 96199, annualYield: 1700, label: "NorCal inland profile" },
      { start: 97000, end: 98699, annualYield: 1300, label: "Pacific Northwest profile" },
      { start: 80000, end: 81699, annualYield: 1650, label: "Mountain West profile" },
      { start: 85000, end: 86599, annualYield: 1950, label: "Desert Southwest profile" }
    ];

    const DEFAULTS = {
      annualLoadKwh: 24000,
      zipCode: "95672",
      autoYieldFromZip: true,
      annualYield: 1700,
      peakLoadShare: 0.4,
      exportPeakShare: 0.2,
      importOffPeak: 0.36,
      importPeak: 0.58,
      fixedMonthlyCharge: 15,
      nbcPerImportKwh: 0.03,
      exportOffPeak: 0.05,
      exportPeak: 0.12,
      useNem3Export: true,
      nem3ExportRate: 0.04,
      solarBaseCost: DEFAULT_PRICING.solarBaseCost,
      solarPerModuleCost: DEFAULT_PRICING.solarPerModuleCost,
      batteryCost1: DEFAULT_PRICING[1],
      batteryCost2: DEFAULT_PRICING[2],
      cyclesPerDay: 0.85,
      roundTripEff: 0.9,
      apr: 0.06,
      financeYears: 15,
      applyItc: true,
      itcRate: 0.3,
      itcTiming: "year1",
      opportunityRate: 0.05,
      maxSolarKw: 15,
      moduleCount: 10,
      batteryCount: 0,
      rankingObjective: "netWithOpportunity",
      projectionYears: 15,
      solarDeg: 0.005,
      batteryDeg: 0.02,
      rateEsc: 0.03,
      toggleSolarDeg: true,
      toggleBatteryDeg: true,
      toggleRateEsc: true
    };

    const LOAD_PROFILE = normalizeProfile(DEFAULT_LOAD_PROFILE_RAW);
    const SOLAR_PROFILE = normalizeProfile(DEFAULT_SOLAR_PROFILE_RAW);
    const BASE_LOAD_HOURLY = normalizeProfile(BASE_LOAD_HOURLY_RAW);

    const el = {
      annualLoadKwh: document.getElementById("annualLoadKwh"),
      zipCode: document.getElementById("zipCode"),
      autoYieldFromZip: document.getElementById("autoYieldFromZip"),
      annualYield: document.getElementById("annualYield"),
      peakLoadShare: document.getElementById("peakLoadShare"),
      exportPeakShare: document.getElementById("exportPeakShare"),
      importOffPeak: document.getElementById("importOffPeak"),
      importPeak: document.getElementById("importPeak"),
      fixedMonthlyCharge: document.getElementById("fixedMonthlyCharge"),
      nbcPerImportKwh: document.getElementById("nbcPerImportKwh"),
      useNem3Export: document.getElementById("useNem3Export"),
      nem3ExportRate: document.getElementById("nem3ExportRate"),
      exportOffPeak: document.getElementById("exportOffPeak"),
      exportPeak: document.getElementById("exportPeak"),
      nem3Note: document.getElementById("nem3Note"),
      zipYieldNote: document.getElementById("zipYieldNote"),
      solarBaseCost: document.getElementById("solarBaseCost"),
      solarPerModuleCost: document.getElementById("solarPerModuleCost"),
      batteryCost1: document.getElementById("batteryCost1"),
      batteryCost2: document.getElementById("batteryCost2"),
      cyclesPerDay: document.getElementById("cyclesPerDay"),
      roundTripEff: document.getElementById("roundTripEff"),
      apr: document.getElementById("apr"),
      financeYears: document.getElementById("financeYears"),
      applyItc: document.getElementById("applyItc"),
      itcRate: document.getElementById("itcRate"),
      itcTiming: document.getElementById("itcTiming"),
      opportunityRate: document.getElementById("opportunityRate"),
      maxSolarKw: document.getElementById("maxSolarKw"),
      moduleRange: document.getElementById("moduleRange"),
      moduleCount: document.getElementById("moduleCount"),
      batteryCount: document.getElementById("batteryCount"),
      rankingObjective: document.getElementById("rankingObjective"),
      sizingNote: document.getElementById("sizingNote"),
      projectionYears: document.getElementById("projectionYears"),
      solarDeg: document.getElementById("solarDeg"),
      batteryDeg: document.getElementById("batteryDeg"),
      rateEsc: document.getElementById("rateEsc"),
      toggleSolarDeg: document.getElementById("toggleSolarDeg"),
      toggleBatteryDeg: document.getElementById("toggleBatteryDeg"),
      toggleRateEsc: document.getElementById("toggleRateEsc"),
      cardInstallCost: document.getElementById("cardInstallCost"),
      cardFinanced: document.getElementById("cardFinanced"),
      cardItcApplied: document.getElementById("cardItcApplied"),
      cardMortgage: document.getElementById("cardMortgage"),
      cardPgeBefore: document.getElementById("cardPgeBefore"),
      cardPgeAfter: document.getElementById("cardPgeAfter"),
      cardTrueUpNote: document.getElementById("cardTrueUpNote"),
      cardSavings: document.getElementById("cardSavings"),
      cardNet: document.getElementById("cardNet"),
      cardNetOpp: document.getElementById("cardNetOpp"),
      selectionStatus: document.getElementById("selectionStatus"),
      bestSummary: document.getElementById("bestSummary"),
      applyBestBtn: document.getElementById("applyBestBtn"),
      topFiveBody: document.getElementById("topFiveBody"),
      matrixHeading: document.getElementById("matrixHeading"),
      matrixTable: document.getElementById("matrixTable"),
      matrixNote: document.getElementById("matrixNote"),
      energyImport: document.getElementById("energyImport"),
      energyExport: document.getElementById("energyExport"),
      energyDirectSolar: document.getElementById("energyDirectSolar"),
      energyBatteryToLoad: document.getElementById("energyBatteryToLoad"),
      energySelfConsumption: document.getElementById("energySelfConsumption"),
      projectionChart: document.getElementById("projectionChart"),
      projectionBody: document.getElementById("projectionBody"),
      projectionBreakEven: document.getElementById("projectionBreakEven"),
      projectionCumulative: document.getElementById("projectionCumulative"),
      checksOutput: document.getElementById("checksOutput")
    };

    let latestRankedScenarios = [];
    let latestBestScenario = null;
    let renderTimer = null;

    function normalizeProfile(values) {
      const total = values.reduce((acc, v) => acc + v, 0);
      if (!Number.isFinite(total) || total <= 0) {
        return new Array(values.length).fill(1 / values.length);
      }
      return values.map((v) => v / total);
    }

    function clamp(n, low, high) {
      return Math.min(high, Math.max(low, n));
    }

    function readNumber(node, fallback) {
      const parsed = Number(node.value);
      return Number.isFinite(parsed) ? parsed : fallback;
    }

    function readPct(node, fallbackPct) {
      return clamp(readNumber(node, fallbackPct * 100) / 100, 0, 1);
    }

    function usd(value) {
      return new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 0 }).format(value);
    }

    function usdPrecise(value) {
      return new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2 }).format(value);
    }

    function kwh(value) {
      return new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 }).format(value) + " kWh";
    }

    function fmt(value, digits) {
      return Number(value).toFixed(digits);
    }

    function objectiveLabel(objective) {
      if (objective === "netMonthly") return "lowest net monthly change";
      if (objective === "annualSavings") return "highest annual utility savings";
      return "lowest net + opportunity monthly change";
    }

    function getObjectiveValue(result, objective) {
      if (objective === "netMonthly") return result.netMonthlyChange;
      if (objective === "annualSavings") return -result.annualSavings;
      return result.netWithOpportunityMonthly;
    }

    function formatObjectiveValue(result, objective) {
      if (objective === "netMonthly") return usdPrecise(result.netMonthlyChange);
      if (objective === "annualSavings") return usdPrecise(result.annualSavings) + "/yr";
      return usdPrecise(result.netWithOpportunityMonthly);
    }

    function parseZip(zipValue) {
      const match = String(zipValue || "").trim().match(/^(\d{5})/);
      return match ? Number(match[1]) : null;
    }

    function inferYieldFromZip(zipValue, fallbackYield) {
      const parsed = parseZip(zipValue);
      if (parsed === null) {
        return { annualYield: fallbackYield, label: "manual (invalid ZIP)" };
      }
      for (const hint of ZIP_YIELD_HINTS) {
        if (parsed >= hint.start && parsed <= hint.end) {
          return { annualYield: hint.annualYield, label: hint.label };
        }
      }
      return { annualYield: fallbackYield, label: "manual (no preset)" };
    }

    function buildHourlyLoadShape(targetPeakShare) {
      const basePeakShare = BASE_LOAD_HOURLY.reduce((acc, v, hour) => acc + (PEAK_HOURS.has(hour) ? v : 0), 0);
      if (basePeakShare <= 0 || basePeakShare >= 1) {
        return BASE_LOAD_HOURLY;
      }

      const constrainedTarget = clamp(targetPeakShare, 0.05, 0.95);
      const peakScale = constrainedTarget / basePeakShare;
      const offScale = (1 - constrainedTarget) / (1 - basePeakShare);
      return normalizeProfile(BASE_LOAD_HOURLY.map((v, hour) => v * (PEAK_HOURS.has(hour) ? peakScale : offScale)));
    }

    function buildSolarHourlyShape(monthIndex) {
      const daylight = MONTHLY_DAYLIGHT_HOURS[monthIndex] || 12;
      const sunrise = 12 - daylight / 2;
      const sunset = 12 + daylight / 2;
      const sigma = Math.max(1.4, daylight / 4.2);
      const profile = new Array(24).fill(0).map((_, hour) => {
        const center = hour + 0.5;
        if (center < sunrise || center > sunset) return 0;
        const spread = center - 12;
        return Math.exp(-(spread * spread) / (2 * sigma * sigma));
      });
      return normalizeProfile(profile);
    }

    function calculateSolarCost(modules, pricing) {
      if (modules <= 0) return 0;
      return pricing.solarBaseCost + pricing.solarPerModuleCost * modules;
    }

    function calculateBatteryCost(batteries, pricing) {
      if (batteries <= 0) return 0;
      if (batteries === 1) return pricing.batteryCost1;
      if (batteries === 2) return pricing.batteryCost2;
      return 0;
    }

    function calculateMortgagePayment(principal, apr, years) {
      if (principal <= 0) return 0;
      if (apr <= 0) return principal / (years * 12);
      const r = apr / 12;
      const n = years * 12;
      return principal * (r / (1 - Math.pow(1 + r, -n)));
    }

    function collectInputs() {
      const maxSolarKw = Math.max(0, readNumber(el.maxSolarKw, DEFAULTS.maxSolarKw));
      const maxModules = Math.max(0, Math.round(maxSolarKw / MODULE_KW));
      const modules = clamp(Math.round(readNumber(el.moduleCount, DEFAULTS.moduleCount)), 0, maxModules);
      const batteries = clamp(Math.round(readNumber(el.batteryCount, DEFAULTS.batteryCount)), 0, 2);
      const zipCode = String(el.zipCode.value || DEFAULTS.zipCode).trim();
      const manualYield = Math.max(0, readNumber(el.annualYield, DEFAULTS.annualYield));
      const yieldInfo = inferYieldFromZip(zipCode, manualYield);
      const autoYieldFromZip = el.autoYieldFromZip.checked;
      const annualYield = autoYieldFromZip ? yieldInfo.annualYield : manualYield;
      const rankingObjective = ["netMonthly", "annualSavings", "netWithOpportunity"].includes(el.rankingObjective.value)
        ? el.rankingObjective.value
        : DEFAULTS.rankingObjective;
      const itcTiming = el.itcTiming.value === "upfront" ? "upfront" : "year1";

      return {
        financing: {
          apr: Math.max(0, readNumber(el.apr, DEFAULTS.apr * 100) / 100),
          years: Math.max(1, Math.round(readNumber(el.financeYears, DEFAULTS.financeYears)))
        },
        load: {
          annualKwh: Math.max(0, readNumber(el.annualLoadKwh, DEFAULTS.annualLoadKwh)),
          monthProfile: LOAD_PROFILE,
          peakShare: readPct(el.peakLoadShare, DEFAULTS.peakLoadShare)
        },
        rates: {
          importOffPeak: Math.max(0, readNumber(el.importOffPeak, DEFAULTS.importOffPeak)),
          importPeak: Math.max(0, readNumber(el.importPeak, DEFAULTS.importPeak)),
          fixedMonthlyCharge: Math.max(0, readNumber(el.fixedMonthlyCharge, DEFAULTS.fixedMonthlyCharge)),
          nbcPerImportKwh: Math.max(0, readNumber(el.nbcPerImportKwh, DEFAULTS.nbcPerImportKwh)),
          exportOffPeak: Math.max(0, readNumber(el.exportOffPeak, DEFAULTS.exportOffPeak)),
          exportPeak: Math.max(0, readNumber(el.exportPeak, DEFAULTS.exportPeak)),
          exportPeakShare: readPct(el.exportPeakShare, DEFAULTS.exportPeakShare),
          useNem3Export: el.useNem3Export.checked,
          nem3ExportRate: Math.max(0, readNumber(el.nem3ExportRate, DEFAULTS.nem3ExportRate))
        },
        pricing: {
          solarBaseCost: Math.max(0, readNumber(el.solarBaseCost, DEFAULTS.solarBaseCost)),
          solarPerModuleCost: Math.max(0, readNumber(el.solarPerModuleCost, DEFAULTS.solarPerModuleCost)),
          batteryCost1: Math.max(0, readNumber(el.batteryCost1, DEFAULTS.batteryCost1)),
          batteryCost2: Math.max(0, readNumber(el.batteryCost2, DEFAULTS.batteryCost2))
        },
        battery: {
          count: batteries,
          usableKwhPerBattery: BATTERY_USABLE_KWH,
          cyclesPerDay: clamp(readNumber(el.cyclesPerDay, DEFAULTS.cyclesPerDay), 0, 2),
          roundTripEfficiency: clamp(readPct(el.roundTripEff, DEFAULTS.roundTripEff), 0.5, 1),
          allowOffPeakDischarge: false
        },
        production: {
          zipCode,
          autoYieldFromZip,
          annualYield,
          manualAnnualYield: manualYield,
          zipYieldLabel: yieldInfo.label,
          monthProfile: SOLAR_PROFILE,
          moduleKw: MODULE_KW
        },
        sizing: {
          modules,
          batteries,
          maxSolarKw,
          maxBatteryCount: 2,
          rankingObjective
        },
        incentives: {
          applyItc: el.applyItc.checked,
          itcRate: readPct(el.itcRate, DEFAULTS.itcRate),
          itcTiming,
          opportunityRate: readPct(el.opportunityRate, DEFAULTS.opportunityRate)
        },
        projection: {
          years: Math.max(1, Math.round(readNumber(el.projectionYears, DEFAULTS.projectionYears))),
          solarDeg: Math.max(0, readNumber(el.solarDeg, DEFAULTS.solarDeg * 100) / 100),
          batteryDeg: Math.max(0, readNumber(el.batteryDeg, DEFAULTS.batteryDeg * 100) / 100),
          rateEsc: Math.max(0, readNumber(el.rateEsc, DEFAULTS.rateEsc * 100) / 100),
          useSolarDeg: el.toggleSolarDeg.checked,
          useBatteryDeg: el.toggleBatteryDeg.checked,
          useRateEsc: el.toggleRateEsc.checked
        }
      };
    }

    function simulateRepresentativeDay(dayInput) {
      const loadShape = buildHourlyLoadShape(dayInput.peakShare);
      const solarShape = buildSolarHourlyShape(dayInput.monthIndex);
      const batteryCapacity = dayInput.batteries * dayInput.usableKwhPerBattery * dayInput.batteryScale;
      const maxDailyDischarge = batteryCapacity * dayInput.cyclesPerDay;

      let soc = batteryCapacity * 0.3;
      let measured = null;
      const warmupDays = 3;

      for (let day = 0; day <= warmupDays; day += 1) {
        let remainingDischarge = maxDailyDischarge;
        const stats = {
          beforeImportPeakKwh: 0,
          beforeImportOffKwh: 0,
          importPeakKwh: 0,
          importOffKwh: 0,
          exportKwh: 0,
          directSolarToLoad: 0,
          batteryToLoad: 0,
          batteryChargeInput: 0,
          endSoc: 0
        };

        for (let hour = 0; hour < 24; hour += 1) {
          const peakHour = PEAK_HOURS.has(hour);
          const hourlyLoad = dayInput.dayLoadKwh * loadShape[hour];
          const hourlySolar = dayInput.daySolarKwh * solarShape[hour];

          if (peakHour) stats.beforeImportPeakKwh += hourlyLoad;
          else stats.beforeImportOffKwh += hourlyLoad;

          let loadRemaining = hourlyLoad;
          let solarRemaining = hourlySolar;

          const directSolar = Math.min(loadRemaining, solarRemaining);
          loadRemaining -= directSolar;
          solarRemaining -= directSolar;
          stats.directSolarToLoad += directSolar;

          if (batteryCapacity > 0 && solarRemaining > 0) {
            const chargeRoom = Math.max(0, batteryCapacity - soc);
            const chargeInput = Math.min(solarRemaining, chargeRoom / dayInput.roundTripEfficiency);
            if (chargeInput > 0) {
              soc += chargeInput * dayInput.roundTripEfficiency;
              solarRemaining -= chargeInput;
              stats.batteryChargeInput += chargeInput;
            }
          }

          if ((peakHour || dayInput.allowOffPeakDischarge) && batteryCapacity > 0 && remainingDischarge > 0 && loadRemaining > 0) {
            const discharge = Math.min(loadRemaining, soc, remainingDischarge);
            if (discharge > 0) {
              soc -= discharge;
              remainingDischarge -= discharge;
              loadRemaining -= discharge;
              stats.batteryToLoad += discharge;
            }
          }

          if (peakHour) stats.importPeakKwh += loadRemaining;
          else stats.importOffKwh += loadRemaining;

          stats.exportKwh += Math.max(0, solarRemaining);
        }

        stats.endSoc = soc;
        measured = stats;
      }

      return measured;
    }

    function computeMonthBills(monthInput) {
      const safeDays = Math.max(1, monthInput.days);
      const dayLoadKwh = monthInput.loadKwh / safeDays;
      const daySolarKwh = monthInput.solarKwh / safeDays;

      const dayResult = simulateRepresentativeDay({
        monthIndex: monthInput.monthIndex,
        dayLoadKwh,
        daySolarKwh,
        peakShare: monthInput.peakShare,
        batteries: monthInput.batteries,
        usableKwhPerBattery: monthInput.usableKwhPerBattery,
        cyclesPerDay: monthInput.cyclesPerDay,
        roundTripEfficiency: monthInput.roundTripEfficiency,
        batteryScale: monthInput.batteryScale,
        allowOffPeakDischarge: monthInput.allowOffPeakDischarge
      });

      const scale = safeDays;
      const beforeImportPeakKwh = dayResult.beforeImportPeakKwh * scale;
      const beforeImportOffKwh = dayResult.beforeImportOffKwh * scale;
      const importPeakKwh = dayResult.importPeakKwh * scale;
      const importOffKwh = dayResult.importOffKwh * scale;
      const exportKwh = dayResult.exportKwh * scale;

      const beforeImportKwh = beforeImportPeakKwh + beforeImportOffKwh;
      const importKwh = importPeakKwh + importOffKwh;

      const exportPeak = exportKwh * monthInput.exportPeakShare;
      const exportOff = exportKwh - exportPeak;
      const exportCredit = exportPeak * monthInput.exportPeak + exportOff * monthInput.exportOffPeak;

      const billBeforeEnergy = beforeImportPeakKwh * monthInput.importPeak + beforeImportOffKwh * monthInput.importOffPeak;
      const billBeforeNbc = beforeImportKwh * monthInput.nbcPerImportKwh;
      const billBefore = billBeforeEnergy + billBeforeNbc + monthInput.fixedMonthlyCharge;

      const billAfterEnergy = importPeakKwh * monthInput.importPeak + importOffKwh * monthInput.importOffPeak;
      const billAfterNbc = importKwh * monthInput.nbcPerImportKwh;
      const rawBillAfter = billAfterEnergy + billAfterNbc + monthInput.fixedMonthlyCharge - exportCredit;
      const savings = billBefore - rawBillAfter;

      return {
        billBefore,
        rawBillAfter,
        savings,
        importPeakKwh,
        importOffKwh,
        importKwh,
        beforeImportKwh,
        exportKwh,
        directSolarToLoad: dayResult.directSolarToLoad * scale,
        batteryToLoad: dayResult.batteryToLoad * scale,
        batteryChargeInput: dayResult.batteryChargeInput * scale
      };
    }

    function calculateAnnualEnergyAndBills(inputs, scales) {
      const rows = [];
      let annualBefore = 0;
      let annualRawAfter = 0;
      let annualImportKwh = 0;
      let annualExportKwh = 0;
      let annualDirectSolarToLoad = 0;
      let annualBatteryToLoad = 0;
      let annualBatteryChargeInput = 0;
      let annualSolarGeneration = 0;

      const exportOffPeakRate = (inputs.rates.useNem3Export ? inputs.rates.nem3ExportRate : inputs.rates.exportOffPeak) * scales.rateScale;
      const exportPeakRate = (inputs.rates.useNem3Export ? inputs.rates.nem3ExportRate : inputs.rates.exportPeak) * scales.rateScale;

      for (let month = 0; month < 12; month += 1) {
        const loadKwh = inputs.load.annualKwh * inputs.load.monthProfile[month];
        const solarKwh = inputs.sizing.modules * inputs.production.moduleKw * inputs.production.annualYield * inputs.production.monthProfile[month] * scales.solarScale;

        const monthResult = computeMonthBills({
          monthIndex: month,
          loadKwh,
          solarKwh,
          peakShare: inputs.load.peakShare,
          exportPeakShare: inputs.rates.exportPeakShare,
          importOffPeak: inputs.rates.importOffPeak * scales.rateScale,
          importPeak: inputs.rates.importPeak * scales.rateScale,
          fixedMonthlyCharge: inputs.rates.fixedMonthlyCharge,
          nbcPerImportKwh: inputs.rates.nbcPerImportKwh * scales.rateScale,
          exportOffPeak: exportOffPeakRate,
          exportPeak: exportPeakRate,
          batteries: inputs.sizing.batteries,
          usableKwhPerBattery: inputs.battery.usableKwhPerBattery,
          cyclesPerDay: inputs.battery.cyclesPerDay,
          roundTripEfficiency: inputs.battery.roundTripEfficiency,
          allowOffPeakDischarge: inputs.battery.allowOffPeakDischarge,
          days: DAYS_IN_MONTH[month],
          batteryScale: scales.batteryScale
        });

        annualBefore += monthResult.billBefore;
        annualRawAfter += monthResult.rawBillAfter;
        annualImportKwh += monthResult.importKwh;
        annualExportKwh += monthResult.exportKwh;
        annualDirectSolarToLoad += monthResult.directSolarToLoad;
        annualBatteryToLoad += monthResult.batteryToLoad;
        annualBatteryChargeInput += monthResult.batteryChargeInput;
        annualSolarGeneration += solarKwh;

        rows.push({
          month,
          monthLabel: MONTH_LABELS[month],
          loadKwh,
          solarKwh,
          ...monthResult
        });
      }

      const annualAfter = annualRawAfter;
      const annualSavings = annualBefore - annualAfter;

      return {
        annualBefore,
        annualAfter,
        annualRawAfter,
        annualSavings,
        annualImportKwh,
        annualExportKwh,
        annualDirectSolarToLoad,
        annualBatteryToLoad,
        annualBatteryChargeInput,
        annualSolarGeneration,
        annualLoadKwh: inputs.load.annualKwh,
        monthlyRows: rows
      };
    }

    function calculateScenario(inputs) {
      const modules = inputs.sizing.modules;
      const batteries = inputs.sizing.batteries;
      const solarCost = calculateSolarCost(modules, inputs.pricing);
      const batteryCost = calculateBatteryCost(batteries, inputs.pricing);
      const totalCost = solarCost + batteryCost;
      const itcCredit = inputs.incentives.applyItc ? totalCost * inputs.incentives.itcRate : 0;

      const financedPrincipal = inputs.incentives.applyItc && inputs.incentives.itcTiming === "upfront"
        ? Math.max(0, totalCost - itcCredit)
        : totalCost;

      const mortgageMonthly = calculateMortgagePayment(financedPrincipal, inputs.financing.apr, inputs.financing.years);

      const annual = calculateAnnualEnergyAndBills(inputs, {
        solarScale: 1,
        batteryScale: 1,
        rateScale: 1
      });

      const pgeBeforeMonthly = annual.annualBefore / 12;
      const pgeAfterMonthly = annual.annualAfter / 12;
      const savingsMonthly = annual.annualSavings / 12;
      const netMonthlyChange = mortgageMonthly - savingsMonthly;
      const opportunityCostMonthly = financedPrincipal * inputs.incentives.opportunityRate / 12;
      const netWithOpportunityMonthly = netMonthlyChange + opportunityCostMonthly;

      return {
        modules,
        solarKw: modules * MODULE_KW,
        batteries,
        totalCost,
        financedPrincipal,
        itcCredit,
        mortgageMonthly,
        pgeBeforeMonthly,
        pgeAfterMonthly,
        savingsMonthly,
        netMonthlyChange,
        opportunityCostMonthly,
        netWithOpportunityMonthly,
        annualBefore: annual.annualBefore,
        annualAfter: annual.annualAfter,
        annualRawAfter: annual.annualRawAfter,
        annualSavings: annual.annualSavings,
        annualLoadKwh: annual.annualLoadKwh,
        annualSolarGeneration: annual.annualSolarGeneration,
        annualImportKwh: annual.annualImportKwh,
        annualExportKwh: annual.annualExportKwh,
        annualDirectSolarToLoad: annual.annualDirectSolarToLoad,
        annualBatteryToLoad: annual.annualBatteryToLoad,
        annualBatteryChargeInput: annual.annualBatteryChargeInput
      };
    }

    function runScenarioSweep(baseInputs) {
      const maxModules = Math.max(0, Math.round(baseInputs.sizing.maxSolarKw / MODULE_KW));
      const results = [];

      for (let modules = 0; modules <= maxModules; modules += 1) {
        for (let batteries = 0; batteries <= baseInputs.sizing.maxBatteryCount; batteries += 1) {
          const result = calculateScenario({
            ...baseInputs,
            battery: { ...baseInputs.battery, count: batteries },
            sizing: { ...baseInputs.sizing, modules, batteries }
          });
          results.push(result);
        }
      }

      return results;
    }

    function rankScenarios(results, objective) {
      const scored = results.map((row) => ({
        ...row,
        objectiveValue: getObjectiveValue(row, objective)
      }));
      return scored.sort((a, b) => a.objectiveValue - b.objectiveValue || a.totalCost - b.totalCost);
    }

    function projectYears(inputs, scenario) {
      const yearly = [];
      const cumulative = [];
      let running = 0;
      let breakevenYear = null;

      for (let year = 1; year <= inputs.projection.years; year += 1) {
        const solarScale = inputs.projection.useSolarDeg ? Math.pow(1 - inputs.projection.solarDeg, year - 1) : 1;
        const batteryScale = inputs.projection.useBatteryDeg ? Math.pow(1 - inputs.projection.batteryDeg, year - 1) : 1;
        const rateScale = inputs.projection.useRateEsc ? Math.pow(1 + inputs.projection.rateEsc, year - 1) : 1;

        const annual = calculateAnnualEnergyAndBills({
          ...inputs,
          battery: { ...inputs.battery, count: scenario.batteries },
          sizing: { ...inputs.sizing, modules: scenario.modules, batteries: scenario.batteries }
        }, {
          solarScale,
          batteryScale,
          rateScale
        });

        const annualSavings = annual.annualSavings;
        const annualMortgage = year <= inputs.financing.years ? scenario.mortgageMonthly * 12 : 0;
        const annualItcBenefit = inputs.incentives.applyItc && inputs.incentives.itcTiming === "year1" && year === 1 ? scenario.itcCredit : 0;
        const annualNet = annualMortgage - annualSavings - annualItcBenefit;
        running += annualNet;

        if (running <= 0 && breakevenYear === null) {
          breakevenYear = year;
        }

        yearly.push({
          year,
          annualSavings,
          annualMortgage,
          annualItcBenefit,
          annualNet,
          cumulativeNet: running
        });
        cumulative.push(running);
      }

      return { yearly, cumulative, breakevenYear };
    }

    function syncModuleControls(inputs) {
      const maxModules = Math.max(0, Math.round(inputs.sizing.maxSolarKw / MODULE_KW));
      el.moduleRange.max = String(maxModules);
      el.moduleCount.max = String(maxModules);

      const correctedModules = clamp(Math.round(readNumber(el.moduleCount, inputs.sizing.modules)), 0, maxModules);
      el.moduleCount.value = String(correctedModules);
      el.moduleRange.value = String(correctedModules);
      el.sizingNote.textContent = "Module size is 0.395 kW; max " + maxModules + " modules (" + fmt(maxModules * MODULE_KW, 2) + " kW). Ranking objective: " + objectiveLabel(inputs.sizing.rankingObjective) + ".";
    }

    function syncRateAndIncentiveControls(inputs) {
      const nemOn = inputs.rates.useNem3Export;
      el.nem3ExportRate.disabled = !nemOn;
      el.exportOffPeak.disabled = nemOn;
      el.exportPeak.disabled = nemOn;
      el.nem3Note.textContent = nemOn
        ? "NEM 3.0 mode active: export credits fixed at " + usdPrecise(inputs.rates.nem3ExportRate) + "/kWh."
        : "NEM 3.0 override off: export rates use TOU inputs.";

      el.itcRate.disabled = !inputs.incentives.applyItc;
      el.itcTiming.disabled = !inputs.incentives.applyItc;

      const inferred = inferYieldFromZip(inputs.production.zipCode, inputs.production.manualAnnualYield);
      el.annualYield.disabled = inputs.production.autoYieldFromZip;
      if (inputs.production.autoYieldFromZip) {
        el.annualYield.value = String(inferred.annualYield);
      }
      el.zipYieldNote.textContent = inputs.production.autoYieldFromZip
        ? "Yield inferred from ZIP: " + inferred.annualYield + " kWh/kW-yr (" + inferred.label + ")."
        : "Manual yield in use. ZIP inference disabled.";

      el.matrixHeading.textContent = "Scenario Matrix (" + objectiveLabel(inputs.sizing.rankingObjective) + ")";
      el.matrixNote.textContent = inputs.sizing.rankingObjective === "annualSavings"
        ? "Click a matrix cell to set scenario selection. Higher values are better for this objective."
        : "Click a matrix cell to set scenario selection. Lower values are better for this objective.";
    }

    function renderCards(selectedScenario, inputs) {
      el.cardInstallCost.textContent = usd(selectedScenario.totalCost);
      el.cardFinanced.textContent = usd(selectedScenario.financedPrincipal);

      if (!inputs.incentives.applyItc) {
        el.cardItcApplied.textContent = "ITC not applied";
      } else if (inputs.incentives.itcTiming === "upfront") {
        el.cardItcApplied.textContent = "ITC reduces financed principal by " + usdPrecise(selectedScenario.itcCredit);
      } else {
        el.cardItcApplied.textContent = "ITC modeled as Year 1 lump-sum credit: " + usdPrecise(selectedScenario.itcCredit);
      }

      el.cardMortgage.textContent = usdPrecise(selectedScenario.mortgageMonthly);
      el.cardPgeBefore.textContent = usdPrecise(selectedScenario.pgeBeforeMonthly);
      el.cardPgeAfter.textContent = usdPrecise(selectedScenario.pgeAfterMonthly);
      el.cardTrueUpNote.textContent = selectedScenario.annualRawAfter < 0
        ? "Annual subtotal includes export credits: " + usdPrecise(selectedScenario.annualRawAfter)
        : "Annual subtotal: " + usdPrecise(selectedScenario.annualRawAfter);
      el.cardSavings.textContent = usdPrecise(selectedScenario.savingsMonthly);
      el.cardNet.textContent = usdPrecise(selectedScenario.netMonthlyChange);
      el.cardNetOpp.textContent = usdPrecise(selectedScenario.netWithOpportunityMonthly);

      el.cardNet.classList.toggle("good", selectedScenario.netMonthlyChange < 0);
      el.cardNet.classList.toggle("bad", selectedScenario.netMonthlyChange >= 0);
      el.cardNetOpp.classList.toggle("good", selectedScenario.netWithOpportunityMonthly < 0);
      el.cardNetOpp.classList.toggle("bad", selectedScenario.netWithOpportunityMonthly >= 0);
    }

    function renderEnergyBreakdown(selectedScenario) {
      el.energyImport.textContent = "Grid import: " + kwh(selectedScenario.annualImportKwh) + "/yr";
      el.energyExport.textContent = "Solar export: " + kwh(selectedScenario.annualExportKwh) + "/yr";
      el.energyDirectSolar.textContent = "Direct solar to load: " + kwh(selectedScenario.annualDirectSolarToLoad) + "/yr";
      el.energyBatteryToLoad.textContent = "Battery to load: " + kwh(selectedScenario.annualBatteryToLoad) + "/yr";

      const deliveredSolar = selectedScenario.annualDirectSolarToLoad + selectedScenario.annualBatteryToLoad;
      const selfConsumption = selectedScenario.annualSolarGeneration > 0
        ? deliveredSolar / selectedScenario.annualSolarGeneration
        : 0;
      el.energySelfConsumption.textContent = "Solar self-consumption (delivered to load): " + fmt(selfConsumption * 100, 1) + "%.";
    }

    function renderBestSummary(best, objective) {
      el.bestSummary.innerHTML = "";
      const chunks = [
        "Best by " + objectiveLabel(objective),
        best.modules + " modules",
        fmt(best.solarKw, 2) + " kW",
        best.batteries + " PW",
        "Cost " + usd(best.totalCost),
        "Objective " + formatObjectiveValue(best, objective)
      ];

      for (const text of chunks) {
        const node = document.createElement("div");
        node.className = "pill";
        node.textContent = text;
        el.bestSummary.appendChild(node);
      }

      const netNode = document.createElement("div");
      netNode.className = "pill " + (best.netMonthlyChange < 0 ? "good" : "bad");
      netNode.textContent = "Recurring net/mo " + usdPrecise(best.netMonthlyChange);
      el.bestSummary.appendChild(netNode);
    }

    function renderTopFive(ranked, selectedScenario, objective) {
      const top = ranked.slice(0, 5);
      el.topFiveBody.innerHTML = "";

      top.forEach((row, idx) => {
        const tr = document.createElement("tr");
        if (row.modules === selectedScenario.modules && row.batteries === selectedScenario.batteries) {
          tr.style.background = "rgba(224, 141, 0, 0.18)";
        }

        const objectiveClass = objective === "annualSavings"
          ? "good"
          : (row.objectiveValue < 0 ? "good" : "bad");

        tr.innerHTML = [
          "<td>" + (idx + 1) + "</td>",
          "<td>" + row.modules + "</td>",
          "<td>" + fmt(row.solarKw, 2) + "</td>",
          "<td>" + row.batteries + "</td>",
          "<td>" + usd(row.totalCost) + "</td>",
          "<td>" + usd(row.financedPrincipal) + "</td>",
          "<td>" + usdPrecise(row.mortgageMonthly) + "</td>",
          "<td class='good'>" + usdPrecise(row.savingsMonthly) + "</td>",
          "<td class='" + (row.netMonthlyChange < 0 ? "good" : "bad") + "'>" + usdPrecise(row.netMonthlyChange) + "</td>",
          "<td class='" + (row.netWithOpportunityMonthly < 0 ? "good" : "bad") + "'>" + usdPrecise(row.netWithOpportunityMonthly) + "</td>",
          "<td class='" + objectiveClass + "'>" + formatObjectiveValue(row, objective) + "</td>"
        ].join("");

        tr.addEventListener("click", () => {
          el.moduleCount.value = String(row.modules);
          el.moduleRange.value = String(row.modules);
          el.batteryCount.value = String(row.batteries);
          render();
        });

        el.topFiveBody.appendChild(tr);
      });
    }

    function renderMatrix(inputs, ranked, selectedScenario) {
      const maxModules = Math.max(0, Math.round(inputs.sizing.maxSolarKw / MODULE_KW));
      const objective = inputs.sizing.rankingObjective;
      const table = el.matrixTable;
      table.innerHTML = "";

      const best = ranked[0];
      const byKey = new Map();
      ranked.forEach((row) => byKey.set(row.modules + "-" + row.batteries, row));

      const thead = document.createElement("thead");
      const htr = document.createElement("tr");
      htr.innerHTML = "<th>Solar (modules / kW)</th><th>0 PW</th><th>1 PW</th><th>2 PW</th>";
      thead.appendChild(htr);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      for (let m = 0; m <= maxModules; m += 1) {
        const tr = document.createElement("tr");
        const label = document.createElement("td");
        label.textContent = m + " / " + fmt(m * MODULE_KW, 2);
        tr.appendChild(label);

        for (let b = 0; b <= 2; b += 1) {
          const key = m + "-" + b;
          const row = byKey.get(key);
          const td = document.createElement("td");
          td.className = "matrix-cell";

          if (!row) {
            td.textContent = "--";
          } else if (objective === "annualSavings") {
            td.textContent = usd(Math.round(row.annualSavings));
          } else {
            td.textContent = usdPrecise(getObjectiveValue(row, objective));
          }

          if (row && row.modules === selectedScenario.modules && row.batteries === selectedScenario.batteries) {
            td.classList.add("cell-selected");
          }
          if (row && best && row.modules === best.modules && row.batteries === best.batteries) {
            td.classList.add("cell-best");
          }

          td.addEventListener("click", () => {
            el.moduleCount.value = String(m);
            el.moduleRange.value = String(m);
            el.batteryCount.value = String(b);
            render();
          });

          tr.appendChild(td);
        }

        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
    }

    function drawProjectionChart(yearly) {
      const canvas = el.projectionChart;
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      if (!yearly.length) return;

      const left = 48;
      const right = width - 16;
      const top = 16;
      const bottom = height - 34;
      const plotW = right - left;
      const plotH = bottom - top;

      const values = yearly.map((v) => v.cumulativeNet);
      const minY = Math.min(0, ...values);
      const maxY = Math.max(0, ...values);
      const spanY = Math.max(1, maxY - minY);

      const xAt = (i) => left + (plotW * i) / Math.max(1, yearly.length - 1);
      const yAt = (v) => bottom - ((v - minY) / spanY) * plotH;

      ctx.strokeStyle = "#6f7e75";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(left, top);
      ctx.lineTo(left, bottom);
      ctx.lineTo(right, bottom);
      ctx.stroke();

      const yTicks = 5;
      ctx.font = "12px 'Avenir Next', sans-serif";
      ctx.fillStyle = "#48534a";
      for (let i = 0; i <= yTicks; i += 1) {
        const p = i / yTicks;
        const y = top + p * plotH;
        const val = maxY - p * spanY;
        ctx.strokeStyle = "rgba(40, 55, 44, 0.12)";
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(right, y);
        ctx.stroke();
        ctx.fillText(usd(val), 4, y + 4);
      }

      const yZero = yAt(0);
      ctx.strokeStyle = "rgba(224, 141, 0, 0.9)";
      ctx.beginPath();
      ctx.moveTo(left, yZero);
      ctx.lineTo(right, yZero);
      ctx.stroke();

      ctx.strokeStyle = "#0c7a52";
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      yearly.forEach((row, i) => {
        const x = xAt(i);
        const y = yAt(row.cumulativeNet);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      yearly.forEach((row, i) => {
        const x = xAt(i);
        const y = yAt(row.cumulativeNet);
        ctx.fillStyle = row.cumulativeNet <= 0 ? "#0f8a4f" : "#b03b28";
        ctx.beginPath();
        ctx.arc(x, y, 2.7, 0, Math.PI * 2);
        ctx.fill();
      });

      const xTicks = Math.min(yearly.length, 8);
      ctx.fillStyle = "#48534a";
      for (let i = 0; i < xTicks; i += 1) {
        const idx = Math.round((i * (yearly.length - 1)) / Math.max(1, xTicks - 1));
        const x = xAt(idx);
        ctx.fillText("Y" + yearly[idx].year, x - 10, height - 12);
      }
    }

    function renderProjection(projection) {
      el.projectionBody.innerHTML = "";
      projection.yearly.forEach((row) => {
        const tr = document.createElement("tr");
        tr.innerHTML = [
          "<td>" + row.year + "</td>",
          "<td class='good'>" + usdPrecise(row.annualSavings) + "</td>",
          "<td>" + usdPrecise(row.annualMortgage) + "</td>",
          "<td class='" + (row.annualNet < 0 ? "good" : "bad") + "'>" + usdPrecise(row.annualNet) + "</td>",
          "<td class='" + (row.cumulativeNet < 0 ? "good" : "bad") + "'>" + usdPrecise(row.cumulativeNet) + "</td>"
        ].join("");
        el.projectionBody.appendChild(tr);
      });

      const last = projection.yearly[projection.yearly.length - 1];
      const horizon = projection.yearly.length;
      el.projectionCumulative.textContent = horizon + "-year cumulative: " + usdPrecise(last ? last.cumulativeNet : 0);
      el.projectionBreakEven.textContent = "Break-even year: " + (projection.breakevenYear ?? "None within horizon");
      drawProjectionChart(projection.yearly);
    }

    function runModelChecks(inputs, ranked) {
      const checks = [];

      const anchorPricing = {
        solarBaseCost: DEFAULT_PRICING.solarBaseCost,
        solarPerModuleCost: DEFAULT_PRICING.solarPerModuleCost,
        batteryCost1: DEFAULT_PRICING[1],
        batteryCost2: DEFAULT_PRICING[2]
      };
      checks.push({
        name: "Cost anchors",
        ok: calculateSolarCost(10, anchorPricing) === 13710 &&
          calculateSolarCost(14, anchorPricing) === 18110 &&
          calculateBatteryCost(1, anchorPricing) === 16875 &&
          calculateBatteryCost(2, anchorPricing) === 31250
      });

      const zero = calculateScenario({
        ...inputs,
        battery: { ...inputs.battery, count: 0 },
        sizing: { ...inputs.sizing, modules: 0, batteries: 0 }
      });
      checks.push({
        name: "Zero baseline",
        ok: Math.abs(zero.mortgageMonthly) < 0.001 && Math.abs(zero.savingsMonthly) < 0.001 && Math.abs(zero.netMonthlyChange) < 0.001
      });

      const pmtTest = calculateMortgagePayment(100000, 0.06, 15);
      checks.push({
        name: "Mortgage PMT sanity",
        ok: Math.abs(pmtTest - 843.86) < 0.4
      });

      const monotonicBase = {
        monthIndex: 0,
        loadKwh: 1200,
        solarKwh: 0,
        peakShare: 0.4,
        exportPeakShare: 0.2,
        importOffPeak: inputs.rates.importOffPeak,
        importPeak: inputs.rates.importPeak,
        fixedMonthlyCharge: inputs.rates.fixedMonthlyCharge,
        nbcPerImportKwh: inputs.rates.nbcPerImportKwh,
        exportOffPeak: inputs.rates.exportOffPeak,
        exportPeak: inputs.rates.exportPeak,
        batteries: 0,
        usableKwhPerBattery: BATTERY_USABLE_KWH,
        cyclesPerDay: 0.85,
        roundTripEfficiency: 0.9,
        allowOffPeakDischarge: false,
        days: 31,
        batteryScale: 1
      };
      const m1 = computeMonthBills(monotonicBase);
      const m2 = computeMonthBills({ ...monotonicBase, solarKwh: 700, monthIndex: 5 });
      checks.push({
        name: "Solar lowers grid import",
        ok: m2.importKwh < m1.importKwh
      });

      const rankedAgain = rankScenarios(ranked, inputs.sizing.rankingObjective);
      checks.push({
        name: "Ranking objective",
        ok: rankedAgain.length === 0 || rankedAgain[0].objectiveValue <= rankedAgain[rankedAgain.length - 1].objectiveValue
      });

      const probeScenario = rankedAgain[0] || zero;
      const projectionProbe = projectYears({
        ...inputs,
        projection: { ...inputs.projection, years: inputs.financing.years + 2 }
      }, probeScenario);
      const afterLoanRow = projectionProbe.yearly[inputs.financing.years];
      checks.push({
        name: "Loan stops at term",
        ok: afterLoanRow ? Math.abs(afterLoanRow.annualMortgage) < 0.001 : true
      });

      const passCount = checks.filter((c) => c.ok).length;
      const output = checks.map((c) => (c.ok ? "OK " : "WARN ") + c.name).join(" | ");
      el.checksOutput.textContent = "Model checks: " + passCount + "/" + checks.length + " passing. " + output;
    }

    function render() {
      const inputs = collectInputs();
      syncModuleControls(inputs);
      syncRateAndIncentiveControls(inputs);

      const selectedScenario = calculateScenario(inputs);
      const sweep = runScenarioSweep(inputs);
      const ranked = rankScenarios(sweep, inputs.sizing.rankingObjective);
      latestRankedScenarios = ranked;
      latestBestScenario = ranked[0] || null;

      renderCards(selectedScenario, inputs);
      renderEnergyBreakdown(selectedScenario);
      if (latestBestScenario) {
        renderBestSummary(latestBestScenario, inputs.sizing.rankingObjective);
      }

      const selectedLabel = selectedScenario.modules + " modules / " + fmt(selectedScenario.solarKw, 2) + " kW / " + selectedScenario.batteries + " PW";
      if (latestBestScenario) {
        const bestLabel = latestBestScenario.modules + " modules / " + fmt(latestBestScenario.solarKw, 2) + " kW / " + latestBestScenario.batteries + " PW";
        const sameSelection = selectedScenario.modules === latestBestScenario.modules && selectedScenario.batteries === latestBestScenario.batteries;
        el.selectionStatus.textContent = sameSelection
          ? "Selected scenario matches best scenario for " + objectiveLabel(inputs.sizing.rankingObjective) + "."
          : "Selected: " + selectedLabel + " | Best by objective: " + bestLabel + ".";
      } else {
        el.selectionStatus.textContent = "Selected: " + selectedLabel;
      }

      renderTopFive(ranked, selectedScenario, inputs.sizing.rankingObjective);
      renderMatrix(inputs, ranked, selectedScenario);

      const projection = projectYears(inputs, selectedScenario);
      renderProjection(projection);
      runModelChecks(inputs, ranked);
    }

    function bindEvents() {
      const inputs = document.querySelectorAll("input, select");
      inputs.forEach((node) => {
        node.addEventListener("input", () => {
          if (node === el.moduleRange) {
            el.moduleCount.value = el.moduleRange.value;
          } else if (node === el.moduleCount) {
            el.moduleRange.value = el.moduleCount.value;
          }
          scheduleRender();
        });
      });

      el.applyBestBtn.addEventListener("click", () => {
        if (!latestBestScenario) return;
        el.moduleCount.value = String(latestBestScenario.modules);
        el.moduleRange.value = String(latestBestScenario.modules);
        el.batteryCount.value = String(latestBestScenario.batteries);
        render();
      });

      window.addEventListener("resize", () => {
        scheduleRender();
      });
    }

    function scheduleRender() {
      if (renderTimer !== null) {
        clearTimeout(renderTimer);
      }
      renderTimer = window.setTimeout(() => {
        renderTimer = null;
        render();
      }, 100);
    }

    function bootstrapDefaults() {
      el.annualLoadKwh.value = String(DEFAULTS.annualLoadKwh);
      el.zipCode.value = DEFAULTS.zipCode;
      el.autoYieldFromZip.checked = DEFAULTS.autoYieldFromZip;
      el.annualYield.value = String(DEFAULTS.annualYield);
      el.peakLoadShare.value = String(DEFAULTS.peakLoadShare * 100);
      el.exportPeakShare.value = String(DEFAULTS.exportPeakShare * 100);
      el.importOffPeak.value = String(DEFAULTS.importOffPeak);
      el.importPeak.value = String(DEFAULTS.importPeak);
      el.fixedMonthlyCharge.value = String(DEFAULTS.fixedMonthlyCharge);
      el.nbcPerImportKwh.value = String(DEFAULTS.nbcPerImportKwh);
      el.useNem3Export.checked = DEFAULTS.useNem3Export;
      el.nem3ExportRate.value = String(DEFAULTS.nem3ExportRate);
      el.exportOffPeak.value = String(DEFAULTS.exportOffPeak);
      el.exportPeak.value = String(DEFAULTS.exportPeak);
      el.solarBaseCost.value = String(DEFAULTS.solarBaseCost);
      el.solarPerModuleCost.value = String(DEFAULTS.solarPerModuleCost);
      el.batteryCost1.value = String(DEFAULTS.batteryCost1);
      el.batteryCost2.value = String(DEFAULTS.batteryCost2);
      el.cyclesPerDay.value = String(DEFAULTS.cyclesPerDay);
      el.roundTripEff.value = String(DEFAULTS.roundTripEff * 100);
      el.apr.value = String(DEFAULTS.apr * 100);
      el.financeYears.value = String(DEFAULTS.financeYears);
      el.applyItc.checked = DEFAULTS.applyItc;
      el.itcRate.value = String(DEFAULTS.itcRate * 100);
      el.itcTiming.value = DEFAULTS.itcTiming;
      el.opportunityRate.value = String(DEFAULTS.opportunityRate * 100);
      el.maxSolarKw.value = String(DEFAULTS.maxSolarKw);
      el.moduleCount.value = String(DEFAULTS.moduleCount);
      el.moduleRange.value = String(DEFAULTS.moduleCount);
      el.batteryCount.value = String(DEFAULTS.batteryCount);
      el.rankingObjective.value = DEFAULTS.rankingObjective;
      el.projectionYears.value = String(DEFAULTS.projectionYears);
      el.solarDeg.value = String(DEFAULTS.solarDeg * 100);
      el.batteryDeg.value = String(DEFAULTS.batteryDeg * 100);
      el.rateEsc.value = String(DEFAULTS.rateEsc * 100);
      el.toggleSolarDeg.checked = DEFAULTS.toggleSolarDeg;
      el.toggleBatteryDeg.checked = DEFAULTS.toggleBatteryDeg;
      el.toggleRateEsc.checked = DEFAULTS.toggleRateEsc;
    }

    bootstrapDefaults();
    bindEvents();
    render();
  </script>
</body>
</html>
