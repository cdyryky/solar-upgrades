<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Solar Upgrade Analyzer v2.5</title>
  <style>
    :root {
      --bg: #f4f6ef;
      --panel: #ffffff;
      --panel-soft: #f8fbf4;
      --text: #1e2d22;
      --muted: #516457;
      --line: #d6e0d1;
      --accent: #0d7750;
      --accent-soft: #d8f1e4;
      --warn: #a74d1a;
      --warn-soft: #ffe7d8;
      --good: #197a44;
      --bad: #992f22;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Avenir Next", "Segoe UI", "Trebuchet MS", sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 10% 0%, #fdf4dd 0%, rgba(253, 244, 221, 0) 45%),
        radial-gradient(circle at 90% 0%, #dff4ec 0%, rgba(223, 244, 236, 0) 42%),
        var(--bg);
    }

    .shell {
      max-width: 1240px;
      margin: 0 auto;
      padding: 20px 16px 28px;
    }

    .title {
      margin: 0;
      font-size: 1.9rem;
      letter-spacing: 0.015em;
    }

    .subtitle {
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 0.96rem;
      line-height: 1.42;
      max-width: 900px;
    }

    .layout {
      margin-top: 18px;
      display: grid;
      grid-template-columns: 370px 1fr;
      gap: 12px;
      align-items: start;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 8px 22px rgba(23, 40, 28, 0.06);
    }

    .panel.inputs {
      position: sticky;
      top: 10px;
      max-height: calc(100vh - 20px);
      overflow: auto;
      padding: 12px;
    }

    .panel.results {
      padding: 12px;
      background: linear-gradient(180deg, #fcfffb 0%, #f7fbf5 100%);
    }

    h2 {
      margin: 4px 0 10px;
      font-size: 1.05rem;
    }

    h3 {
      margin: 0 0 8px;
      font-size: 0.94rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #384b3f;
    }

    .group {
      background: var(--panel-soft);
      border: 1px solid #e3ebdf;
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 10px;
    }

    .field {
      margin-bottom: 9px;
    }

    .field:last-child {
      margin-bottom: 0;
    }

    label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.85rem;
      color: #3f5145;
    }

    input,
    select,
    button {
      width: 100%;
      border-radius: 9px;
      border: 1px solid #c8d3c3;
      background: #fff;
      color: var(--text);
      font: inherit;
      font-size: 0.95rem;
      padding: 9px 10px;
    }

    input:focus,
    select:focus,
    button:focus {
      outline: none;
      border-color: #6ea886;
      box-shadow: 0 0 0 2px rgba(110, 168, 134, 0.22);
    }

    input[type="checkbox"] {
      width: auto;
      transform: translateY(1px);
      margin-right: 7px;
    }

    .checkline {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.91rem;
      color: #3f5145;
    }

    .month-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 4px;
      margin-top: 4px;
    }

    .month-grid .checkline {
      font-size: 0.8rem;
      padding: 3px 4px;
      border-radius: 6px;
      background: #f2f7ef;
      border: 1px solid #dde8d8;
    }

    .month-grid.monthly-reserve .checkline {
      justify-content: space-between;
      gap: 8px;
    }

    .month-grid.monthly-reserve input[type="number"] {
      width: 70px;
      margin-left: auto;
      padding: 5px 6px;
      font-size: 0.78rem;
    }

    .hint {
      margin-top: 5px;
      color: var(--muted);
      font-size: 0.8rem;
      line-height: 1.3;
    }

    .climate-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-top: 5px;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid #cfdccd;
      background: #f4f8f1;
      color: #3c5044;
      font-size: 0.78rem;
      line-height: 1.2;
      font-weight: 600;
    }

    .climate-badge-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #6a7d70;
      flex: 0 0 auto;
    }

    .climate-badge-live {
      border-color: #86c6a5;
      background: #eaf8f0;
      color: #1d5b3a;
    }

    .climate-badge-live .climate-badge-dot {
      background: #1f8b4c;
    }

    .climate-badge-cached {
      border-color: #d8be84;
      background: #fff6e3;
      color: #70510d;
    }

    .climate-badge-cached .climate-badge-dot {
      background: #b98316;
    }

    .climate-badge-fallback {
      border-color: #d89a8e;
      background: #fff0ed;
      color: #853224;
    }

    .climate-badge-fallback .climate-badge-dot {
      background: #ad3f2e;
    }

    .field-error {
      margin-top: 4px;
      color: var(--bad);
      font-size: 0.78rem;
      line-height: 1.25;
      min-height: 1em;
    }

    .input-error {
      border-color: #ce553d !important;
      background: #fff7f4 !important;
    }

    .actions {
      display: grid;
      gap: 8px;
      margin-top: 10px;
    }

    button {
      background: linear-gradient(180deg, #0e915f 0%, #0a744b 100%);
      color: #fff;
      border-color: #0a744b;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.52;
    }

    .cards {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }

    .cards-header {
      margin: 0 0 6px;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #5b6f61;
    }

    .cards-group {
      margin-bottom: 10px;
    }

    .card {
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      min-height: 90px;
    }

    .k {
      font-size: 0.8rem;
      letter-spacing: 0.01em;
      color: #4e6154;
      margin-bottom: 4px;
    }

    .v {
      font-size: 1.22rem;
      font-weight: 700;
      color: #183025;
      line-height: 1.2;
    }

    .sub {
      margin-top: 3px;
      color: #5c7163;
      font-size: 0.78rem;
      line-height: 1.25;
    }

    .good {
      color: var(--good);
    }

    .bad {
      color: var(--bad);
    }

    .section {
      margin-top: 10px;
      border: 1px solid var(--line);
      background: #fff;
      border-radius: 10px;
      padding: 10px;
    }

    .table-wrap {
      overflow: auto;
      border: 1px solid #dce6d8;
      border-radius: 8px;
      background: #fff;
    }

    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    .results-table th,
    .results-table td {
      border-bottom: 1px solid #e3ece0;
      border-right: 1px solid #e8f0e5;
      padding: 6px 7px;
      text-align: right;
      white-space: nowrap;
    }

    .results-table th:first-child,
    .results-table td:first-child {
      text-align: left;
    }

    .results-table thead th {
      position: sticky;
      top: 0;
      z-index: 1;
      background: #eff7ea;
      color: #355043;
      font-weight: 700;
    }

    .matrix-cell {
      cursor: pointer;
    }

    .matrix-cell-selected {
      background: #e6f4ec;
      outline: 2px solid #2f8e63;
      outline-offset: -2px;
    }

    .row-selected {
      background: #eff8f1;
    }

    details.calc-details {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      margin-top: 10px;
      overflow: hidden;
    }

    details.calc-details > summary {
      cursor: pointer;
      list-style: none;
      padding: 10px;
      font-weight: 600;
      color: #2c4035;
      background: #f4f8f1;
      border-bottom: 1px solid #e1eadc;
    }

    details.calc-details > summary::-webkit-details-marker {
      display: none;
    }

    details.collapsible {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      margin-bottom: 10px;
      overflow: hidden;
    }

    details.collapsible > summary {
      cursor: pointer;
      list-style: none;
      padding: 10px;
      font-weight: 600;
      color: #2c4035;
      background: #f4f8f1;
      border-bottom: 1px solid #e1eadc;
    }

    details.collapsible > summary::-webkit-details-marker {
      display: none;
    }

    details.collapsible > .section {
      margin-top: 0;
      border: none;
      border-radius: 0;
    }

    details.collapsible > .group {
      margin: 0;
      border: none;
      border-radius: 0;
      border-top: 1px solid #e3ebdf;
    }

    details.collapsible > .group:first-of-type {
      border-top: none;
    }

    .calc-body {
      padding: 10px;
      font-size: 0.85rem;
      line-height: 1.45;
      color: #33483b;
    }

    .calc-line {
      margin: 0 0 6px;
    }

    .calc-table {
      width: 100%;
      border-collapse: collapse;
      margin: 8px 0 10px;
      font-size: 0.8rem;
    }

    .calc-table th,
    .calc-table td {
      border: 1px solid #dbe6d6;
      padding: 6px 7px;
      text-align: right;
      white-space: nowrap;
    }

    .calc-table th:first-child,
    .calc-table td:first-child {
      text-align: left;
    }

    .calc-table thead th {
      background: #f2f7ef;
      color: #355043;
      font-weight: 600;
    }

    .inline-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 7px;
    }

    .pill {
      background: #f4f8f1;
      border: 1px solid #dce8d7;
      border-radius: 999px;
      padding: 5px 10px;
      font-size: 0.78rem;
      color: #3e5145;
    }

    .summary {
      margin: 6px 0 0;
      color: #304338;
      font-size: 0.88rem;
      line-height: 1.35;
    }

    .error-box {
      display: none;
      margin-bottom: 10px;
      border: 1px solid #e3a67e;
      border-radius: 10px;
      background: var(--warn-soft);
      color: #6d3012;
      padding: 9px 10px;
      font-size: 0.85rem;
      line-height: 1.35;
    }

    .climate-banner {
      display: none;
      margin-bottom: 10px;
      border: 1px solid #d78273;
      border-radius: 10px;
      background: #fff2ef;
      color: #6f2519;
      padding: 9px 10px;
    }

    .climate-banner.visible {
      display: block;
    }

    .climate-banner-title {
      font-size: 0.87rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      margin-bottom: 4px;
    }

    .climate-banner-body {
      font-size: 0.82rem;
      line-height: 1.35;
    }

    .climate-banner-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .climate-banner-actions button {
      width: auto;
      padding: 7px 10px;
      font-size: 0.8rem;
      line-height: 1.2;
    }

    .secondary-btn {
      background: #fff;
      color: #4b5f53;
      border-color: #bdcbc3;
      box-shadow: none;
    }

    .checks {
      color: #32463a;
      font-size: 0.84rem;
      line-height: 1.35;
    }

    .check-row {
      display: block;
      margin-bottom: 5px;
    }

    .check-ok {
      color: #176f3f;
      font-weight: 600;
    }

    .check-warn {
      color: #8e331f;
      font-weight: 600;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 0.78rem;
      color: #4d6357;
    }

    .hidden {
      display: none !important;
    }

    @media (max-width: 1100px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .panel.inputs {
        position: static;
        max-height: none;
      }
    }

    @media (max-width: 760px) {
      .cards {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 560px) {
      .cards {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <h1 class="title">Solar Upgrade Analyzer v2.5</h1>
    <p class="subtitle">
      Solar + storage sizing with hourly dispatch, annual true-up rollover, clipping-aware PV limits, and VPP-aware returns.
      <strong>Objective is configurable (NPV, total outflow, or utility-bill knee point).</strong>
    </p>

    <div class="layout">
      <aside class="panel inputs">
        <h2>Inputs</h2>

        <div class="group">
          <h3>Sizing</h3>
          <div class="field">
            <label for="powerwallCount">Preferred Powerwalls for primary view</label>
            <select id="powerwallCount">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2" selected>2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
          </div>
          <div class="field">
            <label class="checkline"><input id="lockPowerwallCount" type="checkbox" /> Lock optimization to selected Powerwalls</label>
          </div>
          <div class="field">
            <label for="solarSearchMinKw">Solar search min (kW)</label>
            <input id="solarSearchMinKw" type="number" min="0" step="0.05" value="2" />
          </div>
          <div class="field">
            <label for="solarSearchMaxKw">Solar search max (kW)</label>
            <input id="solarSearchMaxKw" type="number" min="0" step="0.05" value="20" />
          </div>
          <div class="field">
            <label for="solarSearchStepKw">Solar search step (kW)</label>
            <input id="solarSearchStepKw" type="number" min="0.01" step="0.01" value="0.1" />
          </div>
          <div class="field">
            <label for="sizingObjective">Sizing objective</label>
            <select id="sizingObjective">
              <option value="return_npv" selected>Maximize return (NPV + payback tie-break)</option>
              <option value="total_outflow">Minimize total outflow (Mortgage + PG&amp;E)</option>
              <option value="utility_bill_knee">Utility bill knee-point (Pareto)</option>
            </select>
          </div>
          <div class="hint" id="sizingObjectiveHint">Objective: maximize NPV, then faster payback, then lower outflow.</div>
          <div class="hint" id="sweepModeHint">Optimizer sweeps all battery counts (0-4) across your solar range.</div>
        </div>

        <div class="group">
          <h3>Physical Constraints: Home + Yield</h3>
          <div class="field">
            <label for="annualLoadKwh">Annual home load (non-EV kWh)</label>
            <input id="annualLoadKwh" type="number" min="0" step="100" value="24000" />
          </div>
          <div class="field">
            <label for="zipCode">ZIP code (5-digit)</label>
            <input id="zipCode" type="text" value="95672" />
          </div>
          <div class="field">
            <label for="nrelApiKey">NREL API key (optional)</label>
            <input id="nrelApiKey" type="text" value="" placeholder="DEMO_KEY is used when empty" autocomplete="off" />
          </div>
          <div class="hint" id="zipYieldNote">Yield profile: --</div>
          <div class="climate-badge" id="climateDataBadge">
            <span class="climate-badge-dot"></span>
            <span>Climate Data: --</span>
          </div>
        </div>

        <div class="group">
          <h3>Load Shaping: Whole House Fan</h3>
          <div class="field">
            <label class="checkline"><input id="enableWhf" type="checkbox" /> Enable WHF load replacement</label>
          </div>
          <div class="field">
            <label for="whfMode">WHF mode</label>
            <select id="whfMode">
              <option value="auto" selected>Auto (temperature-guided)</option>
              <option value="manual">Manual window + success</option>
            </select>
          </div>
          <div id="whfFields">
            <div class="field">
              <label for="whfFanWatts">Fan power (W)</label>
              <input id="whfFanWatts" type="number" min="0" step="10" value="200" />
            </div>
            <div class="field">
              <label for="whfDisplacedAcWatts">Displaced AC load (W)</label>
              <input id="whfDisplacedAcWatts" type="number" min="0" step="50" value="3500" />
            </div>
            <div id="whfManualFields">
              <div class="field">
                <label for="whfStartHour">Start hour</label>
                <input id="whfStartHour" type="number" min="0" max="23" step="1" value="20" />
              </div>
              <div class="field">
                <label for="whfStartMinute">Start minute</label>
                <input id="whfStartMinute" type="number" min="0" max="59" step="1" value="30" />
              </div>
              <div class="field">
                <label for="whfEndHour">End hour</label>
                <input id="whfEndHour" type="number" min="0" max="23" step="1" value="6" />
              </div>
              <div class="field">
                <label for="whfEndMinute">End minute</label>
                <input id="whfEndMinute" type="number" min="0" max="59" step="1" value="0" />
              </div>
              <div class="field">
                <label>Active months</label>
                <div class="month-grid" id="whfMonths">
                  <label class="checkline"><input data-whf-month="0" type="checkbox" /> Jan</label>
                  <label class="checkline"><input data-whf-month="1" type="checkbox" /> Feb</label>
                  <label class="checkline"><input data-whf-month="2" type="checkbox" /> Mar</label>
                  <label class="checkline"><input data-whf-month="3" type="checkbox" /> Apr</label>
                  <label class="checkline"><input data-whf-month="4" type="checkbox" checked /> May</label>
                  <label class="checkline"><input data-whf-month="5" type="checkbox" checked /> Jun</label>
                  <label class="checkline"><input data-whf-month="6" type="checkbox" checked /> Jul</label>
                  <label class="checkline"><input data-whf-month="7" type="checkbox" checked /> Aug</label>
                  <label class="checkline"><input data-whf-month="8" type="checkbox" checked /> Sep</label>
                  <label class="checkline"><input data-whf-month="9" type="checkbox" /> Oct</label>
                  <label class="checkline"><input data-whf-month="10" type="checkbox" /> Nov</label>
                  <label class="checkline"><input data-whf-month="11" type="checkbox" /> Dec</label>
                </div>
              </div>
              <div class="field">
                <label for="whfSuccessRatePct">WHF success rate (%)</label>
                <input id="whfSuccessRatePct" type="number" min="0" max="100" step="1" value="85" />
              </div>
            </div>
          </div>
          <div class="hint" id="whfNote">WHF: OFF.</div>
          <div class="hint">Auto mode derives month windows and success from hourly temperatures (55F-82F eligibility + cooling stress).</div>
          <div class="hint">Rescue manual preset: May-Sep, 20:30-06:00, 3500W displaced AC, 200W fan, 85% success.</div>
        </div>

        <div class="group">
          <h3>Load Shaping: HomeAssistant HVAC Shift</h3>
          <div class="field">
            <label for="tempUnitsDisplay">Temperature units</label>
            <input id="tempUnitsDisplay" type="text" value="F (fixed)" readonly />
          </div>
          <div class="field">
            <label for="summerSetpointF">Summer HVAC setpoint (F)</label>
            <input id="summerSetpointF" type="number" min="55" max="90" step="1" value="74" />
          </div>
          <div class="field">
            <label for="winterSetpointF">Winter HVAC setpoint (F)</label>
            <input id="winterSetpointF" type="number" min="55" max="90" step="1" value="68" />
          </div>
          <div class="hint">Setpoints always affect utility/load estimates, even if HVAC shifting is OFF.</div>
          <div class="field">
            <label class="checkline"><input id="enableHaShift" type="checkbox" /> Enable HVAC pre-cool/pre-heat load shift</label>
          </div>
          <div class="field">
            <label for="haMode">HVAC shift mode</label>
            <select id="haMode">
              <option value="auto" selected>Auto (temperature-guided)</option>
              <option value="manual">Manual success + pre-window</option>
            </select>
          </div>
          <div id="haFields">
            <div class="field">
              <label for="maxPrecoolOffsetF">Max pre-cool offset (F)</label>
              <input id="maxPrecoolOffsetF" type="number" min="0" max="10" step="0.5" value="3" />
            </div>
            <div class="field">
              <label for="maxPreheatOffsetF">Max pre-heat offset (F)</label>
              <input id="maxPreheatOffsetF" type="number" min="0" max="10" step="0.5" value="2" />
            </div>
            <div class="field">
              <label for="maxPeakRelaxOffsetF">Max peak-hour setpoint drift (F)</label>
              <input id="maxPeakRelaxOffsetF" type="number" min="0" max="10" step="0.5" value="2" />
            </div>
            <div class="field">
              <label for="hvacSensitivityKwhPerDegHour">HVAC sensitivity (kWh / deg-hour)</label>
              <input id="hvacSensitivityKwhPerDegHour" type="number" min="0.01" step="0.01" value="0.60" />
            </div>
            <div id="haManualFields">
              <div class="field">
                <label for="hvacShiftSuccessRatePct">Shift success rate (%)</label>
                <input id="hvacShiftSuccessRatePct" type="number" min="0" max="100" step="1" value="70" />
              </div>
              <div class="field">
                <label for="preCoolStartHour">Pre-window start hour (0-23)</label>
                <input id="preCoolStartHour" type="number" min="0" max="23" step="1" value="12" />
              </div>
              <div class="field">
                <label for="preCoolEndHour">Pre-window end hour (0-23)</label>
                <input id="preCoolEndHour" type="number" min="0" max="23" step="1" value="16" />
              </div>
            </div>
            <div class="field">
              <label for="maxShiftHoursPerDay">Max shift hours/day</label>
              <input id="maxShiftHoursPerDay" type="number" min="1" max="12" step="1" value="4" />
            </div>
            <div class="field">
              <label for="maxShiftKwhPerDay">Max shift kWh/day</label>
              <input id="maxShiftKwhPerDay" type="number" min="0" step="0.1" value="6" />
            </div>
          </div>
          <div class="hint" id="haLoadShiftNote">HVAC shift: OFF.</div>
          <div class="hint">Season map is fixed: Summer May-Sep, Winter Nov-Feb, Shoulder Mar-Apr-Oct. Peak drift lets temp move away from setpoint during 4-9pm before recovery.</div>
        </div>

        <div class="group">
          <h3>Load Shaping: EV Charging</h3>
          <div class="field">
            <label class="checkline"><input id="hasEvCharging" type="checkbox" /> Include EV charging load</label>
          </div>
          <div id="evFields">
            <div class="field">
              <label for="evMilesPerMonth">Miles driven per month</label>
              <input id="evMilesPerMonth" type="number" min="0" step="10" value="800" />
            </div>
            <div class="field">
              <label for="evKwhPerMile">EV efficiency (kWh/mile)</label>
              <input id="evKwhPerMile" type="number" min="0.01" step="0.01" value="0.30" />
            </div>
            <div class="field">
              <label for="evDayChargingPct">Daytime charging share (%)</label>
              <input id="evDayChargingPct" type="number" min="0" max="100" step="1" value="60" />
            </div>
          </div>
          <div class="hint" id="evLoadNote">EV load: OFF.</div>
          <div class="hint">Charging windows: Day 09:00-16:00, Night 21:00-06:00. Day charging is solar-only; unmet day charging shifts to night.</div>
        </div>

        <details class="collapsible">
          <summary>Tariff &amp; Programs</summary>
          <div class="group">
            <h3>Tariff &amp; Programs</h3>
            <div class="field">
              <label for="tariffPreset">Tariff preset</label>
              <select id="tariffPreset">
                <option value="custom" selected>Custom</option>
                <option value="pge_e_elec">PG&amp;E E-ELEC (reference)</option>
              </select>
            </div>
            <div class="field">
              <label for="importOffPeak">Import off-peak ($/kWh)</label>
              <input id="importOffPeak" type="number" min="0" step="0.01" value="0.36" />
            </div>
            <div class="field">
              <label for="importPeak">Import peak ($/kWh)</label>
              <input id="importPeak" type="number" min="0" step="0.01" value="0.58" />
            </div>
            <div class="field">
              <label for="fixedMonthlyCharge">Fixed monthly charge ($)</label>
              <input id="fixedMonthlyCharge" type="number" min="0" step="0.01" value="24.15" />
            </div>
            <div class="field">
              <label for="nbcPerImportKwh">NBC on imports ($/kWh)</label>
              <input id="nbcPerImportKwh" type="number" min="0" step="0.001" value="0.03" />
            </div>
            <div class="field">
              <label for="exportRateMode">Export rate mode</label>
              <select id="exportRateMode">
                <option value="nem3_override" selected>NEM 3.0 override</option>
                <option value="tou_export">TOU export rates</option>
              </select>
            </div>
            <div class="field">
              <label for="nem3ExportRate">NEM 3.0 export rate ($/kWh)</label>
              <input id="nem3ExportRate" type="number" min="0" step="0.01" value="0.04" />
            </div>
            <div class="field">
              <label for="exportOffPeak">Export off-peak ($/kWh)</label>
              <input id="exportOffPeak" type="number" min="0" step="0.01" value="0.05" />
            </div>
            <div class="field">
              <label for="exportPeak">Export peak ($/kWh)</label>
              <input id="exportPeak" type="number" min="0" step="0.01" value="0.12" />
            </div>
            <div class="field">
              <label class="checkline"><input id="vppEnabled" type="checkbox" checked /> Include VPP revenue (DSGS/ELRP proxy)</label>
            </div>
            <div class="hint" id="exportModeNote">Export note: --</div>
            <div class="hint">Annual true-up logic: export value offsets annual energy import charges only. Fixed charge and NBC remain non-offsettable.</div>
            <div class="hint">VPP credit model: Powerwalls * 11.5 kW * $35/kW-year. This can make annual utility results negative (net profit).</div>
          </div>
        </details>

        <details class="collapsible">
          <summary>Physical Constraints: System Pricing</summary>
          <div class="group">
            <h3>Physical Constraints: System Pricing</h3>
            <div class="field">
              <label for="solarBaseCost">Solar base cost ($)</label>
              <input id="solarBaseCost" type="number" min="0" step="50" value="2710" />
            </div>
            <div class="field">
              <label for="solarCostPerKw">Solar cost per kW ($)</label>
              <input id="solarCostPerKw" type="number" min="0" step="25" value="2785" />
            </div>
            <div class="field">
              <label for="batteryCost1">1 Powerwall cost ($)</label>
              <input id="batteryCost1" type="number" min="0" step="50" value="16875" />
            </div>
            <div class="field">
              <label for="batteryCost2">2 Powerwalls cost ($)</label>
              <input id="batteryCost2" type="number" min="0" step="50" value="31250" />
            </div>
            <div class="field">
              <label for="batteryCost3">3 Powerwalls cost ($)</label>
              <input id="batteryCost3" type="number" min="0" step="50" value="45625" />
            </div>
            <div class="field">
              <label for="batteryCost4">4 Powerwalls cost ($)</label>
              <input id="batteryCost4" type="number" min="0" step="50" value="60000" />
            </div>
          </div>
        </details>

        <details class="collapsible">
          <summary>Physical Constraints: Battery + Inverter</summary>
          <div class="group">
            <h3>Physical Constraints: Battery + Inverter</h3>
            <div class="field">
              <label for="dispatchMode">Battery dispatch mode</label>
              <select id="dispatchMode">
                <option value="self_consumption_peak_then_postpeak" selected>Self-Consumption (peak then post-peak)</option>
                <option value="arbitrage_price_event">VPP Arbitrage (export when export &gt; import)</option>
              </select>
            </div>
            <div class="field">
              <label for="reservePolicy">Reserve policy</label>
              <select id="reservePolicy">
                <option value="auto_seasonal" selected>Auto Seasonal (50/30/20)</option>
                <option value="fixed">Fixed reserve</option>
                <option value="custom_monthly">Custom monthly table</option>
              </select>
            </div>
            <div class="field" id="fixedReserveField">
              <label for="minSocReservePct">Fixed minimum SOC reserve (%)</label>
              <input id="minSocReservePct" type="number" min="0" max="95" step="1" value="20" />
            </div>
            <div class="field hidden" id="reserveMonthlyFields">
              <label>Monthly reserve table (%)</label>
              <div class="month-grid monthly-reserve">
                <label class="checkline">Jan<input id="monthlyReservePct0" type="number" min="0" max="95" step="1" value="50" /></label>
                <label class="checkline">Feb<input id="monthlyReservePct1" type="number" min="0" max="95" step="1" value="50" /></label>
                <label class="checkline">Mar<input id="monthlyReservePct2" type="number" min="0" max="95" step="1" value="30" /></label>
                <label class="checkline">Apr<input id="monthlyReservePct3" type="number" min="0" max="95" step="1" value="30" /></label>
                <label class="checkline">May<input id="monthlyReservePct4" type="number" min="0" max="95" step="1" value="20" /></label>
                <label class="checkline">Jun<input id="monthlyReservePct5" type="number" min="0" max="95" step="1" value="20" /></label>
                <label class="checkline">Jul<input id="monthlyReservePct6" type="number" min="0" max="95" step="1" value="20" /></label>
                <label class="checkline">Aug<input id="monthlyReservePct7" type="number" min="0" max="95" step="1" value="20" /></label>
                <label class="checkline">Sep<input id="monthlyReservePct8" type="number" min="0" max="95" step="1" value="20" /></label>
                <label class="checkline">Oct<input id="monthlyReservePct9" type="number" min="0" max="95" step="1" value="30" /></label>
                <label class="checkline">Nov<input id="monthlyReservePct10" type="number" min="0" max="95" step="1" value="50" /></label>
                <label class="checkline">Dec<input id="monthlyReservePct11" type="number" min="0" max="95" step="1" value="50" /></label>
              </div>
            </div>
            <div class="field">
              <label for="cyclesPerDay">Cycles/day</label>
              <input id="cyclesPerDay" type="number" min="0" max="2" step="0.01" value="0.85" />
            </div>
            <div class="field">
              <label for="solarToHomeEfficiencyPct">Solar-to-home efficiency (%)</label>
              <input id="solarToHomeEfficiencyPct" type="number" min="80" max="100" step="0.1" value="97.5" />
            </div>
            <div class="field">
              <label for="roundTripEfficiency">Round-trip efficiency (%)</label>
              <input id="roundTripEfficiency" type="number" min="50" max="100" step="1" value="90" />
            </div>
            <div class="hint">Powerwall 3 clipping: solar AC output is capped at 11.5 kW per Powerwall when Powerwalls &gt;= 1. For 0 Powerwalls, clipping cap is disabled.</div>
            <div class="hint">Self-consumption mode discharges to reduce load in peak/post-peak. Arbitrage mode can export battery energy when export price exceeds import price.</div>
          </div>
        </details>

        <details class="collapsible">
          <summary>Financing</summary>
          <div class="group">
            <h3>Financing</h3>
            <div class="field">
              <label for="apr">APR (%)</label>
              <input id="apr" type="number" min="0" step="0.01" value="6" />
            </div>
            <div class="field">
              <label for="financeYears">Loan term (years)</label>
              <input id="financeYears" type="number" min="1" step="1" value="15" />
            </div>
          </div>
        </details>


        <div class="actions">
          <button id="recalculateBtn" type="button">Recalculate Ideal System</button>
          <div class="hint mono" id="candidateNote">Candidate set: --</div>
        </div>
      </aside>

      <section class="panel results">
        <h2>Results</h2>

        <div class="error-box" id="errorBox"></div>
        <div class="climate-banner" id="climateFallbackBanner">
          <div class="climate-banner-title">Climate data fallback active</div>
          <div class="climate-banner-body" id="climateFallbackMessage">Synthetic fallback in use.</div>
          <div class="climate-banner-actions">
            <button id="fallbackProceedBtn" type="button">Use Synthetic Fallback For Now</button>
            <button id="climateRetryBtn" class="secondary-btn" type="button">Retry NREL Fetch</button>
          </div>
        </div>

        <div class="cards">
          <div class="cards-group" style="grid-column: 1 / -1;">
            <div class="cards-header">System</div>
            <div class="cards">
              <div class="card">
                <div class="k">Ideal Solar Size (kW)</div>
                <div class="v" id="cardIdealSolarKw">--</div>
                <div class="sub" id="cardPowerwallChoice">Powerwalls: --</div>
              </div>
              <div class="card">
                <div class="k">Financed Principal</div>
                <div class="v" id="cardFinanced">$0</div>
                <div class="sub" id="cardFinancedNote">Based on gross system cost.</div>
              </div>
              <div class="card">
                <div class="k">Mortgage / Month</div>
                <div class="v" id="cardMortgage">$0</div>
                <div class="sub" id="cardOutflow">Total outflow (Mortgage + PG&amp;E After): --</div>
              </div>
            </div>
          </div>

          <div class="cards-group" style="grid-column: 1 / -1;">
            <div class="cards-header">Utility Comparison</div>
            <div class="cards">
              <div class="card">
                <div class="k">PG&amp;E Baseline / Month (No WHF/HA)</div>
                <div class="v" id="cardPgeBefore">$0</div>
              </div>
              <div class="card">
                <div class="k">PG&amp;E After / Month (True-Up)</div>
                <div class="v" id="cardPgeAfter">$0</div>
                <div class="sub" id="cardTrueUpNote">Annual true-up bill: --</div>
              </div>
              <div class="card">
                <div class="k">Clipping Impact</div>
                <div class="v" id="cardClippedSolar">--</div>
                <div class="sub" id="cardClippedSolarNote">Annual clipped solar: --</div>
              </div>
              <div class="card">
                <div class="k">Utility Bill Change / Month</div>
                <div class="v" id="cardSavings">$0</div>
                <div class="sub" id="cardUtilityChangeFormula">(PG&amp;E After) - (PG&amp;E Baseline No WHF/HA)</div>
                <div class="sub mono" id="cardSolarOnlyDelta">Solar-only delta (same-load baseline): --</div>
              </div>
            </div>
          </div>

          <div class="cards-group" style="grid-column: 1 / -1;">
            <div class="cards-header">Net Payment Impact</div>
            <div class="cards">
              <div class="card" style="grid-column: span 3;">
                <div class="k">Net Change In Payment / Month</div>
                <div class="v" id="cardNetPaymentChange">$0</div>
                <div class="sub" id="cardNetPaymentFormula">(Primary Utility Bill Change / Month) + (Mortgage / Month)</div>
              </div>
            </div>
          </div>

          <div class="cards-group" style="grid-column: 1 / -1;">
            <div class="cards-header">HVAC Impact Analysis</div>
            <div class="cards">
              <div class="card" style="grid-column: span 3;">
                <div class="k">Dual View (Fixed-size + Re-optimized)</div>
                <div class="sub" id="hvacImpactOutput">HVAC impact analysis runs after a valid calculation.</div>
              </div>
            </div>
          </div>
        </div>

        <details class="collapsible" open>
          <summary>Assumptions</summary>
          <div class="section">
            <h3>Assumptions</h3>
            <div class="inline-pills">
              <div class="pill">Hourly dispatch retained</div>
              <div class="pill">Battery dispatch/reserve are fully modeled by hour</div>
              <div class="pill">Climate profile: NREL preferred, synthetic fallback guarded</div>
              <div class="pill" id="climateAssumptionPill">Climate source: --</div>
              <div class="pill" id="tempAssumptionPill">Temperature source: --</div>
              <div class="pill" id="tariffAssumptionPill">Tariff floor: --</div>
              <div class="pill" id="vppAssumptionPill">VPP: --</div>
              <div class="pill" id="dispatchAssumptionPill">Dispatch mode: --</div>
              <div class="pill" id="reserveAssumptionPill">Reserve policy: --</div>
              <div class="pill" id="clipAssumptionPill">Clipping: --</div>
              <div class="pill" id="yieldAssumptionPill">Yield profile: --</div>
              <div class="pill" id="evAssumptionPill">EV: --</div>
              <div class="pill" id="haAssumptionPill">HA HVAC shift: --</div>
              <div class="pill" id="whfAssumptionPill">WHF: --</div>
            </div>
            <p class="summary" id="objectiveSummary">
              Ideal size is selected by minimizing <strong>Mortgage/Month + PG&amp;E After/Month</strong>. Tie-breakers: lower financed principal, then lower kW.
            </p>
          </div>
        </details>

        <details class="collapsible" open>
          <summary>Scenario Matrix (Solar kW x Powerwalls)</summary>
          <div class="section">
            <h3>Scenario Matrix (Solar kW x Powerwalls)</h3>
            <div class="table-wrap">
              <table class="results-table" id="scenarioMatrixTable"></table>
            </div>
            <p class="summary" id="scenarioMatrixNote">Matrix will render after a valid calculation. Click a cell to select a scenario.</p>
          </div>
        </details>

        <details class="collapsible" open>
          <summary>Model Checks</summary>
          <div class="section">
            <h3>Model Checks</h3>
            <div class="checks" id="checksOutput">Checks will run after a valid calculation.</div>
          </div>
        </details>


        <div class="section">
          <h3>Top Scenarios</h3>
          <div class="table-wrap" style="max-height: 260px;">
            <table class="results-table">
              <thead>
                <tr>
                  <th>Rank</th>
                  <th>Solar kW</th>
                  <th>PW</th>
                  <th>NPV</th>
                  <th>Payback</th>
                  <th>PG&amp;E After/mo</th>
                  <th>Total Outflow/mo</th>
                  <th>Import kWh/yr</th>
                  <th>Export kWh/yr</th>
                </tr>
              </thead>
              <tbody id="topScenariosBody"></tbody>
            </table>
          </div>
        </div>

        <p class="summary hidden" id="regressionOutput">
          Regression probe disabled.
        </p>

        <details class="calc-details" id="calcDetails">
          <summary>Calculation Breakdown (Expandable)</summary>
          <div class="calc-body" id="calcBreakdown">
            Enter valid inputs to see step-by-step calculations.
          </div>
        </details>
      </section>
    </div>
  </div>

  <script>
    "use strict";

    const BATTERY_USABLE_KWH = 13.5 * 0.9;
    const DAYS_PER_YEAR = 365;
    const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    const MONTH_LABELS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const MONTHLY_DAYLIGHT_HOURS = [9.8, 10.7, 11.9, 13.1, 14.1, 14.6, 14.4, 13.5, 12.3, 11.1, 10.0, 9.5];
    const SYNTHETIC_TEMP_MONTHLY_AVG_F = [47, 50, 55, 60, 67, 75, 81, 80, 75, 66, 55, 48];
    const DEFAULT_MONTHLY_RESERVE_PCT = [50, 50, 30, 30, 20, 20, 20, 20, 20, 30, 50, 50];
    const PEAK_HOURS = new Set([16, 17, 18, 19, 20]);
    const DAY_CHARGING_HOURS = [9, 10, 11, 12, 13, 14, 15];
    const NIGHT_CHARGING_HOURS = [21, 22, 23, 0, 1, 2, 3, 4, 5];
    const POST_PEAK_HOURS = [21, 22, 23];
    const DAY_CHARGING_HOUR_SET = new Set(DAY_CHARGING_HOURS);
    const NIGHT_CHARGING_HOUR_SET = new Set(NIGHT_CHARGING_HOURS);
    const POST_PEAK_HOUR_SET = new Set(POST_PEAK_HOURS);
    const SUMMER_MONTHS = new Set([4, 5, 6, 7, 8]);
    const WINTER_MONTHS = new Set([10, 11, 0, 1]);
    const PEAK_WINDOW_HOURS = [16, 17, 18, 19, 20];
    const PEAK_WINDOW_HOUR_SET = new Set(PEAK_WINDOW_HOURS);
    const BASE_SUMMER_SETPOINT_F = 74;
    const BASE_WINTER_SETPOINT_F = 68;
    const SUMMER_SETPOINT_LOAD_SENSITIVITY_PER_DEG = 0.03;
    const WINTER_SETPOINT_LOAD_SENSITIVITY_PER_DEG = 0.025;
    const MODULE_KW = 0.395;
    const V1_LIKE_OPPORTUNITY_RATE = 0.05;
    const ZIP_DEFAULT_YIELD = 1700;
    const POWERWALL3_AC_KW = 11.5;
    const VPP_CREDIT_PER_KW_YEAR = 35;
    const RESCUE_ZIP = "95672";
    const RESCUE_HVAC_SENSITIVITY = 0.45;
    const DEFAULT_HVAC_SENSITIVITY = 0.60;
    const NREL_DEMO_KEY = "DEMO_KEY";
    const NREL_PVWATTS_URL = "https://developer.nrel.gov/api/pvwatts/v8.json";
    const NREL_CACHE_STORAGE_KEY = "solarAnalyzer.nrelCache.v1";
    const NREL_META_STORAGE_KEY = "solarAnalyzer.climateMeta.v1";
    const ZIP_COORD_CACHE_STORAGE_KEY = "solarAnalyzer.zipCoordCache.v1";
    const NREL_CACHE_TTL_MS = 30 * 24 * 60 * 60 * 1000;
    const ZIP_COORD_CACHE_TTL_MS = 180 * 24 * 60 * 60 * 1000;
    const NREL_RATE_LIMIT_COOLDOWN_MS = 15 * 60 * 1000;
    const NREL_GENERIC_RETRY_BACKOFF_MS = 60 * 1000;
    const SYNTHETIC_ACK_SESSION_KEY = "solarAnalyzer.syntheticFallbackAck.v1";

    const DEFAULT_LOAD_PROFILE_RAW = [1.02, 0.95, 0.91, 0.82, 0.79, 0.83, 0.96, 1.07, 0.96, 0.89, 0.91, 0.99];
    const DEFAULT_SOLAR_PROFILE_RAW = [0.58, 0.66, 0.86, 1.02, 1.12, 1.18, 1.16, 1.08, 0.98, 0.83, 0.64, 0.53];
    const BASE_LOAD_HOURLY_RAW = [
      0.021, 0.019, 0.018, 0.018, 0.018, 0.021,
      0.028, 0.037, 0.043, 0.045, 0.043, 0.041,
      0.040, 0.039, 0.040, 0.044, 0.054, 0.066,
      0.074, 0.078, 0.070, 0.056, 0.042, 0.031
    ];

    const ZIP_YIELD_HINTS = [
      { start: 90000, end: 93599, annualYield: 1850, label: "SoCal inland profile" },
      { start: 93600, end: 96199, annualYield: 1700, label: "NorCal inland profile" },
      { start: 97000, end: 98699, annualYield: 1300, label: "Pacific Northwest profile" },
      { start: 80000, end: 81699, annualYield: 1650, label: "Mountain West profile" },
      { start: 85000, end: 86599, annualYield: 1950, label: "Desert Southwest profile" }
    ];

    const LOAD_PROFILE = normalizeProfile(DEFAULT_LOAD_PROFILE_RAW);
    const SOLAR_PROFILE = normalizeProfile(DEFAULT_SOLAR_PROFILE_RAW);
    const BASE_LOAD_HOURLY = normalizeProfile(BASE_LOAD_HOURLY_RAW);

    const el = {
      powerwallCount: document.getElementById("powerwallCount"),
      lockPowerwallCount: document.getElementById("lockPowerwallCount"),
      solarSearchMinKw: document.getElementById("solarSearchMinKw"),
      solarSearchMaxKw: document.getElementById("solarSearchMaxKw"),
      solarSearchStepKw: document.getElementById("solarSearchStepKw"),
      sizingObjective: document.getElementById("sizingObjective"),
      sizingObjectiveHint: document.getElementById("sizingObjectiveHint"),
      sweepModeHint: document.getElementById("sweepModeHint"),
      enableWhf: document.getElementById("enableWhf"),
      whfMode: document.getElementById("whfMode"),
      whfFields: document.getElementById("whfFields"),
      whfManualFields: document.getElementById("whfManualFields"),
      whfFanWatts: document.getElementById("whfFanWatts"),
      whfDisplacedAcWatts: document.getElementById("whfDisplacedAcWatts"),
      whfStartHour: document.getElementById("whfStartHour"),
      whfStartMinute: document.getElementById("whfStartMinute"),
      whfEndHour: document.getElementById("whfEndHour"),
      whfEndMinute: document.getElementById("whfEndMinute"),
      whfMonthNodes: Array.from(document.querySelectorAll("input[data-whf-month]")),
      whfSuccessRatePct: document.getElementById("whfSuccessRatePct"),
      whfNote: document.getElementById("whfNote"),
      annualLoadKwh: document.getElementById("annualLoadKwh"),
      hasEvCharging: document.getElementById("hasEvCharging"),
      evFields: document.getElementById("evFields"),
      evMilesPerMonth: document.getElementById("evMilesPerMonth"),
      evKwhPerMile: document.getElementById("evKwhPerMile"),
      evDayChargingPct: document.getElementById("evDayChargingPct"),
      evLoadNote: document.getElementById("evLoadNote"),
      enableHaShift: document.getElementById("enableHaShift"),
      haMode: document.getElementById("haMode"),
      haFields: document.getElementById("haFields"),
      haManualFields: document.getElementById("haManualFields"),
      tempUnitsDisplay: document.getElementById("tempUnitsDisplay"),
      summerSetpointF: document.getElementById("summerSetpointF"),
      winterSetpointF: document.getElementById("winterSetpointF"),
      maxPrecoolOffsetF: document.getElementById("maxPrecoolOffsetF"),
      maxPreheatOffsetF: document.getElementById("maxPreheatOffsetF"),
      maxPeakRelaxOffsetF: document.getElementById("maxPeakRelaxOffsetF"),
      hvacSensitivityKwhPerDegHour: document.getElementById("hvacSensitivityKwhPerDegHour"),
      hvacShiftSuccessRatePct: document.getElementById("hvacShiftSuccessRatePct"),
      preCoolStartHour: document.getElementById("preCoolStartHour"),
      preCoolEndHour: document.getElementById("preCoolEndHour"),
      maxShiftHoursPerDay: document.getElementById("maxShiftHoursPerDay"),
      maxShiftKwhPerDay: document.getElementById("maxShiftKwhPerDay"),
      haLoadShiftNote: document.getElementById("haLoadShiftNote"),
      zipCode: document.getElementById("zipCode"),
      nrelApiKey: document.getElementById("nrelApiKey"),
      zipYieldNote: document.getElementById("zipYieldNote"),
      climateDataBadge: document.getElementById("climateDataBadge"),
      tariffPreset: document.getElementById("tariffPreset"),
      exportRateMode: document.getElementById("exportRateMode"),
      importOffPeak: document.getElementById("importOffPeak"),
      importPeak: document.getElementById("importPeak"),
      fixedMonthlyCharge: document.getElementById("fixedMonthlyCharge"),
      nbcPerImportKwh: document.getElementById("nbcPerImportKwh"),
      nem3ExportRate: document.getElementById("nem3ExportRate"),
      exportOffPeak: document.getElementById("exportOffPeak"),
      exportPeak: document.getElementById("exportPeak"),
      vppEnabled: document.getElementById("vppEnabled"),
      exportModeNote: document.getElementById("exportModeNote"),
      solarBaseCost: document.getElementById("solarBaseCost"),
      solarCostPerKw: document.getElementById("solarCostPerKw"),
      batteryCost1: document.getElementById("batteryCost1"),
      batteryCost2: document.getElementById("batteryCost2"),
      batteryCost3: document.getElementById("batteryCost3"),
      batteryCost4: document.getElementById("batteryCost4"),
      dispatchMode: document.getElementById("dispatchMode"),
      reservePolicy: document.getElementById("reservePolicy"),
      fixedReserveField: document.getElementById("fixedReserveField"),
      minSocReservePct: document.getElementById("minSocReservePct"),
      reserveMonthlyFields: document.getElementById("reserveMonthlyFields"),
      monthlyReservePctNodes: new Array(12).fill(0).map((_, month) => document.getElementById("monthlyReservePct" + month)),
      cyclesPerDay: document.getElementById("cyclesPerDay"),
      solarToHomeEfficiencyPct: document.getElementById("solarToHomeEfficiencyPct"),
      roundTripEfficiency: document.getElementById("roundTripEfficiency"),
      apr: document.getElementById("apr"),
      financeYears: document.getElementById("financeYears"),
      recalculateBtn: document.getElementById("recalculateBtn"),
      candidateNote: document.getElementById("candidateNote"),
      errorBox: document.getElementById("errorBox"),
      cardIdealSolarKw: document.getElementById("cardIdealSolarKw"),
      cardPowerwallChoice: document.getElementById("cardPowerwallChoice"),
      cardPgeBefore: document.getElementById("cardPgeBefore"),
      cardPgeAfter: document.getElementById("cardPgeAfter"),
      cardTrueUpNote: document.getElementById("cardTrueUpNote"),
      cardClippedSolar: document.getElementById("cardClippedSolar"),
      cardClippedSolarNote: document.getElementById("cardClippedSolarNote"),
      cardSavings: document.getElementById("cardSavings"),
      cardUtilityChangeFormula: document.getElementById("cardUtilityChangeFormula"),
      cardSolarOnlyDelta: document.getElementById("cardSolarOnlyDelta"),
      cardNetPaymentChange: document.getElementById("cardNetPaymentChange"),
      cardNetPaymentFormula: document.getElementById("cardNetPaymentFormula"),
      cardFinanced: document.getElementById("cardFinanced"),
      cardFinancedNote: document.getElementById("cardFinancedNote"),
      cardMortgage: document.getElementById("cardMortgage"),
      cardOutflow: document.getElementById("cardOutflow"),
      yieldAssumptionPill: document.getElementById("yieldAssumptionPill"),
      climateAssumptionPill: document.getElementById("climateAssumptionPill"),
      tempAssumptionPill: document.getElementById("tempAssumptionPill"),
      tariffAssumptionPill: document.getElementById("tariffAssumptionPill"),
      vppAssumptionPill: document.getElementById("vppAssumptionPill"),
      dispatchAssumptionPill: document.getElementById("dispatchAssumptionPill"),
      reserveAssumptionPill: document.getElementById("reserveAssumptionPill"),
      clipAssumptionPill: document.getElementById("clipAssumptionPill"),
      evAssumptionPill: document.getElementById("evAssumptionPill"),
      haAssumptionPill: document.getElementById("haAssumptionPill"),
      whfAssumptionPill: document.getElementById("whfAssumptionPill"),
      scenarioMatrixTable: document.getElementById("scenarioMatrixTable"),
      scenarioMatrixNote: document.getElementById("scenarioMatrixNote"),
      topScenariosBody: document.getElementById("topScenariosBody"),
      checksOutput: document.getElementById("checksOutput"),
      regressionOutput: document.getElementById("regressionOutput"),
      objectiveSummary: document.getElementById("objectiveSummary"),
      hvacImpactOutput: document.getElementById("hvacImpactOutput"),
      climateFallbackBanner: document.getElementById("climateFallbackBanner"),
      climateFallbackMessage: document.getElementById("climateFallbackMessage"),
      fallbackProceedBtn: document.getElementById("fallbackProceedBtn"),
      climateRetryBtn: document.getElementById("climateRetryBtn"),
      calcDetails: document.getElementById("calcDetails"),
      calcBreakdown: document.getElementById("calcBreakdown")
    };
    let selectedScenarioKey = null;
    let hvacSensitivityTouched = false;
    let climateFetchToken = 0;
    const optimizationCache = new Map();
    const OPTIMIZATION_CACHE_LIMIT = 12;
    const NREL_PROFILE_PARAMS = {
      system_capacity: 1,
      module_type: 1,
      array_type: 1,
      tilt: 20,
      azimuth: 180,
      losses: 14,
      timeframe: "hourly"
    };
    let climateState = loadInitialClimateState();

    function loadJsonStorage(storage, key, fallbackValue) {
      try {
        const raw = storage.getItem(key);
        if (!raw) return fallbackValue;
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === "object" ? parsed : fallbackValue;
      } catch (_err) {
        return fallbackValue;
      }
    }

    function saveJsonStorage(storage, key, value) {
      try {
        storage.setItem(key, JSON.stringify(value));
      } catch (_err) {
        // Ignore storage write failures and continue with in-memory state.
      }
    }

    function loadInitialClimateState() {
      const fallback = {
        status: "fallback_synthetic",
        locationLabel: "ZIP pending",
        lastVerifiedAt: null,
        fallbackReason: "missing_data",
        keyMode: "demo_key",
        requestSignature: "",
        profile: null,
        pending: false,
        nextRetryAt: 0,
        lastFetchAttemptAt: 0,
        blockedByFallbackAck: false
      };
      const stored = loadJsonStorage(localStorage, NREL_META_STORAGE_KEY, null);
      if (!stored) return fallback;
      return {
        ...fallback,
        status: typeof stored.status === "string" ? stored.status : fallback.status,
        locationLabel: typeof stored.locationLabel === "string" ? stored.locationLabel : fallback.locationLabel,
        lastVerifiedAt: typeof stored.lastVerifiedAt === "string" ? stored.lastVerifiedAt : null,
        fallbackReason: typeof stored.fallbackReason === "string" ? stored.fallbackReason : fallback.fallbackReason,
        keyMode: stored.keyMode === "user_key" ? "user_key" : "demo_key",
        requestSignature: typeof stored.requestSignature === "string" ? stored.requestSignature : "",
        nextRetryAt: Number.isFinite(stored.nextRetryAt) ? stored.nextRetryAt : 0,
        lastFetchAttemptAt: Number.isFinite(stored.lastFetchAttemptAt) ? stored.lastFetchAttemptAt : 0
      };
    }

    function persistClimateState() {
      saveJsonStorage(localStorage, NREL_META_STORAGE_KEY, {
        status: climateState.status,
        locationLabel: climateState.locationLabel,
        lastVerifiedAt: climateState.lastVerifiedAt,
        fallbackReason: climateState.fallbackReason,
        keyMode: climateState.keyMode,
        requestSignature: climateState.requestSignature,
        nextRetryAt: Number.isFinite(climateState.nextRetryAt) ? climateState.nextRetryAt : 0,
        lastFetchAttemptAt: Number.isFinite(climateState.lastFetchAttemptAt) ? climateState.lastFetchAttemptAt : 0
      });
    }

    function normalizeProfile(values) {
      const total = values.reduce((acc, v) => acc + v, 0);
      if (!Number.isFinite(total) || total <= 0) {
        return new Array(values.length).fill(1 / values.length);
      }
      return values.map((v) => v / total);
    }

    function clamp(n, low, high) {
      return Math.min(high, Math.max(low, n));
    }

    function decimalPlaces(value) {
      const asText = String(value);
      if (!asText.includes(".")) return 0;
      return asText.length - asText.indexOf(".") - 1;
    }

    function usd(value) {
      return new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 0 }).format(value);
    }

    function usdPrecise(value) {
      return new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2 }).format(value);
    }

    function fmt(value, digits = 2) {
      return Number(value).toFixed(digits);
    }

    function usdSigned(value) {
      const abs = Math.abs(value);
      const formatted = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2 }).format(abs);
      if (Math.abs(value) < 0.005) return "$0.00";
      return (value > 0 ? "+" : "-") + formatted;
    }

    function formatPaybackYears(value, years = 15) {
      return Number.isFinite(value) ? (fmt(value, 1) + "y") : ("No payback in " + years + "y");
    }

    function scenarioKey(solarKw, powerwallCount) {
      return Number(solarKw).toFixed(6) + "|" + powerwallCount;
    }

    function inputCacheKey(inputs) {
      return JSON.stringify(inputs);
    }

    function getOptimizationCached(inputs) {
      const key = inputCacheKey(inputs);
      if (optimizationCache.has(key)) {
        return optimizationCache.get(key);
      }
      const value = optimizeIdealScenario(inputs);
      optimizationCache.set(key, value);
      if (optimizationCache.size > OPTIMIZATION_CACHE_LIMIT) {
        const oldestKey = optimizationCache.keys().next().value;
        optimizationCache.delete(oldestKey);
      }
      return value;
    }

    function objectiveLabel(mode) {
      if (mode === "return_npv") return "highest NPV (payback and outflow tie-breakers)";
      if (mode === "utility_bill_knee") return "utility bill Pareto knee-point";
      return "minimum total outflow";
    }

    function objectiveFormula(mode) {
      if (mode === "return_npv") return "maximize NPV (discounted annual utility savings - system cost)";
      if (mode === "utility_bill_knee") return "select Pareto knee on (System Cost, PG&E After / Month)";
      return "Mortgage / Month + PG&E After / Month (True-Up)";
    }

    function renderDelta(node, value) {
      node.textContent = usdSigned(value);
      node.classList.toggle("good", value < 0);
      node.classList.toggle("bad", value > 0);
    }

    function parseZip(zipRaw) {
      const trimmed = String(zipRaw || "").trim();
      return /^\d{5}$/.test(trimmed) ? Number(trimmed) : null;
    }

    function shortHash(text) {
      const asText = String(text || "");
      let hash = 2166136261;
      for (let i = 0; i < asText.length; i += 1) {
        hash ^= asText.charCodeAt(i);
        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
      }
      return (hash >>> 0).toString(16).padStart(8, "0");
    }

    function buildClimateContext(zipRaw = el.zipCode.value, apiKeyRaw = el.nrelApiKey.value) {
      const parsedZip = parseZip(zipRaw);
      if (parsedZip === null) return { ok: false };
      const zip = String(parsedZip).padStart(5, "0");
      const userKey = String(apiKeyRaw || "").trim();
      const apiKey = userKey || NREL_DEMO_KEY;
      const keyMode = userKey ? "user_key" : "demo_key";
      const apiKeyHash = shortHash(apiKey);
      const signature = zip + "|" + apiKeyHash;
      const cacheKey = [
        zip,
        "sc" + NREL_PROFILE_PARAMS.system_capacity,
        "mt" + NREL_PROFILE_PARAMS.module_type,
        "at" + NREL_PROFILE_PARAMS.array_type,
        "tilt" + NREL_PROFILE_PARAMS.tilt,
        "az" + NREL_PROFILE_PARAMS.azimuth,
        "loss" + NREL_PROFILE_PARAMS.losses,
        NREL_PROFILE_PARAMS.timeframe,
        apiKeyHash
      ].join("|");
      return {
        ok: true,
        zip,
        apiKey,
        keyMode,
        signature,
        cacheKey
      };
    }

    function isValidMonthlyProfile(monthlyProfile) {
      return Array.isArray(monthlyProfile)
        && monthlyProfile.length === 12
        && monthlyProfile.every((v) => Number.isFinite(v) && v >= 0);
    }

    function isValidHourlyByMonth(hourlyByMonth) {
      return Array.isArray(hourlyByMonth)
        && hourlyByMonth.length === 12
        && hourlyByMonth.every((row) => Array.isArray(row)
          && row.length === 24
          && row.every((v) => Number.isFinite(v) && v >= 0));
    }

    function isValidTempHourlyByMonth(hourlyByMonth) {
      return Array.isArray(hourlyByMonth)
        && hourlyByMonth.length === 12
        && hourlyByMonth.every((row) => Array.isArray(row)
          && row.length === 24
          && row.every((v) => Number.isFinite(v)));
    }

    function isValidClimateProfile(profile) {
      return !!profile
        && isValidMonthlyProfile(profile.monthlyProfile)
        && isValidHourlyByMonth(profile.hourlyByMonth)
        && isValidTempHourlyByMonth(profile.tempHourlyFByMonth)
        && (profile.tempSource === "nrel_tamb" || profile.tempSource === "synthetic_temp_fallback");
    }

    function readClimateCacheStore() {
      return loadJsonStorage(localStorage, NREL_CACHE_STORAGE_KEY, {});
    }

    function writeClimateCacheStore(store) {
      saveJsonStorage(localStorage, NREL_CACHE_STORAGE_KEY, store);
    }

    function readZipCoordCacheStore() {
      return loadJsonStorage(localStorage, ZIP_COORD_CACHE_STORAGE_KEY, {});
    }

    function writeZipCoordCacheStore(store) {
      saveJsonStorage(localStorage, ZIP_COORD_CACHE_STORAGE_KEY, store);
    }

    function getCachedZipCoordEntry(zip) {
      const store = readZipCoordCacheStore();
      const now = Date.now();
      let changed = false;
      Object.keys(store).forEach((key) => {
        const entry = store[key];
        if (!entry || !Number.isFinite(entry.cachedAt) || (now - entry.cachedAt) > ZIP_COORD_CACHE_TTL_MS) {
          delete store[key];
          changed = true;
        }
      });
      if (changed) writeZipCoordCacheStore(store);
      const entry = store[String(zip)];
      if (!entry) return null;
      if (!Number.isFinite(entry.lat) || !Number.isFinite(entry.lon)) return null;
      return entry;
    }

    function putCachedZipCoordEntry(zip, entry) {
      if (!entry || !Number.isFinite(entry.lat) || !Number.isFinite(entry.lon)) return;
      const store = readZipCoordCacheStore();
      store[String(zip)] = {
        lat: entry.lat,
        lon: entry.lon,
        label: entry.label || String(zip),
        cachedAt: Date.now()
      };
      writeZipCoordCacheStore(store);
    }

    function parseZipCoordEntry(rawEntry, fallbackLabel) {
      if (!rawEntry || typeof rawEntry !== "object") return null;
      const lat = Number(rawEntry.lat);
      const lon = Number(rawEntry.lon);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
      return {
        lat,
        lon,
        label: typeof rawEntry.label === "string" && rawEntry.label.trim() ? rawEntry.label.trim() : fallbackLabel
      };
    }

    function fetchZipCoordinatesFromZippopotam(zip) {
      const url = "https://api.zippopotam.us/us/" + encodeURIComponent(zip);
      return fetch(url, { method: "GET" })
        .then((response) => {
          if (!response.ok) throw { type: "network_error" };
          return response.json().catch(() => {
            throw { type: "parse_error" };
          });
        })
        .then((json) => {
          const place = json && Array.isArray(json.places) ? json.places[0] : null;
          const parsed = parseZipCoordEntry({
            lat: place && place.latitude,
            lon: place && place.longitude,
            label: place
              ? (((place["place name"] || "").trim()) + ", " + (((place["state abbreviation"] || place.state || "").trim())) + " (" + zip + ")")
              : zip
          }, zip);
          if (!parsed) throw { type: "missing_data" };
          return parsed;
        });
    }

    function fetchZipCoordinatesFromCensus(zip) {
      const params = new URLSearchParams({
        address: zip,
        benchmark: "Public_AR_Current",
        format: "json"
      });
      const url = "https://geocoding.geo.census.gov/geocoder/locations/onelineaddress?" + params.toString();
      return fetch(url, { method: "GET" })
        .then((response) => {
          if (!response.ok) throw { type: "network_error" };
          return response.json().catch(() => {
            throw { type: "parse_error" };
          });
        })
        .then((json) => {
          const matches = json && json.result && Array.isArray(json.result.addressMatches) ? json.result.addressMatches : [];
          const top = matches[0];
          const parsed = parseZipCoordEntry({
            lat: top && top.coordinates && top.coordinates.y,
            lon: top && top.coordinates && top.coordinates.x,
            label: top && typeof top.matchedAddress === "string" ? (top.matchedAddress + " (" + zip + ")") : zip
          }, zip);
          if (!parsed) throw { type: "missing_data" };
          return parsed;
        });
    }

    function resolveZipCoordinates(zip) {
      const cached = getCachedZipCoordEntry(zip);
      if (cached) {
        return Promise.resolve({
          lat: cached.lat,
          lon: cached.lon,
          label: cached.label || zip
        });
      }
      return fetchZipCoordinatesFromZippopotam(zip)
        .catch(() => fetchZipCoordinatesFromCensus(zip))
        .then((entry) => {
          putCachedZipCoordEntry(zip, entry);
          return entry;
        })
        .catch(() => {
          throw { type: "location_lookup_failed" };
        });
    }

    function getCachedClimateEntry(cacheKey) {
      const store = readClimateCacheStore();
      const now = Date.now();
      let changed = false;
      Object.keys(store).forEach((key) => {
        const entry = store[key];
        if (!entry || !Number.isFinite(entry.cachedAt) || (now - entry.cachedAt) > NREL_CACHE_TTL_MS) {
          delete store[key];
          changed = true;
        }
      });
      if (changed) writeClimateCacheStore(store);
      const entry = store[cacheKey];
      if (!entry || !isValidClimateProfile(entry.profile)) return null;
      return entry;
    }

    function putCachedClimateEntry(cacheKey, entry) {
      const store = readClimateCacheStore();
      store[cacheKey] = entry;
      writeClimateCacheStore(store);
    }

    function getSyntheticHourlyByMonthProfiles() {
      return new Array(12).fill(0).map((_, month) => buildSyntheticSolarHourlyShape(month));
    }

    function buildSyntheticTempHourlyShape(monthIndex) {
      const monthAverage = Number.isFinite(SYNTHETIC_TEMP_MONTHLY_AVG_F[monthIndex]) ? SYNTHETIC_TEMP_MONTHLY_AVG_F[monthIndex] : 65;
      const season = monthSeason(monthIndex);
      const amplitude = season === "summer" ? 14 : (season === "winter" ? 9 : 11);
      return new Array(24).fill(0).map((_, hour) => {
        const radians = ((hour - 15) / 24) * Math.PI * 2;
        return monthAverage + (amplitude * Math.cos(radians));
      });
    }

    function getSyntheticTempHourlyByMonthProfiles() {
      return new Array(12).fill(0).map((_, month) => buildSyntheticTempHourlyShape(month));
    }

    function getSyntheticClimateProfile() {
      return {
        monthlyProfile: [...SOLAR_PROFILE],
        hourlyByMonth: getSyntheticHourlyByMonthProfiles(),
        tempHourlyFByMonth: getSyntheticTempHourlyByMonthProfiles(),
        tempSource: "synthetic_temp_fallback"
      };
    }

    function deriveClimateProfileFromHourly(acValues, tambValues) {
      if (!Array.isArray(acValues) || acValues.length < 24 * 365) return null;
      const monthlyTotals = new Array(12).fill(0);
      const hourlyTotalsByMonth = new Array(12).fill(0).map(() => new Array(24).fill(0));
      const syntheticTemp = getSyntheticTempHourlyByMonthProfiles();
      const tempTotalsByMonth = new Array(12).fill(0).map(() => new Array(24).fill(0));
      const tempCountsByMonth = new Array(12).fill(0).map(() => new Array(24).fill(0));
      const hasTamb = Array.isArray(tambValues) && tambValues.length >= (24 * 365);
      let tempFullyValid = hasTamb;
      let cursor = 0;
      for (let month = 0; month < 12; month += 1) {
        const monthHours = DAYS_IN_MONTH[month] * 24;
        for (let offset = 0; offset < monthHours; offset += 1) {
          const raw = Number(acValues[cursor]);
          const hourlyKwh = Number.isFinite(raw) ? Math.max(0, raw / 1000) : 0;
          const hour = offset % 24;
          monthlyTotals[month] += hourlyKwh;
          hourlyTotalsByMonth[month][hour] += hourlyKwh;
          if (hasTamb) {
            const tempC = Number(tambValues[cursor]);
            if (Number.isFinite(tempC)) {
              const tempF = (tempC * 9 / 5) + 32;
              tempTotalsByMonth[month][hour] += tempF;
              tempCountsByMonth[month][hour] += 1;
            } else {
              tempFullyValid = false;
            }
          }
          cursor += 1;
        }
      }
      const annualKwh = monthlyTotals.reduce((acc, v) => acc + v, 0);
      if (!Number.isFinite(annualKwh) || annualKwh <= 0) return null;
      const tempHourlyFByMonth = tempFullyValid
        ? tempTotalsByMonth.map((row, month) => row.map((total, hour) => {
          const count = tempCountsByMonth[month][hour];
          return count > 0 ? (total / count) : syntheticTemp[month][hour];
        }))
        : syntheticTemp;
      return {
        annualKwhPerKw: annualKwh,
        monthlyProfile: normalizeProfile(monthlyTotals),
        hourlyByMonth: hourlyTotalsByMonth.map((row, idx) => {
          const total = row.reduce((acc, v) => acc + v, 0);
          return total > 0 ? normalizeProfile(row) : buildSyntheticSolarHourlyShape(idx);
        }),
        tempHourlyFByMonth,
        tempSource: tempFullyValid ? "nrel_tamb" : "synthetic_temp_fallback"
      };
    }

    function resolveClimateLocationLabel(json, fallbackLabel) {
      const stationInfo = json && typeof json.station_info === "object" ? json.station_info : null;
      const city = stationInfo && typeof stationInfo.city === "string" ? stationInfo.city.trim() : "";
      const state = stationInfo && typeof stationInfo.state === "string" ? stationInfo.state.trim() : "";
      if (city && state) return city + ", " + state;
      if (city) return city;
      return fallbackLabel;
    }

    function resolveClimateFailureReason(errorObj) {
      if (errorObj && errorObj.type === "rate_limit_429") return "rate_limit_429";
      if (errorObj && errorObj.type === "location_lookup_failed") return "location_lookup_failed";
      if (errorObj && errorObj.type === "missing_data") return "missing_data";
      if (errorObj && errorObj.type === "parse_error") return "parse_error";
      return "network_error";
    }

    function fetchNrelClimateProfile(context, coordinates) {
      const params = new URLSearchParams({
        api_key: context.apiKey,
        lat: String(coordinates.lat),
        lon: String(coordinates.lon),
        system_capacity: String(NREL_PROFILE_PARAMS.system_capacity),
        module_type: String(NREL_PROFILE_PARAMS.module_type),
        array_type: String(NREL_PROFILE_PARAMS.array_type),
        tilt: String(NREL_PROFILE_PARAMS.tilt),
        azimuth: String(NREL_PROFILE_PARAMS.azimuth),
        losses: String(NREL_PROFILE_PARAMS.losses),
        timeframe: NREL_PROFILE_PARAMS.timeframe
      });
      return fetch(NREL_PVWATTS_URL + "?" + params.toString(), { method: "GET" })
        .then((response) => {
          if (!response.ok) {
            if (response.status === 429) {
              throw { type: "rate_limit_429" };
            }
            throw { type: "network_error" };
          }
          return response.json().catch(() => {
            throw { type: "parse_error" };
          });
        })
        .then((json) => {
          const acValues = json && json.outputs && Array.isArray(json.outputs.ac) ? json.outputs.ac : null;
          const tambValues = json && json.outputs && Array.isArray(json.outputs.tamb) ? json.outputs.tamb : null;
          const profile = deriveClimateProfileFromHourly(acValues, tambValues);
          if (!profile) {
            throw { type: "missing_data" };
          }
          return {
            profile,
            locationLabel: resolveClimateLocationLabel(json, coordinates.label || context.zip)
          };
        });
    }

    function getSyntheticAckSignature() {
      try {
        return String(sessionStorage.getItem(SYNTHETIC_ACK_SESSION_KEY) || "");
      } catch (_err) {
        return "";
      }
    }

    function isSyntheticFallbackAcknowledged(signature) {
      return !!signature && getSyntheticAckSignature() === signature;
    }

    function acknowledgeSyntheticFallback(signature) {
      try {
        sessionStorage.setItem(SYNTHETIC_ACK_SESSION_KEY, String(signature || ""));
      } catch (_err) {
        // Ignore session storage failures.
      }
    }

    function ensureClimateProfile(context, options = {}) {
      if (!context.ok) return;
      const forceRefresh = !!options.forceRefresh;
      const nowMs = Date.now();
      const signatureChanged = climateState.requestSignature !== context.signature;
      const cachedEntry = getCachedClimateEntry(context.cacheKey);
      if (signatureChanged) {
        climateState = {
          ...climateState,
          status: "fallback_synthetic",
          requestSignature: context.signature,
          keyMode: context.keyMode,
          locationLabel: context.zip,
          lastVerifiedAt: null,
          fallbackReason: "missing_data",
          profile: null,
          pending: false,
          nextRetryAt: 0,
          blockedByFallbackAck: !isSyntheticFallbackAcknowledged(context.signature)
        };
      }

      if (cachedEntry && (!isValidClimateProfile(climateState.profile) || signatureChanged || climateState.status === "fallback_synthetic" || climateState.status === "fetch_error")) {
        climateState = {
          ...climateState,
          status: "verified_cached",
          locationLabel: cachedEntry.locationLabel || context.zip,
          lastVerifiedAt: cachedEntry.lastVerifiedAt || climateState.lastVerifiedAt,
          fallbackReason: cachedEntry.fallbackReason || "",
          keyMode: context.keyMode,
          requestSignature: context.signature,
          profile: cachedEntry.profile,
          pending: false,
          blockedByFallbackAck: false
        };
        persistClimateState();
      }

      if (!forceRefresh && climateState.pending && climateState.requestSignature === context.signature) return;
      if (!forceRefresh && climateState.nextRetryAt > nowMs && climateState.requestSignature === context.signature) {
        const cooldownReason = climateState.fallbackReason || "network_error";
        const cooldownStatus = cooldownReason === "rate_limit_429" ? "fallback_synthetic" : "fetch_error";
        if (cachedEntry) {
          climateState = {
            ...climateState,
            status: "verified_cached",
            profile: cachedEntry.profile,
            locationLabel: cachedEntry.locationLabel || context.zip,
            lastVerifiedAt: cachedEntry.lastVerifiedAt || climateState.lastVerifiedAt,
            fallbackReason: cooldownReason,
            keyMode: context.keyMode,
            blockedByFallbackAck: false
          };
        } else {
          climateState = {
            ...climateState,
            status: cooldownStatus,
            fallbackReason: cooldownReason,
            keyMode: context.keyMode,
            locationLabel: context.zip,
            profile: null,
            blockedByFallbackAck: !isSyntheticFallbackAcknowledged(context.signature)
          };
        }
        persistClimateState();
        return;
      }

      const shouldRetryAfterRateLimit = !forceRefresh
        && climateState.fallbackReason === "rate_limit_429"
        && climateState.nextRetryAt <= nowMs;
      const shouldFetch = forceRefresh
        || shouldRetryAfterRateLimit
        || (!cachedEntry && !isValidClimateProfile(climateState.profile));
      if (!shouldFetch) return;

      const currentFetchToken = ++climateFetchToken;
      climateState.pending = true;
      climateState.lastFetchAttemptAt = nowMs;
      resolveZipCoordinates(context.zip)
        .then((coordinates) => fetchNrelClimateProfile(context, coordinates))
        .then((live) => {
          if (currentFetchToken !== climateFetchToken) return;
          const nowIso = new Date().toISOString();
          putCachedClimateEntry(context.cacheKey, {
            profile: live.profile,
            locationLabel: live.locationLabel || context.zip,
            lastVerifiedAt: nowIso,
            cachedAt: Date.now()
          });
          climateState = {
            ...climateState,
            status: "verified_live",
            locationLabel: live.locationLabel || context.zip,
            lastVerifiedAt: nowIso,
            fallbackReason: "",
            keyMode: context.keyMode,
            requestSignature: context.signature,
            profile: live.profile,
            pending: false,
            nextRetryAt: 0,
            blockedByFallbackAck: false
          };
          persistClimateState();
          render();
        })
        .catch((errorObj) => {
          if (currentFetchToken !== climateFetchToken) return;
          const fallbackReason = resolveClimateFailureReason(errorObj);
          const cachedAfterError = getCachedClimateEntry(context.cacheKey);
          if (fallbackReason === "rate_limit_429") {
            climateState.nextRetryAt = Date.now() + NREL_RATE_LIMIT_COOLDOWN_MS;
          } else {
            climateState.nextRetryAt = Date.now() + NREL_GENERIC_RETRY_BACKOFF_MS;
          }
          if (cachedAfterError) {
            climateState = {
              ...climateState,
              status: "verified_cached",
              profile: cachedAfterError.profile,
              locationLabel: cachedAfterError.locationLabel || context.zip,
              lastVerifiedAt: cachedAfterError.lastVerifiedAt || climateState.lastVerifiedAt,
              fallbackReason,
              keyMode: context.keyMode,
              requestSignature: context.signature,
              pending: false,
              blockedByFallbackAck: false
            };
          } else {
            const fallbackStatus = fallbackReason === "rate_limit_429" ? "fallback_synthetic" : "fetch_error";
            climateState = {
              ...climateState,
              status: fallbackStatus,
              profile: null,
              locationLabel: context.zip,
              fallbackReason,
              keyMode: context.keyMode,
              requestSignature: context.signature,
              pending: false,
              blockedByFallbackAck: !isSyntheticFallbackAcknowledged(context.signature)
            };
          }
          persistClimateState();
          render();
        });
    }

    function getClimateSnapshot(context) {
      const fallbackProfile = getSyntheticClimateProfile();
      const sameSignature = context.ok && climateState.requestSignature === context.signature;
      const activeProfile = sameSignature && isValidClimateProfile(climateState.profile) ? climateState.profile : null;
      const status = sameSignature ? climateState.status : "fallback_synthetic";
      const fallbackReason = sameSignature ? (climateState.fallbackReason || "") : "missing_data";
      const keyMode = context.ok ? context.keyMode : "demo_key";
      const pending = sameSignature ? !!climateState.pending : false;
      const blockedByFallbackAck = !!(context.ok
        && !pending
        && (status === "fallback_synthetic" || status === "fetch_error")
        && !isSyntheticFallbackAcknowledged(context.signature));
      return {
        status,
        locationLabel: sameSignature ? (climateState.locationLabel || context.zip) : (context.ok ? context.zip : "invalid ZIP"),
        lastVerifiedAt: sameSignature ? climateState.lastVerifiedAt : null,
        fallbackReason,
        keyMode,
        monthlyProfile: activeProfile ? activeProfile.monthlyProfile : fallbackProfile.monthlyProfile,
        hourlyByMonth: activeProfile ? activeProfile.hourlyByMonth : fallbackProfile.hourlyByMonth,
        tempHourlyFByMonth: activeProfile ? activeProfile.tempHourlyFByMonth : fallbackProfile.tempHourlyFByMonth,
        tempSource: activeProfile ? activeProfile.tempSource : fallbackProfile.tempSource,
        blockedByFallbackAck,
        pending,
        nextRetryAt: sameSignature ? climateState.nextRetryAt : 0
      };
    }

    function climateFallbackReasonText(code) {
      if (code === "rate_limit_429") return "NREL rate limit reached (HTTP 429).";
      if (code === "location_lookup_failed") return "ZIP geocoding failed (lat/lon lookup unavailable).";
      if (code === "network_error") return "NREL network request failed.";
      if (code === "parse_error") return "NREL response could not be parsed.";
      if (code === "missing_data") return "NREL response was missing hourly climate output.";
      return "NREL climate data unavailable.";
    }

    function formatTimestampForUi(isoText) {
      if (!isoText) return "never";
      const asDate = new Date(isoText);
      if (!Number.isFinite(asDate.getTime())) return "unknown";
      return asDate.toLocaleString("en-US", { month: "short", day: "numeric", year: "numeric", hour: "numeric", minute: "2-digit" });
    }

    function getClimateSourceText(climate) {
      if (!climate) return "Climate Source: synthetic fallback";
      if (climate.status === "verified_live") {
        return "Climate Source: NREL verified (Live) | " + climate.locationLabel;
      }
      if (climate.status === "verified_cached") {
        return "Climate Source: NREL verified (Cached) | " + climate.locationLabel;
      }
      return "Climate Source: synthetic fallback | reason: " + climateFallbackReasonText(climate.fallbackReason);
    }

    function getTemperatureSourceText(productionConfig) {
      if (!productionConfig) return "Temperature Source: synthetic fallback";
      if (productionConfig.tempSource === "nrel_tamb") {
        return "Temperature Source: NREL tamb (ambient C converted to F)";
      }
      return "Temperature Source: synthetic fallback";
    }

    function monthSeason(monthIndex) {
      if (SUMMER_MONTHS.has(monthIndex)) return "summer";
      if (WINTER_MONTHS.has(monthIndex)) return "winter";
      return "shoulder";
    }

    function buildHourRange(startHour, endHour, maxHours) {
      const start = ((startHour % 24) + 24) % 24;
      const end = ((endHour % 24) + 24) % 24;
      const hours = [];
      let cursor = start;
      let guard = 0;
      while (cursor !== end && guard < 24 && hours.length < maxHours) {
        hours.push(cursor);
        cursor = (cursor + 1) % 24;
        guard += 1;
      }
      return hours;
    }

    function inferYieldFromZip(zipRaw) {
      const parsedZip = parseZip(zipRaw);
      if (parsedZip === null) return { ok: false, annualYield: null, label: "invalid ZIP" };

      for (const hint of ZIP_YIELD_HINTS) {
        if (parsedZip >= hint.start && parsedZip <= hint.end) {
          return { ok: true, annualYield: hint.annualYield, label: hint.label };
        }
      }
      return {
        ok: true,
        annualYield: ZIP_DEFAULT_YIELD,
        label: "default profile (no regional preset)"
      };
    }

    function setFieldError(node, message) {
      node.classList.add("input-error");
      let errNode = node.parentElement.querySelector(".field-error");
      if (!errNode) {
        errNode = document.createElement("div");
        errNode.className = "field-error";
        node.parentElement.appendChild(errNode);
      }
      errNode.textContent = message;
    }

    function clearFieldError(node) {
      node.classList.remove("input-error");
      const errNode = node.parentElement.querySelector(".field-error");
      if (errNode) errNode.textContent = "";
    }

    function clearAllFieldErrors() {
      const fields = document.querySelectorAll("input, select");
      fields.forEach((node) => clearFieldError(node));
    }

    function applyRescueDefaults() {
      if (hvacSensitivityTouched) return;
      const zip = String(el.zipCode.value || "").trim();
      const defaultSensitivity = zip === RESCUE_ZIP ? RESCUE_HVAC_SENSITIVITY : DEFAULT_HVAC_SENSITIVITY;
      el.hvacSensitivityKwhPerDegHour.value = fmt(defaultSensitivity, 2);
    }

    function readNumber(node, label, errors, opts = {}) {
      const value = Number(node.value);
      if (!Number.isFinite(value)) {
        errors.push(label + " must be a valid number.");
        setFieldError(node, "Enter a valid number.");
        return null;
      }

      if (opts.integer && !Number.isInteger(value)) {
        errors.push(label + " must be an integer.");
        setFieldError(node, "Must be an integer.");
        return null;
      }

      if (opts.min !== undefined && value < opts.min) {
        errors.push(label + " must be >= " + opts.min + ".");
        setFieldError(node, "Must be >= " + opts.min + ".");
        return null;
      }

      if (opts.max !== undefined && value > opts.max) {
        errors.push(label + " must be <= " + opts.max + ".");
        setFieldError(node, "Must be <= " + opts.max + ".");
        return null;
      }

      return value;
    }

    const FIELD_SCHEMA = (() => {
      const fields = [
        { key: "powerwallCount", kind: "number", label: "Powerwalls", required: true, integer: true, min: 0, max: 4, default: 2 },
        { key: "lockPowerwallCount", kind: "checkbox", default: false },
        { key: "solarSearchMinKw", kind: "number", label: "Solar search min", required: true, min: 0, default: 2 },
        { key: "solarSearchMaxKw", kind: "number", label: "Solar search max", required: true, min: 0, default: 20 },
        { key: "solarSearchStepKw", kind: "number", label: "Solar search step", required: true, min: 0.000001, default: 0.1 },
        { key: "sizingObjective", kind: "select", options: ["return_npv", "utility_bill_knee", "total_outflow"], default: "return_npv" },
        { key: "enableWhf", kind: "checkbox", default: false },
        { key: "whfMode", kind: "select", options: ["manual", "auto"], default: "auto", enabledWhen: (values) => !!values.enableWhf },
        { key: "whfFanWatts", kind: "number", label: "WHF fan watts", required: true, min: 0, default: 200, enabledWhen: (values) => !!values.enableWhf },
        { key: "whfDisplacedAcWatts", kind: "number", label: "WHF displaced AC watts", required: true, min: 0, default: 3500, enabledWhen: (values) => !!values.enableWhf },
        { key: "whfStartHour", kind: "number", label: "WHF start hour", required: true, integer: true, min: 0, max: 23, default: 20, enabledWhen: (values) => !!values.enableWhf && values.whfMode === "manual" },
        { key: "whfStartMinute", kind: "number", label: "WHF start minute", required: true, integer: true, min: 0, max: 59, default: 30, enabledWhen: (values) => !!values.enableWhf && values.whfMode === "manual" },
        { key: "whfEndHour", kind: "number", label: "WHF end hour", required: true, integer: true, min: 0, max: 23, default: 6, enabledWhen: (values) => !!values.enableWhf && values.whfMode === "manual" },
        { key: "whfEndMinute", kind: "number", label: "WHF end minute", required: true, integer: true, min: 0, max: 59, default: 0, enabledWhen: (values) => !!values.enableWhf && values.whfMode === "manual" },
        { key: "whfSuccessRatePct", kind: "number", label: "WHF success rate", required: true, min: 0, max: 100, default: 85, enabledWhen: (values) => !!values.enableWhf && values.whfMode === "manual" },
        { key: "annualLoadKwh", kind: "number", label: "Annual load", required: true, min: 0, default: 24000 },
        { key: "hasEvCharging", kind: "checkbox", default: false },
        { key: "evMilesPerMonth", kind: "number", label: "EV miles per month", required: true, min: 0, default: 800, enabledWhen: (values) => !!values.hasEvCharging },
        { key: "evKwhPerMile", kind: "number", label: "EV kWh per mile", required: true, min: 0.000001, default: 0.30, enabledWhen: (values) => !!values.hasEvCharging },
        { key: "evDayChargingPct", kind: "number", label: "EV daytime charging share", required: true, min: 0, max: 100, default: 60, enabledWhen: (values) => !!values.hasEvCharging },
        { key: "enableHaShift", kind: "checkbox", default: false },
        { key: "haMode", kind: "select", options: ["manual", "auto"], default: "auto", enabledWhen: (values) => !!values.enableHaShift },
        { key: "summerSetpointF", kind: "number", label: "Summer setpoint", required: true, min: 55, max: 90, default: 74 },
        { key: "winterSetpointF", kind: "number", label: "Winter setpoint", required: true, min: 55, max: 90, default: 68 },
        { key: "maxPrecoolOffsetF", kind: "number", label: "Max pre-cool offset", required: true, min: 0, max: 10, default: 3, enabledWhen: (values) => !!values.enableHaShift },
        { key: "maxPreheatOffsetF", kind: "number", label: "Max pre-heat offset", required: true, min: 0, max: 10, default: 2, enabledWhen: (values) => !!values.enableHaShift },
        { key: "maxPeakRelaxOffsetF", kind: "number", label: "Max peak-hour setpoint drift", required: true, min: 0, max: 10, default: 2, enabledWhen: (values) => !!values.enableHaShift },
        { key: "hvacSensitivityKwhPerDegHour", kind: "number", label: "HVAC sensitivity", required: true, min: 0.000001, default: DEFAULT_HVAC_SENSITIVITY, enabledWhen: (values) => !!values.enableHaShift },
        { key: "hvacShiftSuccessRatePct", kind: "number", label: "HVAC shift success rate", required: true, min: 0, max: 100, default: 70, enabledWhen: (values) => !!values.enableHaShift && values.haMode === "manual" },
        { key: "preCoolStartHour", kind: "number", label: "Pre-window start hour", required: true, integer: true, min: 0, max: 23, default: 12, enabledWhen: (values) => !!values.enableHaShift && values.haMode === "manual" },
        { key: "preCoolEndHour", kind: "number", label: "Pre-window end hour", required: true, integer: true, min: 0, max: 23, default: 16, enabledWhen: (values) => !!values.enableHaShift && values.haMode === "manual" },
        { key: "maxShiftHoursPerDay", kind: "number", label: "Max shift hours/day", required: true, integer: true, min: 1, max: 12, default: 4, enabledWhen: (values) => !!values.enableHaShift },
        { key: "maxShiftKwhPerDay", kind: "number", label: "Max shift kWh/day", required: true, min: 0, default: 6, enabledWhen: (values) => !!values.enableHaShift },
        { key: "zipCode", kind: "text", required: true, default: RESCUE_ZIP },
        { key: "nrelApiKey", kind: "text", required: false, default: "" },
        { key: "tariffPreset", kind: "select", options: ["custom", "pge_e_elec"], default: "custom" },
        { key: "exportRateMode", kind: "select", options: ["nem3_override", "tou_export"], default: "nem3_override" },
        { key: "importOffPeak", kind: "number", label: "Import off-peak rate", required: true, min: 0, default: 0.36 },
        { key: "importPeak", kind: "number", label: "Import peak rate", required: true, min: 0, default: 0.58 },
        { key: "fixedMonthlyCharge", kind: "number", label: "Fixed monthly charge", required: true, min: 0, default: 24.15 },
        { key: "nbcPerImportKwh", kind: "number", label: "NBC rate", required: true, min: 0, default: 0.03 },
        { key: "nem3ExportRate", kind: "number", label: "NEM 3.0 export rate", required: true, min: 0, default: 0.04 },
        { key: "exportOffPeak", kind: "number", label: "Export off-peak rate", required: true, min: 0, default: 0.05 },
        { key: "exportPeak", kind: "number", label: "Export peak rate", required: true, min: 0, default: 0.12 },
        { key: "vppEnabled", kind: "checkbox", default: true },
        { key: "solarBaseCost", kind: "number", label: "Solar base cost", required: true, min: 0, default: 2710 },
        { key: "solarCostPerKw", kind: "number", label: "Solar cost per kW", required: true, min: 0, default: 2785 },
        { key: "batteryCost1", kind: "number", label: "1 Powerwall cost", required: true, min: 0, default: 16875 },
        { key: "batteryCost2", kind: "number", label: "2 Powerwalls cost", required: true, min: 0, default: 31250 },
        { key: "batteryCost3", kind: "number", label: "3 Powerwalls cost", required: true, min: 0, default: 45625 },
        { key: "batteryCost4", kind: "number", label: "4 Powerwalls cost", required: true, min: 0, default: 60000 },
        { key: "dispatchMode", kind: "select", options: ["self_consumption_peak_then_postpeak", "arbitrage_price_event"], default: "self_consumption_peak_then_postpeak" },
        { key: "reservePolicy", kind: "select", options: ["fixed", "auto_seasonal", "custom_monthly"], default: "auto_seasonal" },
        { key: "minSocReservePct", kind: "number", label: "Fixed minimum SOC reserve", required: true, min: 0, max: 95, default: 20, enabledWhen: (values) => values.reservePolicy === "fixed" },
        { key: "cyclesPerDay", kind: "number", label: "Cycles/day", required: true, min: 0, max: 2, default: 0.85 },
        { key: "solarToHomeEfficiencyPct", kind: "number", label: "Solar-to-home efficiency", required: true, min: 80, max: 100, default: 97.5 },
        { key: "roundTripEfficiency", kind: "number", label: "Round-trip efficiency", required: true, min: 50, max: 100, default: 90 },
        { key: "apr", kind: "number", label: "APR", required: true, min: 0, default: 6 },
        { key: "financeYears", kind: "number", label: "Loan term", required: true, integer: true, min: 1, default: 15 }
      ];
      DEFAULT_MONTHLY_RESERVE_PCT.forEach((defaultValue, month) => {
        fields.push({
          key: "monthlyReservePct" + month,
          kind: "number",
          label: MONTH_LABELS[month] + " reserve",
          required: true,
          min: 0,
          max: 95,
          default: defaultValue,
          enabledWhen: (values) => values.reservePolicy === "custom_monthly"
        });
      });
      return fields;
    })();

    function schemaFieldEnabled(field, parsedValues) {
      if (typeof field.enabledWhen === "function") {
        return !!field.enabledWhen(parsedValues);
      }
      return true;
    }

    function parseFieldsBySchema(errors) {
      const values = {};
      let hasInvalidRequired = false;
      FIELD_SCHEMA.forEach((field) => {
        const node = el[field.key];
        if (!node) return;
        const enabled = schemaFieldEnabled(field, values);
        if (!enabled) {
          clearFieldError(node);
          if (field.kind === "checkbox") {
            values[field.key] = !!field.default;
          } else if (field.default !== undefined) {
            values[field.key] = field.default;
          } else if (field.kind === "number") {
            values[field.key] = 0;
          } else {
            values[field.key] = "";
          }
          return;
        }

        if (field.kind === "checkbox") {
          values[field.key] = !!node.checked;
          return;
        }

        if (field.kind === "select") {
          const value = String(node.value || "");
          if (Array.isArray(field.options) && field.options.includes(value)) {
            values[field.key] = value;
          } else {
            const fallback = field.default !== undefined ? field.default : (field.options && field.options[0]);
            values[field.key] = fallback;
            errors.push(field.key + " must be one of " + field.options.join(", ") + ".");
            setFieldError(node, "Select a valid option.");
            hasInvalidRequired = hasInvalidRequired || !!field.required;
          }
          return;
        }

        if (field.kind === "text") {
          const value = String(node.value || "").trim();
          if (field.required && value.length === 0) {
            errors.push(field.key + " is required.");
            setFieldError(node, "Enter a value.");
            values[field.key] = field.default !== undefined ? field.default : "";
            hasInvalidRequired = true;
            return;
          }
          values[field.key] = value;
          return;
        }

        const parsed = readNumber(node, field.label || field.key, errors, {
          integer: !!field.integer,
          min: field.min,
          max: field.max
        });
        if (parsed === null) {
          values[field.key] = field.default !== undefined ? field.default : null;
          hasInvalidRequired = hasInvalidRequired || !!field.required;
          return;
        }
        values[field.key] = parsed;
      });
      return { values, hasInvalidRequired };
    }

    function collectWhfActiveMonths() {
      return el.whfMonthNodes
        .filter((node) => node.checked)
        .map((node) => Number(node.dataset.whfMonth))
        .filter((month) => Number.isInteger(month) && month >= 0 && month <= 11);
    }

    function resolveMonthlyReservePct(policy, fixedReservePct, customMonthlyReservePct) {
      if (policy === "fixed") {
        const fixed = clamp((Number(fixedReservePct) || 0) / 100, 0, 0.95);
        return new Array(12).fill(fixed);
      }
      if (policy === "custom_monthly") {
        return customMonthlyReservePct.map((value) => clamp((Number(value) || 0) / 100, 0, 0.95));
      }
      return DEFAULT_MONTHLY_RESERVE_PCT.map((value) => clamp(value / 100, 0, 0.95));
    }

    function getMonthTempProfile(tempHourlyFByMonth, monthIndex) {
      if (isValidTempHourlyByMonth(tempHourlyFByMonth)) {
        return tempHourlyFByMonth[monthIndex];
      }
      return buildSyntheticTempHourlyShape(monthIndex);
    }

    function deriveAutoWhfProfile(tempHourlyFByMonth, summerSetpointF) {
      const successRateByMonth = new Array(12).fill(0.1);
      const autoWindowByMonth = new Array(12).fill(0).map(() => ({ startMinuteOfDay: (20 * 60) + 30, endMinuteOfDay: 6 * 60 }));
      const autoActiveMonths = [];
      const candidateBandHours = [18, 19, 20, 21, 22, 23, 0, 1, 2, 3, 4, 5, 6, 7, 8];
      for (let month = 0; month < 12; month += 1) {
        const monthTemps = getMonthTempProfile(tempHourlyFByMonth, month);
        const days = DAYS_IN_MONTH[month];
        const eligiblePerDay = monthTemps.reduce((sum, tempF) => sum + ((tempF >= 55 && tempF <= 82) ? 1 : 0), 0);
        const monthlyCoolingStress = monthTemps.reduce((sum, tempF) => sum + Math.max(0, tempF - summerSetpointF), 0) / 24;
        const monthlyEligibleHours = eligiblePerDay * days;

        let best = {
          score: Number.NEGATIVE_INFINITY,
          eligibleWindowHours: 0,
          windowHours: 1,
          startHour: 20,
          endHour: 6
        };
        for (let startIdx = 0; startIdx < candidateBandHours.length - 1; startIdx += 1) {
          for (let endIdx = startIdx + 2; endIdx <= candidateBandHours.length; endIdx += 1) {
            const windowHoursList = candidateBandHours.slice(startIdx, endIdx);
            const windowHours = windowHoursList.length;
            const eligibleWindowHours = windowHoursList.reduce((sum, hour) => sum + ((monthTemps[hour] >= 55 && monthTemps[hour] <= 82) ? 1 : 0), 0);
            const avgCoolingStress = windowHoursList.reduce((sum, hour) => sum + Math.max(0, monthTemps[hour] - summerSetpointF), 0) / Math.max(1, windowHours);
            const score = (eligibleWindowHours * 1.5) + (avgCoolingStress * 0.35);
            if (score > best.score + 1e-9 || (Math.abs(score - best.score) <= 1e-9 && eligibleWindowHours > best.eligibleWindowHours)) {
              best = {
                score,
                eligibleWindowHours,
                windowHours,
                startHour: windowHoursList[0],
                endHour: (windowHoursList[windowHoursList.length - 1] + 1) % 24
              };
            }
          }
        }

        const successRate = clamp(best.eligibleWindowHours / Math.max(1, best.windowHours), 0.10, 0.95);
        const active = monthlyEligibleHours >= 45 && monthlyCoolingStress >= 0.5;
        successRateByMonth[month] = successRate;
        autoWindowByMonth[month] = {
          startMinuteOfDay: best.startHour * 60,
          endMinuteOfDay: best.endHour * 60
        };
        if (active) autoActiveMonths.push(month);
      }
      return {
        successRateByMonth,
        autoWindowByMonth,
        autoActiveMonths
      };
    }

    function deriveAutoHaProfile(tempHourlyFByMonth, summerSetpointF, winterSetpointF) {
      const successRateByMonth = new Array(12).fill(0.15);
      const autoPreWindowByMonth = new Array(12).fill(0).map(() => ({ startHour: 13, endHour: 16 }));
      for (let month = 0; month < 12; month += 1) {
        const monthTemps = getMonthTempProfile(tempHourlyFByMonth, month);
        const coolingStress = monthTemps.reduce((sum, tempF) => sum + Math.max(0, tempF - summerSetpointF), 0) / 24;
        const heatingStress = monthTemps.reduce((sum, tempF) => sum + Math.max(0, winterSetpointF - tempF), 0) / 24;
        const stressIndex = clamp((coolingStress + heatingStress) / 8, 0, 1);
        successRateByMonth[month] = clamp(0.15 + (stressIndex * 0.80), 0.15, 0.95);

        if (coolingStress > (heatingStress * 1.1)) {
          autoPreWindowByMonth[month] = { startHour: 12, endHour: 16 };
        } else if (heatingStress > (coolingStress * 1.1)) {
          autoPreWindowByMonth[month] = { startHour: 11, endHour: 15 };
        } else {
          autoPreWindowByMonth[month] = { startHour: 13, endHour: 16 };
        }
      }
      return {
        successRateByMonth,
        autoPreWindowByMonth
      };
    }

    function collectInputs() {
      clearAllFieldErrors();
      const errors = [];
      const parsed = parseFieldsBySchema(errors);
      const values = parsed.values;
      const zipInfo = inferYieldFromZip(values.zipCode);
      const climateContext = buildClimateContext(values.zipCode, values.nrelApiKey);
      const climateSnapshot = getClimateSnapshot(climateContext);
      if (!zipInfo.ok) {
        errors.push("ZIP code must be a valid 5-digit value.");
        setFieldError(el.zipCode, "Enter a 5-digit ZIP.");
      }

      if (values.solarSearchMaxKw !== null && values.solarSearchMinKw !== null && values.solarSearchMaxKw < values.solarSearchMinKw) {
        errors.push("Solar search max must be >= min.");
        setFieldError(el.solarSearchMaxKw, "Must be >= min.");
      }

      if (values.solarSearchStepKw !== null && values.solarSearchStepKw <= 0) {
        errors.push("Solar search step must be > 0.");
        setFieldError(el.solarSearchStepKw, "Must be > 0.");
      }

      const whfActiveMonthsManual = collectWhfActiveMonths();
      if (parsed.hasInvalidRequired || !zipInfo.ok) {
        return { errors, inputs: null, zipInfo };
      }

      if (values.enableHaShift && values.haMode === "manual") {
        const candidateHours = buildHourRange(values.preCoolStartHour, values.preCoolEndHour, 24);
        if (candidateHours.length === 0) {
          errors.push("Pre-window start and end hour must define a non-zero window.");
          setFieldError(el.preCoolEndHour, "Must define non-zero window.");
        }
      }
      if (values.enableWhf && values.whfMode === "manual") {
        const whfStartMinuteOfDay = (values.whfStartHour * 60) + values.whfStartMinute;
        const whfEndMinuteOfDay = (values.whfEndHour * 60) + values.whfEndMinute;
        if (whfStartMinuteOfDay === whfEndMinuteOfDay) {
          errors.push("WHF start and end times must define a non-zero window.");
          setFieldError(el.whfEndMinute, "Must define non-zero window.");
        }
        if (!whfActiveMonthsManual.length) {
          errors.push("WHF must have at least one active month.");
          setFieldError(el.whfSuccessRatePct, "Select >= 1 active month.");
        }
      }

      if (errors.length) {
        return { errors, inputs: null, zipInfo };
      }

      const monthlyReservePctRaw = new Array(12).fill(0).map((_, month) => {
        const key = "monthlyReservePct" + month;
        const numericValue = Number(values[key]);
        return clamp(Number.isFinite(numericValue) ? numericValue : DEFAULT_MONTHLY_RESERVE_PCT[month], 0, 95);
      });
      const monthlyReservePct = resolveMonthlyReservePct(values.reservePolicy, values.minSocReservePct, monthlyReservePctRaw);
      const temperatureProfile = isValidTempHourlyByMonth(climateSnapshot.tempHourlyFByMonth)
        ? climateSnapshot.tempHourlyFByMonth
        : getSyntheticTempHourlyByMonthProfiles();

      const autoWhfProfile = deriveAutoWhfProfile(temperatureProfile, values.summerSetpointF);
      const autoHaProfile = deriveAutoHaProfile(temperatureProfile, values.summerSetpointF, values.winterSetpointF);

      const manualWhfStartMinuteOfDay = (values.whfStartHour * 60) + values.whfStartMinute;
      const manualWhfEndMinuteOfDay = (values.whfEndHour * 60) + values.whfEndMinute;
      const manualWhfSuccess = clamp((Number(values.whfSuccessRatePct) || 0) / 100, 0, 1);
      const whfSuccessRateByMonth = values.enableWhf
        ? (values.whfMode === "auto"
          ? autoWhfProfile.successRateByMonth
          : new Array(12).fill(manualWhfSuccess))
        : new Array(12).fill(0);
      const whfAutoWindowByMonth = values.enableWhf
        ? (values.whfMode === "auto"
          ? autoWhfProfile.autoWindowByMonth
          : new Array(12).fill(0).map(() => ({
            startMinuteOfDay: manualWhfStartMinuteOfDay,
            endMinuteOfDay: manualWhfEndMinuteOfDay
          })))
        : new Array(12).fill(0).map(() => ({ startMinuteOfDay: 0, endMinuteOfDay: 0 }));
      const whfAutoActiveMonths = values.enableWhf
        ? (values.whfMode === "auto" ? autoWhfProfile.autoActiveMonths : whfActiveMonthsManual)
        : [];

      const manualHaSuccess = clamp((Number(values.hvacShiftSuccessRatePct) || 0) / 100, 0, 1);
      const haSuccessRateByMonth = values.enableHaShift
        ? (values.haMode === "auto"
          ? autoHaProfile.successRateByMonth
          : new Array(12).fill(manualHaSuccess))
        : new Array(12).fill(0);
      const haAutoPreWindowByMonth = values.enableHaShift
        ? (values.haMode === "auto"
          ? autoHaProfile.autoPreWindowByMonth
          : new Array(12).fill(0).map(() => ({
            startHour: values.preCoolStartHour,
            endHour: values.preCoolEndHour
          })))
        : new Array(12).fill(0).map(() => ({ startHour: 12, endHour: 16 }));

      const evDayChargingShare = values.hasEvCharging ? clamp(values.evDayChargingPct / 100, 0, 1) : 0;
      const evNightChargingShare = values.hasEvCharging ? (1 - evDayChargingShare) : 0;
      const evKwhPerMonth = values.hasEvCharging ? values.evMilesPerMonth * values.evKwhPerMile : 0;

      const inputs = {
        sizing: {
          powerwallCount: values.powerwallCount,
          lockPowerwallCount: values.lockPowerwallCount,
          solarSearchMinKw: values.solarSearchMinKw,
          solarSearchMaxKw: values.solarSearchMaxKw,
          solarSearchStepKw: values.solarSearchStepKw,
          objectiveMode: values.sizingObjective
        },
        analysis: {
          years: 15,
          discountRate: 0.05,
          utilityEscalation: 0.03,
          solarDegradation: 0.005,
          batteryDegradation: 0.02
        },
        production: {
          annualYield: zipInfo.annualYield,
          zipLabel: zipInfo.label,
          solarToHomeEfficiency: clamp(values.solarToHomeEfficiencyPct / 100, 0.8, 1),
          solarMonthlyProfile: climateSnapshot.monthlyProfile,
          solarHourlyByMonth: climateSnapshot.hourlyByMonth,
          tempHourlyFByMonth: temperatureProfile,
          tempSource: climateSnapshot.tempSource || "synthetic_temp_fallback"
        },
        load: {
          annualKwh: values.annualLoadKwh,
          peakShare: 0.4,
          monthProfile: LOAD_PROFILE,
          summerSetpointF: values.summerSetpointF,
          winterSetpointF: values.winterSetpointF
        },
        ev: {
          enabled: values.hasEvCharging,
          milesPerMonth: values.hasEvCharging ? values.evMilesPerMonth : 0,
          kwhPerMile: values.hasEvCharging ? values.evKwhPerMile : 0.30,
          dayChargingShare: evDayChargingShare,
          nightChargingShare: evNightChargingShare,
          kwhPerMonth: evKwhPerMonth,
          chargingRule: "solar_first_shift"
        },
        ha: {
          enabled: values.enableHaShift,
          mode: values.enableHaShift ? values.haMode : "manual",
          successRateByMonth: haSuccessRateByMonth,
          autoPreWindowByMonth: haAutoPreWindowByMonth,
          tempUnits: "F",
          summerSetpointF: values.summerSetpointF,
          winterSetpointF: values.winterSetpointF,
          maxPrecoolOffsetF: values.enableHaShift ? values.maxPrecoolOffsetF : 0,
          maxPreheatOffsetF: values.enableHaShift ? values.maxPreheatOffsetF : 0,
          maxPeakRelaxOffsetF: values.enableHaShift ? values.maxPeakRelaxOffsetF : 0,
          hvacSensitivityKwhPerDegHour: values.enableHaShift ? values.hvacSensitivityKwhPerDegHour : DEFAULT_HVAC_SENSITIVITY,
          successRate: values.enableHaShift ? manualHaSuccess : 0,
          preCoolStartHour: values.enableHaShift ? values.preCoolStartHour : 12,
          preCoolEndHour: values.enableHaShift ? values.preCoolEndHour : 16,
          maxShiftHoursPerDay: values.enableHaShift ? values.maxShiftHoursPerDay : 0,
          maxShiftKwhPerDay: values.enableHaShift ? values.maxShiftKwhPerDay : 0,
          horizon: "day_ahead_heuristic",
          seasonMap: {
            summerMonths: [4, 5, 6, 7, 8],
            winterMonths: [10, 11, 0, 1],
            shoulderMonths: [2, 3, 9]
          }
        },
        vpp: {
          enabled: values.vppEnabled
        },
        whf: {
          enabled: values.enableWhf,
          mode: values.enableWhf ? values.whfMode : "manual",
          fanWatts: values.enableWhf ? values.whfFanWatts : 0,
          displacedAcWatts: values.enableWhf ? values.whfDisplacedAcWatts : 0,
          startMinuteOfDay: values.enableWhf ? manualWhfStartMinuteOfDay : 0,
          endMinuteOfDay: values.enableWhf ? manualWhfEndMinuteOfDay : 0,
          activeMonths: values.enableWhf ? whfActiveMonthsManual : [],
          successRate: values.enableWhf ? manualWhfSuccess : 0,
          successRateByMonth: whfSuccessRateByMonth,
          autoWindowByMonth: whfAutoWindowByMonth,
          autoActiveMonths: whfAutoActiveMonths
        },
        rates: {
          tariffPreset: values.tariffPreset,
          importOffPeak: values.importOffPeak,
          importPeak: values.importPeak,
          fixedMonthlyCharge: values.fixedMonthlyCharge,
          nbcPerImportKwh: values.nbcPerImportKwh,
          exportRateMode: values.exportRateMode,
          nem3ExportRate: values.nem3ExportRate,
          exportOffPeak: values.exportOffPeak,
          exportPeak: values.exportPeak
        },
        pricing: {
          solarBaseCost: values.solarBaseCost,
          solarCostPerKw: values.solarCostPerKw,
          batteryCosts: {
            0: 0,
            1: values.batteryCost1,
            2: values.batteryCost2,
            3: values.batteryCost3,
            4: values.batteryCost4
          }
        },
        battery: {
          usableKwhPerBattery: BATTERY_USABLE_KWH,
          cyclesPerDay: values.cyclesPerDay,
          roundTripEfficiency: clamp(values.roundTripEfficiency / 100, 0.5, 1),
          dispatchMode: values.dispatchMode,
          reservePolicy: values.reservePolicy,
          minSocReservePct: clamp((values.minSocReservePct || 0) / 100, 0, 0.95),
          monthlyReservePct
        },
        financing: {
          apr: values.apr / 100,
          years: values.financeYears
        },
        climate: {
          status: climateSnapshot.status,
          locationLabel: climateSnapshot.locationLabel,
          lastVerifiedAt: climateSnapshot.lastVerifiedAt,
          fallbackReason: climateSnapshot.fallbackReason,
          keyMode: climateSnapshot.keyMode,
          blockedByFallbackAck: climateSnapshot.blockedByFallbackAck,
          pending: climateSnapshot.pending,
          nextRetryAt: climateSnapshot.nextRetryAt,
          tempSource: climateSnapshot.tempSource || "synthetic_temp_fallback"
        }
      };

      return { errors, inputs, zipInfo };
    }

    function buildSolarCandidates(minKw, maxKw, stepKw) {
      const precision = Math.min(6, Math.max(decimalPlaces(minKw), decimalPlaces(maxKw), decimalPlaces(stepKw), 3));
      const factor = Math.pow(10, precision);

      const start = Math.round(minKw * factor);
      const end = Math.round(maxKw * factor);
      const inc = Math.round(stepKw * factor);

      if (inc <= 0 || end < start) return [];

      const values = [];
      let guard = 0;
      for (let value = start; value <= end; value += inc) {
        values.push(Number((value / factor).toFixed(precision)));
        guard += 1;
        if (guard > 50000) break;
      }

      const exactMax = Number((end / factor).toFixed(precision));
      if (!values.length) {
        values.push(exactMax);
      } else if (Math.abs(values[values.length - 1] - exactMax) > 1e-9) {
        values.push(exactMax);
      }

      const uniqueSorted = Array.from(new Set(values)).sort((a, b) => a - b);
      return uniqueSorted;
    }

    function buildHourlyLoadShape(targetPeakShare) {
      const basePeakShare = BASE_LOAD_HOURLY.reduce((acc, v, hour) => acc + (PEAK_HOURS.has(hour) ? v : 0), 0);
      if (basePeakShare <= 0 || basePeakShare >= 1) {
        return BASE_LOAD_HOURLY;
      }

      const constrainedTarget = clamp(targetPeakShare, 0.05, 0.95);
      const peakScale = constrainedTarget / basePeakShare;
      const offScale = (1 - constrainedTarget) / (1 - basePeakShare);
      return normalizeProfile(BASE_LOAD_HOURLY.map((v, hour) => v * (PEAK_HOURS.has(hour) ? peakScale : offScale)));
    }

    function buildSyntheticSolarHourlyShape(monthIndex) {
      const daylight = MONTHLY_DAYLIGHT_HOURS[monthIndex] || 12;
      const sunrise = 12 - daylight / 2;
      const sunset = 12 + daylight / 2;
      const sigma = Math.max(1.4, daylight / 4.2);
      const profile = new Array(24).fill(0).map((_, hour) => {
        const center = hour + 0.5;
        if (center < sunrise || center > sunset) return 0;
        const spread = center - 12;
        return Math.exp(-(spread * spread) / (2 * sigma * sigma));
      });
      return normalizeProfile(profile);
    }

    function buildSolarHourlyShape(monthIndex, solarHourlyByMonth = null) {
      if (isValidHourlyByMonth(solarHourlyByMonth) && Array.isArray(solarHourlyByMonth[monthIndex]) && solarHourlyByMonth[monthIndex].length === 24) {
        return normalizeProfile(solarHourlyByMonth[monthIndex].map((v) => Number.isFinite(v) ? Math.max(0, v) : 0));
      }
      return buildSyntheticSolarHourlyShape(monthIndex);
    }

    function getSeasonDailyHvacShiftCapacity(ha, monthIndex, preWindowHours) {
      const summerCap = ha.maxPrecoolOffsetF * ha.hvacSensitivityKwhPerDegHour * preWindowHours;
      const winterCap = ha.maxPreheatOffsetF * ha.hvacSensitivityKwhPerDegHour * preWindowHours;
      const summerRelaxCap = ha.maxPeakRelaxOffsetF * ha.hvacSensitivityKwhPerDegHour * PEAK_WINDOW_HOURS.length;
      const winterRelaxCap = ha.maxPeakRelaxOffsetF * ha.hvacSensitivityKwhPerDegHour * PEAK_WINDOW_HOURS.length;
      const shoulderCap = 0.5 * summerCap + 0.5 * winterCap;
      const shoulderRelaxCap = 0.5 * summerRelaxCap + 0.5 * winterRelaxCap;
      const season = monthSeason(monthIndex);
      const seasonPreCap = season === "summer" ? summerCap : (season === "winter" ? winterCap : shoulderCap);
      const seasonRelaxCap = season === "summer" ? summerRelaxCap : (season === "winter" ? winterRelaxCap : shoulderRelaxCap);
      const seasonRawTotal = seasonPreCap + seasonRelaxCap;
      const seasonCap = Math.min(seasonRawTotal, ha.maxShiftKwhPerDay);
      const denom = seasonRawTotal > 0 ? seasonRawTotal : 1;
      const preShare = seasonRawTotal > 0 ? (seasonPreCap / denom) : 0;
      return {
        season,
        summerCap,
        winterCap,
        shoulderCap,
        seasonPreCap,
        seasonRelaxCap,
        seasonCap,
        preShare,
        relaxShare: 1 - preShare
      };
    }

    function getSeasonLoadMultiplier(loadConfig, monthIndex) {
      const summerRaw = 1 + ((BASE_SUMMER_SETPOINT_F - loadConfig.summerSetpointF) * SUMMER_SETPOINT_LOAD_SENSITIVITY_PER_DEG);
      const winterRaw = 1 + ((loadConfig.winterSetpointF - BASE_WINTER_SETPOINT_F) * WINTER_SETPOINT_LOAD_SENSITIVITY_PER_DEG);
      const summerMult = clamp(summerRaw, 0.7, 1.4);
      const winterMult = clamp(winterRaw, 0.7, 1.4);
      const shoulderMult = clamp(0.5 * summerMult + 0.5 * winterMult, 0.7, 1.4);
      const season = monthSeason(monthIndex);
      return season === "summer" ? summerMult : (season === "winter" ? winterMult : shoulderMult);
    }

    function getHvacShiftPlan(dayInput, loadShape) {
      if (!dayInput.haEnabled) {
        return {
          enabled: false,
          shiftByHour: new Array(24).fill(0),
          preWindowHours: 0,
          season: monthSeason(dayInput.monthIndex),
          activeSetpointF: null,
          activeOffsetF: 0,
          dailyShiftCapacityKwh: 0,
          dailyShiftScheduledKwh: 0,
          dailyShiftExecutedKwh: 0,
          dailyShiftToPreWindowKwh: 0,
          dailyShiftToPostPeakKwh: 0
        };
      }

      const preCandidate = buildHourRange(dayInput.haPreCoolStartHour, dayInput.haPreCoolEndHour, 24);
      const preWindowHoursList = preCandidate.slice(0, dayInput.haMaxShiftHoursPerDay);
      const preWindowHours = preWindowHoursList.length;

      const seasonInfo = getSeasonDailyHvacShiftCapacity(dayInput.ha, dayInput.monthIndex, preWindowHours);
      const peakHomeLoadAvailable = PEAK_WINDOW_HOURS.reduce((sum, hour) => sum + (dayInput.dayHomeLoadKwh * loadShape[hour]), 0);
      const dailyShiftCapacityKwh = seasonInfo.seasonCap;
      const dailyShiftScheduledKwh = Math.min(dailyShiftCapacityKwh, peakHomeLoadAvailable);
      const targetExecuted = dailyShiftScheduledKwh * dayInput.haSuccessRate;

      const shiftByHour = new Array(24).fill(0);
      let actualShiftExecuted = 0;

      let shiftToPreWindow = 0;
      let shiftToPostPeak = 0;
      const postPeakHours = [21, 22, 23];

      if (targetExecuted > 0 && peakHomeLoadAvailable > 0) {
        for (const hour of PEAK_WINDOW_HOURS) {
          const hourLoad = dayInput.dayHomeLoadKwh * loadShape[hour];
          const proportionalRemoval = targetExecuted * (hourLoad / peakHomeLoadAvailable);
          const removed = Math.min(hourLoad, proportionalRemoval);
          shiftByHour[hour] -= removed;
          actualShiftExecuted += removed;
        }

        shiftToPreWindow = actualShiftExecuted * seasonInfo.preShare;
        shiftToPostPeak = actualShiftExecuted - shiftToPreWindow;

        if (preWindowHoursList.length === 0) {
          shiftToPostPeak = actualShiftExecuted;
          shiftToPreWindow = 0;
        }

        if (preWindowHoursList.length > 0 && shiftToPreWindow > 0) {
          const addPerPreWindowHour = shiftToPreWindow / preWindowHoursList.length;
          for (const hour of preWindowHoursList) {
            shiftByHour[hour] += addPerPreWindowHour;
          }
        }

        if (shiftToPostPeak > 0) {
          const addPerPostHour = shiftToPostPeak / postPeakHours.length;
          for (const hour of postPeakHours) {
            shiftByHour[hour] += addPerPostHour;
          }
        }
      }

      const season = seasonInfo.season;
      const activeSetpointF = season === "summer"
        ? dayInput.haSummerSetpointF
        : (season === "winter" ? dayInput.haWinterSetpointF : (dayInput.haSummerSetpointF + dayInput.haWinterSetpointF) / 2);
      const activeOffsetF = season === "summer"
        ? dayInput.haMaxPrecoolOffsetF
        : (season === "winter" ? dayInput.haMaxPreheatOffsetF : (dayInput.haMaxPrecoolOffsetF + dayInput.haMaxPreheatOffsetF) / 2);

      return {
        enabled: true,
        shiftByHour,
        preWindowHours,
        season,
        activeSetpointF,
        activeOffsetF,
        dailyShiftCapacityKwh,
        dailyShiftScheduledKwh,
        dailyShiftExecutedKwh: actualShiftExecuted,
        dailyShiftToPreWindowKwh: shiftToPreWindow,
        dailyShiftToPostPeakKwh: shiftToPostPeak
      };
    }

    function minuteInWindow(minuteOfDay, startMinuteOfDay, endMinuteOfDay) {
      if (startMinuteOfDay === endMinuteOfDay) return false;
      if (startMinuteOfDay < endMinuteOfDay) {
        return minuteOfDay >= startMinuteOfDay && minuteOfDay < endMinuteOfDay;
      }
      return minuteOfDay >= startMinuteOfDay || minuteOfDay < endMinuteOfDay;
    }

    function getWholeHouseFanPlan(dayInput) {
      if (!dayInput.whfEnabled || !dayInput.whfActiveMonth) {
        return {
          enabled: false,
          activeHourSet: new Set(),
          fanKwhPerHour: 0,
          displacedKwhPerHour: 0,
          netReductionKwhPerHour: 0
        };
      }

      const activeHours = [];
      for (let hour = 0; hour < 24; hour += 1) {
        const minute = (hour * 60) + 30;
        if (minuteInWindow(minute, dayInput.whfStartMinuteOfDay, dayInput.whfEndMinuteOfDay)) {
          activeHours.push(hour);
        }
      }
      const displacedKwhPerHour = (dayInput.whfDisplacedAcWatts / 1000) * dayInput.whfSuccessRate;
      const fanKwhPerHour = (dayInput.whfFanWatts / 1000) * dayInput.whfSuccessRate;
      const netReductionKwhPerHour = Math.max(0, displacedKwhPerHour - fanKwhPerHour);

      return {
        enabled: true,
        activeHourSet: new Set(activeHours),
        fanKwhPerHour,
        displacedKwhPerHour,
        netReductionKwhPerHour
      };
    }

    function simulateRepresentativeDay(dayInput) {
      const loadShape = buildHourlyLoadShape(dayInput.peakShare);
      const solarShape = buildSolarHourlyShape(dayInput.monthIndex, dayInput.solarHourlyByMonth);
      const batteryCapacity = dayInput.powerwallCount * dayInput.usableKwhPerBattery;
      const maxDailyDischarge = batteryCapacity * dayInput.cyclesPerDay;
      const minSocReserveKwh = batteryCapacity * (dayInput.minSocReservePct || 0);
      const solarToHomeEfficiency = clamp(dayInput.solarToHomeEfficiency || 1, 0.8, 1);
      const maxAcOutputKw = Number.isFinite(dayInput.maxAcOutputKw) ? Math.max(0, dayInput.maxAcOutputKw) : Number.POSITIVE_INFINITY;
      const haPlan = getHvacShiftPlan(dayInput, loadShape);
      const whfPlan = getWholeHouseFanPlan(dayInput);
      const evDayTarget = dayInput.evEnabled ? dayInput.evDayTargetKwh : 0;
      const evNightTarget = dayInput.evEnabled ? dayInput.evNightTargetKwh : 0;
      const evBeforeDayPerHour = evDayTarget / DAY_CHARGING_HOURS.length;
      const evBeforeNightPerHour = evNightTarget / NIGHT_CHARGING_HOURS.length;

      let soc = batteryCapacity * 0.3;
      let measured = null;
      const warmupDays = 3;

      for (let day = 0; day <= warmupDays; day += 1) {
        let remainingDischarge = maxDailyDischarge;
        let evDayRemaining = evDayTarget;
        let evShiftToNight = 0;
        const stats = {
          beforeImportPeakKwh: 0,
          beforeImportOffKwh: 0,
          importPeakKwh: 0,
          importOffKwh: 0,
          exportKwh: 0,
          exportPeakKwh: 0,
          exportOffKwh: 0,
          directSolarToLoad: 0,
          solarToBatteryInputKwh: 0,
          solarToBatteryStoredKwh: 0,
          batteryToLoad: 0,
          batteryToGridExportKwh: 0,
          batteryToLoadPeakKwh: 0,
          batteryToLoadPostPeakKwh: 0,
          batteryReserveHits: 0,
          minSocKwh: soc,
          evDaySolarServedKwh: 0,
          evDayShiftedToNightKwh: 0,
          evNightLoadAfterKwh: 0,
          hvacShiftCapacityKwh: haPlan.dailyShiftCapacityKwh,
          hvacShiftScheduledKwh: haPlan.dailyShiftScheduledKwh,
          hvacShiftExecutedKwh: haPlan.dailyShiftExecutedKwh,
          hvacShiftToPreWindowKwh: haPlan.dailyShiftToPreWindowKwh,
          hvacShiftToPostPeakKwh: haPlan.dailyShiftToPostPeakKwh,
          hvacPeakImportAvoidedKwh: 0,
          whfFanKwh: 0,
          whfDisplacedAcKwh: 0,
          whfNetReductionKwh: 0,
          whfActiveHours: 0,
          minHomeLoadKwh: Number.POSITIVE_INFINITY,
          clippedSolarKwh: 0,
          solarGenerationKwh: 0
        };

        for (let hour = 0; hour < 24; hour += 1) {
          const peakHour = PEAK_HOURS.has(hour);
          const dayChargeHour = DAY_CHARGING_HOUR_SET.has(hour);
          const nightChargeHour = NIGHT_CHARGING_HOUR_SET.has(hour);
          let hourlyHomeLoad = Math.max(0, (dayInput.dayHomeLoadKwh * loadShape[hour]) + haPlan.shiftByHour[hour]);
          if (whfPlan.enabled && whfPlan.activeHourSet.has(hour)) {
            stats.whfActiveHours += 1;
            stats.whfFanKwh += whfPlan.fanKwhPerHour;
            stats.whfDisplacedAcKwh += whfPlan.displacedKwhPerHour;
            stats.whfNetReductionKwh += whfPlan.netReductionKwhPerHour;
            hourlyHomeLoad = Math.max(0, hourlyHomeLoad - whfPlan.netReductionKwhPerHour);
          }
          stats.minHomeLoadKwh = Math.min(stats.minHomeLoadKwh, hourlyHomeLoad);
          const hourlyEvBeforeLoad = (dayChargeHour ? evBeforeDayPerHour : 0) + (nightChargeHour ? evBeforeNightPerHour : 0);
          const hourlySolarRaw = dayInput.daySolarKwh * solarShape[hour];
          const hourlySolar = Math.min(hourlySolarRaw, maxAcOutputKw);
          stats.clippedSolarKwh += Math.max(0, hourlySolarRaw - hourlySolar);
          stats.solarGenerationKwh += hourlySolar;

          if (hour === 16 && evDayRemaining > 0) {
            evShiftToNight = evDayRemaining;
            stats.evDayShiftedToNightKwh = evDayRemaining;
            evDayRemaining = 0;
          }

          if (peakHour) stats.beforeImportPeakKwh += hourlyHomeLoad + hourlyEvBeforeLoad;
          else stats.beforeImportOffKwh += hourlyHomeLoad + hourlyEvBeforeLoad;

          let loadRemaining = hourlyHomeLoad;
          let solarRemaining = hourlySolar;

          const directSolarDelivered = Math.min(loadRemaining, solarRemaining * solarToHomeEfficiency);
          if (directSolarDelivered > 0) {
            const directSolarDc = directSolarDelivered / solarToHomeEfficiency;
            loadRemaining -= directSolarDelivered;
            solarRemaining -= directSolarDc;
            stats.directSolarToLoad += directSolarDelivered;
          }

          if (batteryCapacity > 0 && solarRemaining > 0) {
            const chargeRoom = Math.max(0, batteryCapacity - soc);
            const chargeInput = Math.min(solarRemaining, chargeRoom / dayInput.roundTripEfficiency);
            if (chargeInput > 0) {
              const storedEnergy = chargeInput * dayInput.roundTripEfficiency;
              soc += storedEnergy;
              solarRemaining -= chargeInput;
              stats.solarToBatteryInputKwh += chargeInput;
              stats.solarToBatteryStoredKwh += storedEnergy;
            }
          }

          if (dayChargeHour && evDayRemaining > 0 && solarRemaining > 0) {
            const evDaySolarServed = Math.min(evDayRemaining, solarRemaining * solarToHomeEfficiency);
            if (evDaySolarServed > 0) {
              const evDaySolarDc = evDaySolarServed / solarToHomeEfficiency;
              solarRemaining -= evDaySolarDc;
              evDayRemaining -= evDaySolarServed;
              stats.evDaySolarServedKwh += evDaySolarServed;
            }
          }

          if (nightChargeHour) {
            let nightDemand = evBeforeNightPerHour;
            if (hour >= 21 && evShiftToNight > 0) {
              nightDemand += evShiftToNight / 3;
            }
            loadRemaining += nightDemand;
            stats.evNightLoadAfterKwh += nightDemand;
          }

          const importRate = peakHour ? (Number(dayInput.importPeakRate) || 0) : (Number(dayInput.importOffPeakRate) || 0);
          const exportRate = peakHour ? (Number(dayInput.exportPeakRate) || 0) : (Number(dayInput.exportOffPeakRate) || 0);
          const selfConsumptionWindow = peakHour || POST_PEAK_HOUR_SET.has(hour);
          const allowLoadDischarge = dayInput.dispatchMode === "arbitrage_price_event"
            ? true
            : selfConsumptionWindow;

          if (allowLoadDischarge && batteryCapacity > 0 && remainingDischarge > 0 && loadRemaining > 0) {
            const availableDischarge = Math.max(0, soc - minSocReserveKwh);
            const discharge = Math.min(loadRemaining, availableDischarge, remainingDischarge);
            if (discharge > 0) {
              soc -= discharge;
              remainingDischarge -= discharge;
              loadRemaining -= discharge;
              stats.batteryToLoad += discharge;
              if (peakHour) stats.batteryToLoadPeakKwh += discharge;
              else stats.batteryToLoadPostPeakKwh += discharge;
            } else if (availableDischarge <= 1e-9) {
              stats.batteryReserveHits += 1;
            }
          }

          if (dayInput.dispatchMode === "arbitrage_price_event" && batteryCapacity > 0 && remainingDischarge > 0 && exportRate > importRate + 1e-9) {
            const availableForExport = Math.max(0, soc - minSocReserveKwh);
            const dischargeToGrid = Math.min(availableForExport, remainingDischarge);
            if (dischargeToGrid > 0) {
              soc -= dischargeToGrid;
              remainingDischarge -= dischargeToGrid;
              stats.batteryToGridExportKwh += dischargeToGrid;
              stats.exportKwh += dischargeToGrid;
              if (peakHour) stats.exportPeakKwh += dischargeToGrid;
              else stats.exportOffKwh += dischargeToGrid;
            } else if (availableForExport <= 1e-9) {
              stats.batteryReserveHits += 1;
            }
          }

          stats.minSocKwh = Math.min(stats.minSocKwh, soc);

          if (peakHour) stats.importPeakKwh += loadRemaining;
          else stats.importOffKwh += loadRemaining;

          const solarExport = Math.max(0, solarRemaining * solarToHomeEfficiency);
          stats.exportKwh += solarExport;
          if (peakHour) stats.exportPeakKwh += solarExport;
          else stats.exportOffKwh += solarExport;
        }

        if (evDayRemaining > 0) {
          stats.evDayShiftedToNightKwh += evDayRemaining;
        }

        const peakGridDependency = stats.beforeImportPeakKwh > 0 ? (stats.importPeakKwh / stats.beforeImportPeakKwh) : 0;
        stats.hvacPeakImportAvoidedKwh = stats.hvacShiftExecutedKwh * peakGridDependency;

        measured = stats;
      }

      return measured;
    }

    function getHaMonthDispatchConfig(ha, monthIndex) {
      if (!ha || !ha.enabled) {
        return {
          haSuccessRate: 0,
          haPreCoolStartHour: 12,
          haPreCoolEndHour: 16,
          haMaxShiftHoursPerDay: 0
        };
      }
      const autoWindow = Array.isArray(ha.autoPreWindowByMonth) ? ha.autoPreWindowByMonth[monthIndex] : null;
      const manualWindow = {
        startHour: Number.isFinite(ha.preCoolStartHour) ? ha.preCoolStartHour : 12,
        endHour: Number.isFinite(ha.preCoolEndHour) ? ha.preCoolEndHour : 16
      };
      const selectedWindow = ha.mode === "auto" && autoWindow ? autoWindow : manualWindow;
      const startHour = clamp(Math.floor(Number(selectedWindow.startHour) || 0), 0, 23);
      const endHour = clamp(Math.floor(Number(selectedWindow.endHour) || 0), 0, 23);
      const autoMaxShiftHours = Math.max(1, buildHourRange(startHour, endHour, 24).length);
      const maxShiftHoursPerDay = ha.mode === "auto"
        ? autoMaxShiftHours
        : clamp(Math.floor(Number(ha.maxShiftHoursPerDay) || 0), 1, 12);
      const monthSuccess = (ha.mode === "auto" && Array.isArray(ha.successRateByMonth))
        ? ha.successRateByMonth[monthIndex]
        : ha.successRate;
      return {
        haSuccessRate: clamp(Number(monthSuccess) || 0, 0, 1),
        haPreCoolStartHour: startHour,
        haPreCoolEndHour: endHour,
        haMaxShiftHoursPerDay: maxShiftHoursPerDay
      };
    }

    function getWhfMonthDispatchConfig(whf, monthIndex) {
      if (!whf || !whf.enabled) {
        return {
          whfActiveMonth: false,
          whfSuccessRate: 0,
          whfStartMinuteOfDay: 0,
          whfEndMinuteOfDay: 0
        };
      }
      const autoWindow = Array.isArray(whf.autoWindowByMonth) ? whf.autoWindowByMonth[monthIndex] : null;
      const selectedWindow = whf.mode === "auto" && autoWindow
        ? autoWindow
        : {
          startMinuteOfDay: Number.isFinite(whf.startMinuteOfDay) ? whf.startMinuteOfDay : 0,
          endMinuteOfDay: Number.isFinite(whf.endMinuteOfDay) ? whf.endMinuteOfDay : 0
        };
      const activeMonths = whf.mode === "auto" ? (whf.autoActiveMonths || []) : (whf.activeMonths || []);
      const monthSuccess = (whf.mode === "auto" && Array.isArray(whf.successRateByMonth))
        ? whf.successRateByMonth[monthIndex]
        : whf.successRate;
      return {
        whfActiveMonth: activeMonths.includes(monthIndex),
        whfSuccessRate: clamp(Number(monthSuccess) || 0, 0, 1),
        whfStartMinuteOfDay: clamp(Math.floor(Number(selectedWindow.startMinuteOfDay) || 0), 0, 1439),
        whfEndMinuteOfDay: clamp(Math.floor(Number(selectedWindow.endMinuteOfDay) || 0), 0, 1439)
      };
    }

    function getMonthReservePct(batteryConfig, monthIndex) {
      const monthly = Array.isArray(batteryConfig.monthlyReservePct) ? batteryConfig.monthlyReservePct : null;
      if (monthly && Number.isFinite(monthly[monthIndex])) {
        return clamp(monthly[monthIndex], 0, 0.95);
      }
      return clamp(Number(batteryConfig.minSocReservePct) || 0, 0, 0.95);
    }

    function computeMonthBills(monthInput) {
      const safeDays = Math.max(1, monthInput.days);
      const dayHomeLoadKwh = monthInput.homeLoadKwh / safeDays;
      const daySolarKwh = monthInput.solarKwh / safeDays;
      const dayEvKwh = (monthInput.evKwhMonth || 0) / safeDays;
      const evDayTargetKwh = dayEvKwh * monthInput.evDayChargingShare;
      const evNightTargetKwh = dayEvKwh * monthInput.evNightChargingShare;

      const dayResult = simulateRepresentativeDay({
        monthIndex: monthInput.monthIndex,
        dayHomeLoadKwh,
        daySolarKwh,
        peakShare: monthInput.peakShare,
        powerwallCount: monthInput.powerwallCount,
        usableKwhPerBattery: monthInput.usableKwhPerBattery,
        cyclesPerDay: monthInput.cyclesPerDay,
        solarToHomeEfficiency: monthInput.solarToHomeEfficiency,
        maxAcOutputKw: monthInput.maxAcOutputKw,
        roundTripEfficiency: monthInput.roundTripEfficiency,
        dispatchMode: monthInput.dispatchMode,
        minSocReservePct: monthInput.minSocReservePct,
        importOffPeakRate: monthInput.importOffPeak,
        importPeakRate: monthInput.importPeak,
        exportOffPeakRate: monthInput.exportOffPeak,
        exportPeakRate: monthInput.exportPeak,
        evEnabled: monthInput.evEnabled,
        evDayTargetKwh,
        evNightTargetKwh,
        haEnabled: monthInput.haEnabled,
        ha: monthInput.ha,
        haSuccessRate: monthInput.haSuccessRate,
        haPreCoolStartHour: monthInput.haPreCoolStartHour,
        haPreCoolEndHour: monthInput.haPreCoolEndHour,
        haMaxShiftHoursPerDay: monthInput.haMaxShiftHoursPerDay,
        haSummerSetpointF: monthInput.haSummerSetpointF,
        haWinterSetpointF: monthInput.haWinterSetpointF,
        haMaxPrecoolOffsetF: monthInput.haMaxPrecoolOffsetF,
        haMaxPreheatOffsetF: monthInput.haMaxPreheatOffsetF,
        whfEnabled: monthInput.whfEnabled,
        whfActiveMonth: monthInput.whfActiveMonth,
        whfFanWatts: monthInput.whfFanWatts,
        whfDisplacedAcWatts: monthInput.whfDisplacedAcWatts,
        whfSuccessRate: monthInput.whfSuccessRate,
        whfStartMinuteOfDay: monthInput.whfStartMinuteOfDay,
        whfEndMinuteOfDay: monthInput.whfEndMinuteOfDay,
        solarHourlyByMonth: monthInput.solarHourlyByMonth
      });

      const scale = safeDays;
      const beforeImportPeakKwh = dayResult.beforeImportPeakKwh * scale;
      const beforeImportOffKwh = dayResult.beforeImportOffKwh * scale;
      const importPeakKwh = dayResult.importPeakKwh * scale;
      const importOffKwh = dayResult.importOffKwh * scale;
      const exportPeakKwh = dayResult.exportPeakKwh * scale;
      const exportOffKwh = dayResult.exportOffKwh * scale;
      const exportKwh = exportPeakKwh + exportOffKwh;
      const importKwh = importPeakKwh + importOffKwh;
      const beforeImportKwh = beforeImportPeakKwh + beforeImportOffKwh;

      const exportCreditValue = (exportPeakKwh * monthInput.exportPeak) + (exportOffKwh * monthInput.exportOffPeak);

      const billBeforeEnergy = beforeImportPeakKwh * monthInput.importPeak + beforeImportOffKwh * monthInput.importOffPeak;
      const billBeforeNbc = beforeImportKwh * monthInput.nbcPerImportKwh;
      const billBefore = billBeforeEnergy + billBeforeNbc + monthInput.fixedMonthlyCharge;

      const billAfterEnergy = importPeakKwh * monthInput.importPeak + importOffKwh * monthInput.importOffPeak;
      const billAfterNbc = importKwh * monthInput.nbcPerImportKwh;
      const rawBillAfter = billAfterEnergy + billAfterNbc + monthInput.fixedMonthlyCharge - exportCreditValue;

      return {
        billBefore,
        rawBillAfter,
        billAfterEnergy,
        billAfterNbc,
        fixedCharge: monthInput.fixedMonthlyCharge,
        exportCreditValue,
        importKwh,
        importPeakKwh,
        importOffKwh,
        exportKwh,
        exportPeakKwh,
        exportOffKwh,
        beforeImportPeakKwh,
        beforeImportOffKwh,
        beforeImportKwh,
        directSolarToLoadKwh: dayResult.directSolarToLoad * scale,
        solarToBatteryInputKwh: dayResult.solarToBatteryInputKwh * scale,
        solarToBatteryStoredKwh: dayResult.solarToBatteryStoredKwh * scale,
        batteryToLoadKwh: dayResult.batteryToLoad * scale,
        batteryToGridExportKwh: dayResult.batteryToGridExportKwh * scale,
        batteryToLoadPeakKwh: dayResult.batteryToLoadPeakKwh * scale,
        batteryToLoadPostPeakKwh: dayResult.batteryToLoadPostPeakKwh * scale,
        batteryReserveHits: dayResult.batteryReserveHits * scale,
        minSocKwh: dayResult.minSocKwh,
        evDaySolarServedKwh: dayResult.evDaySolarServedKwh * scale,
        evDayShiftedToNightKwh: dayResult.evDayShiftedToNightKwh * scale,
        evNightLoadAfterKwh: dayResult.evNightLoadAfterKwh * scale,
        hvacShiftCapacityKwh: dayResult.hvacShiftCapacityKwh * scale,
        hvacShiftScheduledKwh: dayResult.hvacShiftScheduledKwh * scale,
        hvacShiftExecutedKwh: dayResult.hvacShiftExecutedKwh * scale,
        hvacShiftToPreWindowKwh: dayResult.hvacShiftToPreWindowKwh * scale,
        hvacShiftToPostPeakKwh: dayResult.hvacShiftToPostPeakKwh * scale,
        hvacPeakImportAvoidedKwh: dayResult.hvacPeakImportAvoidedKwh * scale,
        whfFanKwh: dayResult.whfFanKwh * scale,
        whfDisplacedAcKwh: dayResult.whfDisplacedAcKwh * scale,
        whfNetReductionKwh: dayResult.whfNetReductionKwh * scale,
        whfActiveHours: dayResult.whfActiveHours * scale,
        clippedSolarKwh: dayResult.clippedSolarKwh * scale,
        solarGenerationKwh: dayResult.solarGenerationKwh * scale
      };
    }

    function calculateAnnualEnergyAndBills(inputs, solarKw, powerwallCountOverride = inputs.sizing.powerwallCount, scaleOptions = null) {
      const solarScale = scaleOptions && Number.isFinite(scaleOptions.solarScale) ? Math.max(0, scaleOptions.solarScale) : 1;
      const batteryScale = scaleOptions && Number.isFinite(scaleOptions.batteryScale) ? Math.max(0, scaleOptions.batteryScale) : 1;
      const rateScale = scaleOptions && Number.isFinite(scaleOptions.rateScale) ? Math.max(0, scaleOptions.rateScale) : 1;
      let annualBefore = 0;
      let annualImportKwh = 0;
      let annualImportPeakKwh = 0;
      let annualImportOffKwh = 0;
      let annualExportKwh = 0;
      let annualExportPeakKwh = 0;
      let annualExportOffKwh = 0;
      let annualImportEnergyCostAfter = 0;
      let annualExportCreditValue = 0;
      let annualNbcAfter = 0;
      let annualFixedChargeTotal = 0;
      let annualBeforeImportPeakKwh = 0;
      let annualBeforeImportOffKwh = 0;
      let annualDirectSolarToLoadKwh = 0;
      let annualSolarToBatteryInputKwh = 0;
      let annualSolarToBatteryStoredKwh = 0;
      let annualBatteryToLoadKwh = 0;
      let annualBatteryToGridExportKwh = 0;
      let annualBatteryToLoadPeakKwh = 0;
      let annualBatteryToLoadPostPeakKwh = 0;
      let annualBatteryReserveHits = 0;
      let annualEvDaySolarServedKwh = 0;
      let annualEvDayShiftedToNightKwh = 0;
      let annualEvNightLoadAfterKwh = 0;
      let annualHvacShiftCapacityKwh = 0;
      let annualHvacShiftScheduledKwh = 0;
      let annualHvacShiftExecutedKwh = 0;
      let annualHvacPeakImportAvoidedKwh = 0;
      let annualHvacShiftToPreWindowKwh = 0;
      let annualHvacShiftToPostPeakKwh = 0;
      let annualSolarGenerationKwh = 0;
      let annualHomeLoadAdjustedKwh = 0;
      let annualMinSocKwh = Number.POSITIVE_INFINITY;
      let annualWhfFanKwh = 0;
      let annualWhfDisplacedAcKwh = 0;
      let annualWhfNetReductionKwh = 0;
      let annualWhfActiveHours = 0;
      let annualClippedSolarKwh = 0;
      const evKwhMonth = inputs.ev.enabled ? inputs.ev.kwhPerMonth : 0;
      const solarMonthlyProfile = isValidMonthlyProfile(inputs.production.solarMonthlyProfile) ? inputs.production.solarMonthlyProfile : SOLAR_PROFILE;
      const solarHourlyByMonth = isValidHourlyByMonth(inputs.production.solarHourlyByMonth) ? inputs.production.solarHourlyByMonth : null;
      const exportOffPeakRateBase = inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportOffPeak;
      const exportPeakRateBase = inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportPeak;
      const maxAcOutputKw = powerwallCountOverride >= 1 ? powerwallCountOverride * POWERWALL3_AC_KW : Number.POSITIVE_INFINITY;

      for (let month = 0; month < 12; month += 1) {
        const baseHomeLoadKwh = inputs.load.annualKwh * inputs.load.monthProfile[month];
        const homeLoadSeasonMultiplier = getSeasonLoadMultiplier(inputs.load, month);
        const homeLoadKwh = baseHomeLoadKwh * homeLoadSeasonMultiplier;
        const solarKwh = solarKw * inputs.production.annualYield * solarMonthlyProfile[month] * solarScale;
        const exportOffPeakRate = exportOffPeakRateBase * rateScale;
        const exportPeakRate = exportPeakRateBase * rateScale;
        const monthReservePct = getMonthReservePct(inputs.battery, month);
        const haMonthConfig = getHaMonthDispatchConfig(inputs.ha, month);
        const whfMonthConfig = getWhfMonthDispatchConfig(inputs.whf, month);

        const monthResult = computeMonthBills({
          monthIndex: month,
          homeLoadKwh,
          solarKwh,
          peakShare: inputs.load.peakShare,
          importOffPeak: inputs.rates.importOffPeak * rateScale,
          importPeak: inputs.rates.importPeak * rateScale,
          fixedMonthlyCharge: inputs.rates.fixedMonthlyCharge * rateScale,
          nbcPerImportKwh: inputs.rates.nbcPerImportKwh * rateScale,
          exportOffPeak: exportOffPeakRate,
          exportPeak: exportPeakRate,
          powerwallCount: powerwallCountOverride,
          usableKwhPerBattery: inputs.battery.usableKwhPerBattery * batteryScale,
          cyclesPerDay: inputs.battery.cyclesPerDay,
          solarToHomeEfficiency: inputs.production.solarToHomeEfficiency,
          maxAcOutputKw,
          roundTripEfficiency: inputs.battery.roundTripEfficiency,
          dispatchMode: inputs.battery.dispatchMode,
          minSocReservePct: monthReservePct,
          evEnabled: inputs.ev.enabled,
          evKwhMonth,
          evDayChargingShare: inputs.ev.dayChargingShare,
          evNightChargingShare: inputs.ev.nightChargingShare,
          haEnabled: inputs.ha.enabled,
          ha: inputs.ha,
          haSuccessRate: haMonthConfig.haSuccessRate,
          haPreCoolStartHour: haMonthConfig.haPreCoolStartHour,
          haPreCoolEndHour: haMonthConfig.haPreCoolEndHour,
          haMaxShiftHoursPerDay: haMonthConfig.haMaxShiftHoursPerDay,
          haSummerSetpointF: inputs.ha.summerSetpointF,
          haWinterSetpointF: inputs.ha.winterSetpointF,
          haMaxPrecoolOffsetF: inputs.ha.maxPrecoolOffsetF,
          haMaxPreheatOffsetF: inputs.ha.maxPreheatOffsetF,
          whfEnabled: inputs.whf.enabled,
          whfActiveMonth: whfMonthConfig.whfActiveMonth,
          whfFanWatts: inputs.whf.fanWatts,
          whfDisplacedAcWatts: inputs.whf.displacedAcWatts,
          whfSuccessRate: whfMonthConfig.whfSuccessRate,
          whfStartMinuteOfDay: whfMonthConfig.whfStartMinuteOfDay,
          whfEndMinuteOfDay: whfMonthConfig.whfEndMinuteOfDay,
          solarHourlyByMonth,
          days: DAYS_IN_MONTH[month]
        });

        annualBefore += monthResult.billBefore;
        annualImportEnergyCostAfter += monthResult.billAfterEnergy;
        annualExportCreditValue += monthResult.exportCreditValue;
        annualNbcAfter += monthResult.billAfterNbc;
        annualFixedChargeTotal += monthResult.fixedCharge;
        annualImportKwh += monthResult.importKwh;
        annualImportPeakKwh += monthResult.importPeakKwh;
        annualImportOffKwh += monthResult.importOffKwh;
        annualExportKwh += monthResult.exportKwh;
        annualExportPeakKwh += monthResult.exportPeakKwh;
        annualExportOffKwh += monthResult.exportOffKwh;
        annualBeforeImportPeakKwh += monthResult.beforeImportPeakKwh;
        annualBeforeImportOffKwh += monthResult.beforeImportOffKwh;
        annualDirectSolarToLoadKwh += monthResult.directSolarToLoadKwh;
        annualSolarToBatteryInputKwh += monthResult.solarToBatteryInputKwh;
        annualSolarToBatteryStoredKwh += monthResult.solarToBatteryStoredKwh;
        annualBatteryToLoadKwh += monthResult.batteryToLoadKwh;
        annualBatteryToGridExportKwh += monthResult.batteryToGridExportKwh;
        annualBatteryToLoadPeakKwh += monthResult.batteryToLoadPeakKwh;
        annualBatteryToLoadPostPeakKwh += monthResult.batteryToLoadPostPeakKwh;
        annualBatteryReserveHits += monthResult.batteryReserveHits;
        annualEvDaySolarServedKwh += monthResult.evDaySolarServedKwh;
        annualEvDayShiftedToNightKwh += monthResult.evDayShiftedToNightKwh;
        annualEvNightLoadAfterKwh += monthResult.evNightLoadAfterKwh;
        annualHvacShiftCapacityKwh += monthResult.hvacShiftCapacityKwh;
        annualHvacShiftScheduledKwh += monthResult.hvacShiftScheduledKwh;
        annualHvacShiftExecutedKwh += monthResult.hvacShiftExecutedKwh;
        annualHvacPeakImportAvoidedKwh += monthResult.hvacPeakImportAvoidedKwh;
        annualHvacShiftToPreWindowKwh += monthResult.hvacShiftToPreWindowKwh;
        annualHvacShiftToPostPeakKwh += monthResult.hvacShiftToPostPeakKwh;
        annualSolarGenerationKwh += monthResult.solarGenerationKwh;
        annualHomeLoadAdjustedKwh += homeLoadKwh;
        annualMinSocKwh = Math.min(annualMinSocKwh, monthResult.minSocKwh);
        annualWhfFanKwh += monthResult.whfFanKwh;
        annualWhfDisplacedAcKwh += monthResult.whfDisplacedAcKwh;
        annualWhfNetReductionKwh += monthResult.whfNetReductionKwh;
        annualWhfActiveHours += monthResult.whfActiveHours;
        annualClippedSolarKwh += monthResult.clippedSolarKwh;
      }

      const annualEnergyNetAfterTrueUp = Math.max(0, annualImportEnergyCostAfter - annualExportCreditValue);
      const annualVppCredit = inputs.vpp.enabled ? (powerwallCountOverride * POWERWALL3_AC_KW * VPP_CREDIT_PER_KW_YEAR) : 0;
      const annualAfterRaw = annualFixedChargeTotal + annualNbcAfter + annualEnergyNetAfterTrueUp - annualVppCredit;
      const annualTotalLoadAfterEvKwh = annualHomeLoadAdjustedKwh + (inputs.ev.enabled ? evKwhMonth * 12 : 0);
      const annualSolarPotentialKwh = annualSolarGenerationKwh + annualClippedSolarKwh;
      const annualClippedSolarPct = annualSolarPotentialKwh > 0 ? (annualClippedSolarKwh / annualSolarPotentialKwh) : 0;

      return {
        annualBefore,
        annualAfterRaw,
        annualSavings: annualBefore - annualAfterRaw,
        annualImportKwh,
        annualImportPeakKwh,
        annualImportOffKwh,
        annualExportKwh,
        annualExportPeakKwh,
        annualExportOffKwh,
        annualBeforeImportPeakKwh,
        annualBeforeImportOffKwh,
        annualDirectSolarToLoadKwh,
        annualSolarToBatteryInputKwh,
        annualSolarToBatteryStoredKwh,
        annualBatteryToLoadKwh,
        annualBatteryToGridExportKwh,
        annualBatteryToLoadPeakKwh,
        annualBatteryToLoadPostPeakKwh,
        annualBatteryReserveHits,
        annualMinSocKwh: Number.isFinite(annualMinSocKwh) ? annualMinSocKwh : 0,
        annualEvDaySolarServedKwh,
        annualEvDayShiftedToNightKwh,
        annualEvNightLoadAfterKwh,
        annualHvacShiftCapacityKwh,
        annualHvacShiftScheduledKwh,
        annualHvacShiftExecutedKwh,
        annualHvacPeakImportAvoidedKwh,
        annualHvacShiftToPreWindowKwh,
        annualHvacShiftToPostPeakKwh,
        annualSolarGenerationKwh,
        annualTotalLoadAfterEvKwh,
        annualHomeLoadAdjustedKwh,
        annualWhfFanKwh,
        annualWhfDisplacedAcKwh,
        annualWhfNetReductionKwh,
        annualWhfActiveHours,
        annualImportEnergyCostAfter,
        annualExportCreditValue,
        annualEnergyNetAfterTrueUp,
        annualNbcAfter,
        annualFixedChargeTotal,
        annualVppCredit,
        annualClippedSolarKwh,
        annualClippedSolarPct
      };
    }

    function calculateMortgagePayment(principal, apr, years) {
      if (principal <= 0) return 0;
      if (apr <= 0) return principal / (years * 12);
      const r = apr / 12;
      const n = years * 12;
      return principal * (r / (1 - Math.pow(1 + r, -n)));
    }

    function getBatteryCost(powerwallCount, pricing) {
      return pricing.batteryCosts[powerwallCount] ?? 0;
    }

    function buildNoControlsInputs(inputs) {
      return {
        ...inputs,
        ha: { ...inputs.ha, enabled: false },
        whf: { ...inputs.whf, enabled: false, activeMonths: [] }
      };
    }

    function calculateNoControlsAnnualBefore(inputs) {
      return calculateAnnualEnergyAndBills(buildNoControlsInputs(inputs), 0, 0).annualBefore;
    }

    function computeAnnualComparisonAtSize(inputs, solarKw, powerwallCountOverride, precomputedNoControlsAnnualBefore = null) {
      const annualConfigured = calculateAnnualEnergyAndBills(inputs, solarKw, powerwallCountOverride);
      const noControlsInputs = buildNoControlsInputs(inputs);
      const annualOff = inputs.ha.enabled
        ? calculateAnnualEnergyAndBills(noControlsInputs, solarKw, powerwallCountOverride)
        : null;

      let annualEffective = annualConfigured;
      let haGuardApplied = false;
      let haGuardPreventedAnnualCost = 0;
      if (annualOff && annualConfigured.annualAfterRaw > annualOff.annualAfterRaw + 0.01) {
        haGuardApplied = true;
        haGuardPreventedAnnualCost = annualConfigured.annualAfterRaw - annualOff.annualAfterRaw;
        annualEffective = annualOff;
      }

      const annualBeforeNoControls = annualOff
        ? annualOff.annualBefore
        : (Number.isFinite(precomputedNoControlsAnnualBefore) ? precomputedNoControlsAnnualBefore : calculateNoControlsAnnualBefore(inputs));

      return {
        annualConfigured,
        annualOff,
        annualEffective,
        annualBeforeNoControls,
        haGuardApplied,
        haGuardPreventedAnnualCost
      };
    }

    function evaluateScenario(inputs, solarKw, powerwallCountOverride = inputs.sizing.powerwallCount, options = null) {
      const precomputedNoControlsAnnualBefore = options && Number.isFinite(options.noControlsAnnualBefore)
        ? options.noControlsAnnualBefore
        : null;
      const comparison = computeAnnualComparisonAtSize(inputs, solarKw, powerwallCountOverride, precomputedNoControlsAnnualBefore);
      const annualConfigured = comparison.annualConfigured;
      const annualEffective = comparison.annualEffective;
      const pgeBeforeMonthly = annualEffective.annualBefore / 12;
      const pgeBaselineMonthlyNoControls = comparison.annualBeforeNoControls / 12;
      const pgeAfterMonthlyTrueUp = annualEffective.annualAfterRaw / 12;
      const utilityBillChangeMonthlySolarOnly = pgeAfterMonthlyTrueUp - pgeBeforeMonthly;
      const utilityBillChangeMonthlyWholeHome = pgeAfterMonthlyTrueUp - pgeBaselineMonthlyNoControls;
      const utilitySavingsMonthlyWholeHome = -utilityBillChangeMonthlyWholeHome;
      const utilitySavingsMonthly = annualEffective.annualSavings / 12;

      const systemCostGross = inputs.pricing.solarBaseCost + (inputs.pricing.solarCostPerKw * solarKw) + getBatteryCost(powerwallCountOverride, inputs.pricing);
      const financedPrincipal = systemCostGross;
      const mortgageMonthly = calculateMortgagePayment(financedPrincipal, inputs.financing.apr, inputs.financing.years);
      const totalMonthlyOutflow = mortgageMonthly + pgeAfterMonthlyTrueUp;

      return {
        idealSolarKw: solarKw,
        powerwallCount: powerwallCountOverride,
        pgeBeforeMonthly,
        pgeBaselineMonthlyNoControls,
        pgeAfterMonthlyTrueUp,
        utilityBillChangeMonthlySolarOnly,
        utilityBillChangeMonthlyWholeHome,
        utilitySavingsMonthlyWholeHome,
        utilitySavingsMonthly,
        financedPrincipal,
        mortgageMonthly,
        totalMonthlyOutflow,
        annualBefore: annualEffective.annualBefore,
        annualBeforeNoControls: comparison.annualBeforeNoControls,
        annualAfterRaw: annualEffective.annualAfterRaw,
        annualSavings: annualEffective.annualSavings,
        annualImportKwh: annualEffective.annualImportKwh,
        annualImportPeakKwh: annualEffective.annualImportPeakKwh,
        annualImportOffKwh: annualEffective.annualImportOffKwh,
        annualExportKwh: annualEffective.annualExportKwh,
        annualExportPeakKwh: annualEffective.annualExportPeakKwh,
        annualExportOffKwh: annualEffective.annualExportOffKwh,
        annualBeforeImportPeakKwh: annualEffective.annualBeforeImportPeakKwh,
        annualBeforeImportOffKwh: annualEffective.annualBeforeImportOffKwh,
        annualDirectSolarToLoadKwh: annualEffective.annualDirectSolarToLoadKwh,
        annualSolarToBatteryInputKwh: annualEffective.annualSolarToBatteryInputKwh,
        annualSolarToBatteryStoredKwh: annualEffective.annualSolarToBatteryStoredKwh,
        annualBatteryToLoadKwh: annualEffective.annualBatteryToLoadKwh,
        annualBatteryToGridExportKwh: annualEffective.annualBatteryToGridExportKwh,
        annualBatteryToLoadPeakKwh: annualEffective.annualBatteryToLoadPeakKwh,
        annualBatteryToLoadPostPeakKwh: annualEffective.annualBatteryToLoadPostPeakKwh,
        annualBatteryReserveHits: annualEffective.annualBatteryReserveHits,
        annualMinSocKwh: annualEffective.annualMinSocKwh,
        annualEvDaySolarServedKwh: annualEffective.annualEvDaySolarServedKwh,
        annualEvDayShiftedToNightKwh: annualEffective.annualEvDayShiftedToNightKwh,
        annualEvNightLoadAfterKwh: annualEffective.annualEvNightLoadAfterKwh,
        annualHvacShiftCapacityKwh: annualConfigured.annualHvacShiftCapacityKwh,
        annualHvacShiftScheduledKwh: annualConfigured.annualHvacShiftScheduledKwh,
        annualHvacShiftExecutedKwh: annualConfigured.annualHvacShiftExecutedKwh,
        annualHvacPeakImportAvoidedKwh: annualConfigured.annualHvacPeakImportAvoidedKwh,
        annualHvacShiftToPreWindowKwh: annualConfigured.annualHvacShiftToPreWindowKwh,
        annualHvacShiftToPostPeakKwh: annualConfigured.annualHvacShiftToPostPeakKwh,
        annualSolarGenerationKwh: annualEffective.annualSolarGenerationKwh,
        annualTotalLoadAfterEvKwh: annualEffective.annualTotalLoadAfterEvKwh,
        annualHomeLoadAdjustedKwh: annualEffective.annualHomeLoadAdjustedKwh,
        annualWhfFanKwh: annualEffective.annualWhfFanKwh,
        annualWhfDisplacedAcKwh: annualEffective.annualWhfDisplacedAcKwh,
        annualWhfNetReductionKwh: annualEffective.annualWhfNetReductionKwh,
        annualWhfActiveHours: annualEffective.annualWhfActiveHours,
        annualImportEnergyCostAfter: annualEffective.annualImportEnergyCostAfter,
        annualExportCreditValue: annualEffective.annualExportCreditValue,
        annualEnergyNetAfterTrueUp: annualEffective.annualEnergyNetAfterTrueUp,
        annualNbcAfter: annualEffective.annualNbcAfter,
        annualFixedChargeTotal: annualEffective.annualFixedChargeTotal,
        annualVppCredit: annualEffective.annualVppCredit,
        annualClippedSolarKwh: annualEffective.annualClippedSolarKwh,
        annualClippedSolarPct: annualEffective.annualClippedSolarPct,
        annualAfterRawConfigured: annualConfigured.annualAfterRaw,
        haGuardApplied: comparison.haGuardApplied,
        haGuardPreventedAnnualCost: comparison.haGuardPreventedAnnualCost,
        systemCostGross,
        npv: 0,
        paybackYears: Number.POSITIVE_INFINITY,
        projectionCumulative15: Number.NaN,
        selectionReason: "objective-min"
      };
    }

    function compareObjective(a, b, objectiveMode = "return_npv") {
      if (objectiveMode === "return_npv") {
        if (Math.abs(a.npv - b.npv) > 1e-9) {
          return b.npv - a.npv;
        }
        if (Math.abs(a.paybackYears - b.paybackYears) > 1e-9) {
          return a.paybackYears - b.paybackYears;
        }
        if (Math.abs(a.totalMonthlyOutflow - b.totalMonthlyOutflow) > 1e-9) {
          return a.totalMonthlyOutflow - b.totalMonthlyOutflow;
        }
      } else if (objectiveMode === "total_outflow") {
        if (Math.abs(a.totalMonthlyOutflow - b.totalMonthlyOutflow) > 1e-9) {
          return a.totalMonthlyOutflow - b.totalMonthlyOutflow;
        }
      } else {
        if (Math.abs(a.pgeAfterMonthlyTrueUp - b.pgeAfterMonthlyTrueUp) > 1e-9) {
          return a.pgeAfterMonthlyTrueUp - b.pgeAfterMonthlyTrueUp;
        }
        if (Math.abs(a.systemCostGross - b.systemCostGross) > 1e-9) {
          return a.systemCostGross - b.systemCostGross;
        }
      }
      if (Math.abs(a.financedPrincipal - b.financedPrincipal) > 1e-9) {
        return a.financedPrincipal - b.financedPrincipal;
      }
      if (a.powerwallCount !== b.powerwallCount) {
        return a.powerwallCount - b.powerwallCount;
      }
      return a.idealSolarKw - b.idealSolarKw;
    }

    function projectScenarioReturns(inputs, scenario) {
      const years = inputs.analysis.years;
      let npv = -scenario.systemCostGross;
      let cumulative = -scenario.systemCostGross;
      let paybackYears = Number.POSITIVE_INFINITY;
      const batteryFactor = scenario.powerwallCount > 0 ? (1 - inputs.analysis.batteryDegradation) : 1;
      const annualScale = (1 + inputs.analysis.utilityEscalation) * (1 - inputs.analysis.solarDegradation) * batteryFactor;
      const utilitySavingsAnnualBase = scenario.annualSavings - scenario.annualVppCredit;
      const vppSavingsAnnualBase = scenario.annualVppCredit;
      for (let year = 1; year <= years; year += 1) {
        const utilityScaled = utilitySavingsAnnualBase * Math.pow(annualScale, year - 1);
        const annualSavings = utilityScaled + vppSavingsAnnualBase;
        cumulative += annualSavings;
        npv += annualSavings / Math.pow(1 + inputs.analysis.discountRate, year);
        if (!Number.isFinite(paybackYears) && cumulative >= 0) {
          paybackYears = year;
        }
      }
      return {
        npv,
        paybackYears,
        projectionCumulative15: cumulative
      };
    }

    function buildParetoFrontier(results) {
      const sorted = [...results].sort((a, b) => {
        if (Math.abs(a.systemCostGross - b.systemCostGross) > 1e-9) {
          return a.systemCostGross - b.systemCostGross;
        }
        if (Math.abs(a.pgeAfterMonthlyTrueUp - b.pgeAfterMonthlyTrueUp) > 1e-9) {
          return a.pgeAfterMonthlyTrueUp - b.pgeAfterMonthlyTrueUp;
        }
        return compareObjective(a, b, "total_outflow");
      });
      const frontier = [];
      let bestBill = Number.POSITIVE_INFINITY;
      sorted.forEach((row) => {
        if (row.pgeAfterMonthlyTrueUp <= bestBill + 1e-9) {
          frontier.push(row);
          bestBill = Math.min(bestBill, row.pgeAfterMonthlyTrueUp);
        }
      });
      return frontier;
    }

    function pointLineDistance(px, py, ax, ay, bx, by) {
      const vx = bx - ax;
      const vy = by - ay;
      const wx = px - ax;
      const wy = py - ay;
      const denom = Math.sqrt((vx * vx) + (vy * vy));
      if (denom <= 1e-12) return 0;
      return Math.abs((vx * wy) - (vy * wx)) / denom;
    }

    function selectParetoKnee(frontier) {
      if (!frontier.length) return null;
      if (frontier.length < 3) {
        return [...frontier].sort((a, b) => compareObjective(a, b, "utility_bill_knee"))[0];
      }
      const minCost = Math.min(...frontier.map((row) => row.systemCostGross));
      const maxCost = Math.max(...frontier.map((row) => row.systemCostGross));
      const minBill = Math.min(...frontier.map((row) => row.pgeAfterMonthlyTrueUp));
      const maxBill = Math.max(...frontier.map((row) => row.pgeAfterMonthlyTrueUp));
      const costSpan = Math.max(1e-9, maxCost - minCost);
      const billSpan = Math.max(1e-9, maxBill - minBill);
      const normalizeX = (row) => (row.systemCostGross - minCost) / costSpan;
      const normalizeY = (row) => (row.pgeAfterMonthlyTrueUp - minBill) / billSpan;
      const first = frontier[0];
      const last = frontier[frontier.length - 1];
      const ax = normalizeX(first);
      const ay = normalizeY(first);
      const bx = normalizeX(last);
      const by = normalizeY(last);
      let best = first;
      let bestDist = -1;
      frontier.forEach((row) => {
        const dist = pointLineDistance(normalizeX(row), normalizeY(row), ax, ay, bx, by);
        if (dist > bestDist + 1e-9) {
          bestDist = dist;
          best = row;
        } else if (Math.abs(dist - bestDist) <= 1e-9 && compareObjective(row, best, "utility_bill_knee") < 0) {
          best = row;
        }
      });
      return best;
    }

    function optimizeIdealScenario(inputs) {
      const solarCandidates = buildSolarCandidates(
        inputs.sizing.solarSearchMinKw,
        inputs.sizing.solarSearchMaxKw,
        inputs.sizing.solarSearchStepKw
      );
      const batteryCandidates = inputs.sizing.lockPowerwallCount
        ? [inputs.sizing.powerwallCount]
        : [0, 1, 2, 3, 4];
      if (!solarCandidates.length) {
        return { error: "No valid solar candidates generated from min/max/step.", best: null, solarCandidates: [], batteryCandidates, candidates: [], results: [], paretoFrontier: [] };
      }

      const noControlsAnnualBefore = calculateNoControlsAnnualBefore(inputs);
      const rawResults = [];
      batteryCandidates.forEach((powerwallCount) => {
        solarCandidates.forEach((solarKw) => {
          const scenario = evaluateScenario(inputs, solarKw, powerwallCount, { noControlsAnnualBefore });
          const returns = projectScenarioReturns(inputs, scenario);
          rawResults.push({
            ...scenario,
            npv: returns.npv,
            paybackYears: returns.paybackYears,
            projectionCumulative15: returns.projectionCumulative15,
            selectionReason: "objective-min"
          });
        });
      });

      const objectiveMode = inputs.sizing.objectiveMode || "return_npv";
      const paretoFrontier = buildParetoFrontier(rawResults);
      const sorted = [...rawResults].sort((a, b) => compareObjective(a, b, objectiveMode));
      let best = sorted[0];
      if (objectiveMode === "utility_bill_knee") {
        const knee = selectParetoKnee(paretoFrontier);
        if (knee) {
          best = { ...knee, selectionReason: "pareto-knee" };
        }
      }
      if (best.selectionReason !== "pareto-knee") {
        best = { ...best, selectionReason: "objective-min" };
      }
      return {
        error: null,
        best,
        solarCandidates,
        batteryCandidates,
        candidates: solarCandidates,
        results: sorted,
        paretoFrontier
      };
    }

    function annualMortgageForYear(year, mortgageMonthly, financeYears) {
      return year <= financeYears ? mortgageMonthly * 12 : 0;
    }

    function runModelChecks(inputs, best, optimization) {
      const checks = [];
      const eps = 1e-6;
      const objectiveMode = inputs.sizing.objectiveMode || "return_npv";
      const expectedRows = optimization.solarCandidates.length * optimization.batteryCandidates.length;
      checks.push({
        name: "Grid sweep count matches solar candidates x battery candidates",
        ok: optimization.results.length === expectedRows
      });

      checks.push({
        name: "Loan mortgage flow is zero after loan term",
        ok: Math.abs(annualMortgageForYear(inputs.financing.years + 1, best.mortgageMonthly, inputs.financing.years)) < eps
      });
      checks.push({
        name: "Financed principal is non-negative",
        ok: best.financedPrincipal >= -eps
      });
      checks.push({
        name: "Mortgage monthly payment is non-negative",
        ok: best.mortgageMonthly >= -eps
      });
      checks.push({
        name: "Annual import equals peak + off-peak import",
        ok: Math.abs(best.annualImportKwh - (best.annualImportPeakKwh + best.annualImportOffKwh)) < 0.01
      });
      checks.push({
        name: "Annual export equals peak + off-peak export",
        ok: Math.abs(best.annualExportKwh - (best.annualExportPeakKwh + best.annualExportOffKwh)) < 0.01
      });
      checks.push({
        name: "Same-load identity: PG&E before - after equals utility savings (monthly tolerance)",
        ok: Math.abs((best.pgeBeforeMonthly - best.pgeAfterMonthlyTrueUp) - best.utilitySavingsMonthly) < 0.01
      });
      checks.push({
        name: "Whole-home identity: baseline - after equals whole-home utility savings (monthly tolerance)",
        ok: Math.abs((best.pgeBaselineMonthlyNoControls - best.pgeAfterMonthlyTrueUp) - best.utilitySavingsMonthlyWholeHome) < 0.01
      });
      checks.push({
        name: "Annual energy true-up is floored at zero",
        ok: Math.abs(best.annualEnergyNetAfterTrueUp - Math.max(0, best.annualImportEnergyCostAfter - best.annualExportCreditValue)) < 0.01
      });
      checks.push({
        name: "Annual after-bill matches fixed + NBC + energy net - VPP (unclamped)",
        ok: Math.abs(best.annualAfterRaw - (best.annualFixedChargeTotal + best.annualNbcAfter + best.annualEnergyNetAfterTrueUp - best.annualVppCredit)) < 0.01
      });
      checks.push({
        name: "Savings identity holds even when annual bill is negative",
        ok: Math.abs(best.annualSavings - (best.annualBefore - best.annualAfterRaw)) < 0.01
      });

      const recomputedBest = [...optimization.results].sort((a, b) => compareObjective(a, b, objectiveMode))[0];
      if (objectiveMode === "utility_bill_knee") {
        const frontierKeys = new Set(optimization.paretoFrontier.map((row) => scenarioKey(row.idealSolarKw, row.powerwallCount)));
        checks.push({
          name: "Utility-bill knee selection is on Pareto frontier",
          ok: frontierKeys.has(scenarioKey(best.idealSolarKw, best.powerwallCount))
        });
      } else {
        checks.push({
          name: "Objective selector consistency (selected scenario matches configured objective)",
          ok: scenarioKey(recomputedBest.idealSolarKw, recomputedBest.powerwallCount) === scenarioKey(best.idealSolarKw, best.powerwallCount)
        });
      }

      checks.push({
        name: "Return metrics shape: finite NPV and valid payback field",
        ok: Number.isFinite(best.npv) && (Number.isFinite(best.paybackYears) || best.paybackYears === Number.POSITIVE_INFINITY)
      });

      checks.push({
        name: "WHF net reduction is non-negative",
        ok: best.annualWhfNetReductionKwh >= -eps
      });
      const vppOffInputs = {
        ...inputs,
        vpp: { enabled: false }
      };
      const vppOffScenario = evaluateScenario(vppOffInputs, best.idealSolarKw, best.powerwallCount, { noControlsAnnualBefore: calculateNoControlsAnnualBefore(vppOffInputs) });
      checks.push({
        name: "VPP ON/OFF annual bill delta equals modeled VPP credit",
        ok: Math.abs((vppOffScenario.annualAfterRaw - best.annualAfterRaw) - best.annualVppCredit) < 0.01
      });

      const whfOnInputs = {
        ...inputs,
        whf: {
          ...inputs.whf,
          enabled: true,
          mode: "manual",
          activeMonths: inputs.whf.activeMonths.length ? inputs.whf.activeMonths : [4, 5, 6, 7, 8],
          fanWatts: inputs.whf.fanWatts > 0 ? inputs.whf.fanWatts : 200,
          displacedAcWatts: inputs.whf.displacedAcWatts > 0 ? inputs.whf.displacedAcWatts : 3500,
          successRate: inputs.whf.successRate > 0 ? inputs.whf.successRate : 0.85,
          startMinuteOfDay: inputs.whf.startMinuteOfDay || ((20 * 60) + 30),
          endMinuteOfDay: inputs.whf.endMinuteOfDay || (6 * 60)
        }
      };
      const whfOffInputs = {
        ...inputs,
        whf: { ...inputs.whf, enabled: false, activeMonths: [] }
      };
      const noControlsAnnualBefore = calculateNoControlsAnnualBefore(inputs);
      const whfOnScenario = evaluateScenario(whfOnInputs, best.idealSolarKw, best.powerwallCount, { noControlsAnnualBefore });
      const whfOffScenario = evaluateScenario(whfOffInputs, best.idealSolarKw, best.powerwallCount, { noControlsAnnualBefore });
      checks.push({
        name: "WHF ON reduces annual import at fixed solar and battery",
        ok: whfOnScenario.annualImportKwh <= whfOffScenario.annualImportKwh + 0.01
      });
      checks.push({
        name: "WHF ON does not increase PG&E after monthly bill at fixed solar and battery",
        ok: whfOnScenario.pgeAfterMonthlyTrueUp <= whfOffScenario.pgeAfterMonthlyTrueUp + 0.01
      });
      checks.push({
        name: "WHF ON does not reduce whole-home monthly savings at fixed solar and battery",
        ok: whfOnScenario.utilitySavingsMonthlyWholeHome >= whfOffScenario.utilitySavingsMonthlyWholeHome - 0.01
      });
      const whfFloorProbe = simulateRepresentativeDay({
        monthIndex: 6,
        dayHomeLoadKwh: 18,
        daySolarKwh: 0,
        peakShare: inputs.load.peakShare,
        powerwallCount: 0,
        usableKwhPerBattery: BATTERY_USABLE_KWH,
        cyclesPerDay: 0,
        solarToHomeEfficiency: inputs.production.solarToHomeEfficiency,
        maxAcOutputKw: Number.POSITIVE_INFINITY,
        roundTripEfficiency: 0.9,
        dispatchMode: inputs.battery.dispatchMode,
        minSocReservePct: getMonthReservePct(inputs.battery, 6),
        importOffPeakRate: inputs.rates.importOffPeak,
        importPeakRate: inputs.rates.importPeak,
        exportOffPeakRate: inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportOffPeak,
        exportPeakRate: inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportPeak,
        evEnabled: false,
        evDayTargetKwh: 0,
        evNightTargetKwh: 0,
        haEnabled: false,
        ha: { ...inputs.ha, enabled: false },
        haSuccessRate: 0,
        haPreCoolStartHour: 12,
        haPreCoolEndHour: 16,
        haMaxShiftHoursPerDay: 4,
        haSummerSetpointF: inputs.load.summerSetpointF,
        haWinterSetpointF: inputs.load.winterSetpointF,
        haMaxPrecoolOffsetF: 0,
        haMaxPreheatOffsetF: 0,
        whfEnabled: true,
        whfActiveMonth: true,
        whfFanWatts: 200,
        whfDisplacedAcWatts: 3500,
        whfSuccessRate: 0.85,
        whfStartMinuteOfDay: (20 * 60) + 30,
        whfEndMinuteOfDay: 6 * 60
      });
      checks.push({
        name: "WHF never drives hourly home load negative",
        ok: whfFloorProbe.minHomeLoadKwh >= -1e-9
      });

      const dispatchProbe = simulateRepresentativeDay({
        monthIndex: 6,
        dayHomeLoadKwh: 30,
        daySolarKwh: 72,
        peakShare: inputs.load.peakShare,
        powerwallCount: Math.max(1, best.powerwallCount),
        usableKwhPerBattery: BATTERY_USABLE_KWH,
        cyclesPerDay: Math.max(0.8, inputs.battery.cyclesPerDay),
        solarToHomeEfficiency: inputs.production.solarToHomeEfficiency,
        maxAcOutputKw: Math.max(1, best.powerwallCount) * POWERWALL3_AC_KW,
        roundTripEfficiency: inputs.battery.roundTripEfficiency,
        dispatchMode: inputs.battery.dispatchMode,
        minSocReservePct: getMonthReservePct(inputs.battery, 6),
        importOffPeakRate: inputs.rates.importOffPeak,
        importPeakRate: inputs.rates.importPeak,
        exportOffPeakRate: inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportOffPeak,
        exportPeakRate: inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportPeak,
        evEnabled: false,
        evDayTargetKwh: 0,
        evNightTargetKwh: 0,
        haEnabled: false,
        ha: { ...inputs.ha, enabled: false },
        haSuccessRate: 0,
        haPreCoolStartHour: 12,
        haPreCoolEndHour: 16,
        haMaxShiftHoursPerDay: 4,
        haSummerSetpointF: inputs.load.summerSetpointF,
        haWinterSetpointF: inputs.load.winterSetpointF,
        haMaxPrecoolOffsetF: 0,
        haMaxPreheatOffsetF: 0,
        whfEnabled: false,
        whfActiveMonth: false,
        whfFanWatts: 0,
        whfDisplacedAcWatts: 0,
        whfSuccessRate: 0,
        whfStartMinuteOfDay: 0,
        whfEndMinuteOfDay: 0
      });
      const probeBatteryCapacity = Math.max(1, best.powerwallCount) * BATTERY_USABLE_KWH;
      const probeReservePct = getMonthReservePct(inputs.battery, 6);
      const probeMinSoc = probeBatteryCapacity * probeReservePct;
      checks.push({
        name: "Dispatch check: battery discharges during economical periods",
        ok: (dispatchProbe.batteryToLoadPeakKwh + dispatchProbe.batteryToGridExportKwh) > 0.01
      });
      checks.push({
        name: "Dispatch check: reserve floor respected for active month policy",
        ok: dispatchProbe.minSocKwh >= probeMinSoc - 0.001
      });
      const arbitragePositiveProbe = simulateRepresentativeDay({
        monthIndex: 6,
        dayHomeLoadKwh: 22,
        daySolarKwh: 95,
        peakShare: inputs.load.peakShare,
        powerwallCount: Math.max(1, best.powerwallCount),
        usableKwhPerBattery: BATTERY_USABLE_KWH,
        cyclesPerDay: Math.max(1, inputs.battery.cyclesPerDay),
        solarToHomeEfficiency: inputs.production.solarToHomeEfficiency,
        maxAcOutputKw: Math.max(1, best.powerwallCount) * POWERWALL3_AC_KW,
        roundTripEfficiency: inputs.battery.roundTripEfficiency,
        dispatchMode: "arbitrage_price_event",
        minSocReservePct: getMonthReservePct(inputs.battery, 6),
        importOffPeakRate: 0.30,
        importPeakRate: 0.35,
        exportOffPeakRate: 0.05,
        exportPeakRate: 0.60,
        evEnabled: false,
        evDayTargetKwh: 0,
        evNightTargetKwh: 0,
        haEnabled: false,
        ha: { ...inputs.ha, enabled: false },
        haSuccessRate: 0,
        haPreCoolStartHour: 12,
        haPreCoolEndHour: 16,
        haMaxShiftHoursPerDay: 4,
        haSummerSetpointF: inputs.load.summerSetpointF,
        haWinterSetpointF: inputs.load.winterSetpointF,
        haMaxPrecoolOffsetF: 0,
        haMaxPreheatOffsetF: 0,
        whfEnabled: false,
        whfActiveMonth: false,
        whfFanWatts: 0,
        whfDisplacedAcWatts: 0,
        whfSuccessRate: 0,
        whfStartMinuteOfDay: 0,
        whfEndMinuteOfDay: 0
      });
      const arbitrageBlockedProbe = simulateRepresentativeDay({
        monthIndex: 6,
        dayHomeLoadKwh: 22,
        daySolarKwh: 95,
        peakShare: inputs.load.peakShare,
        powerwallCount: Math.max(1, best.powerwallCount),
        usableKwhPerBattery: BATTERY_USABLE_KWH,
        cyclesPerDay: Math.max(1, inputs.battery.cyclesPerDay),
        solarToHomeEfficiency: inputs.production.solarToHomeEfficiency,
        maxAcOutputKw: Math.max(1, best.powerwallCount) * POWERWALL3_AC_KW,
        roundTripEfficiency: inputs.battery.roundTripEfficiency,
        dispatchMode: "arbitrage_price_event",
        minSocReservePct: getMonthReservePct(inputs.battery, 6),
        importOffPeakRate: 0.30,
        importPeakRate: 0.35,
        exportOffPeakRate: 0.10,
        exportPeakRate: 0.30,
        evEnabled: false,
        evDayTargetKwh: 0,
        evNightTargetKwh: 0,
        haEnabled: false,
        ha: { ...inputs.ha, enabled: false },
        haSuccessRate: 0,
        haPreCoolStartHour: 12,
        haPreCoolEndHour: 16,
        haMaxShiftHoursPerDay: 4,
        haSummerSetpointF: inputs.load.summerSetpointF,
        haWinterSetpointF: inputs.load.winterSetpointF,
        haMaxPrecoolOffsetF: 0,
        haMaxPreheatOffsetF: 0,
        whfEnabled: false,
        whfActiveMonth: false,
        whfFanWatts: 0,
        whfDisplacedAcWatts: 0,
        whfSuccessRate: 0,
        whfStartMinuteOfDay: 0,
        whfEndMinuteOfDay: 0
      });
      checks.push({
        name: "Arbitrage mode can export battery energy when export > import",
        ok: arbitragePositiveProbe.batteryToGridExportKwh > 0.01
      });
      checks.push({
        name: "Arbitrage mode blocks battery export when export <= import",
        ok: arbitrageBlockedProbe.batteryToGridExportKwh <= 0.01
      });
      const clipProbeNoPw = simulateRepresentativeDay({
        monthIndex: 6,
        dayHomeLoadKwh: 15,
        daySolarKwh: 200,
        peakShare: inputs.load.peakShare,
        powerwallCount: 0,
        usableKwhPerBattery: BATTERY_USABLE_KWH,
        cyclesPerDay: 0,
        solarToHomeEfficiency: inputs.production.solarToHomeEfficiency,
        maxAcOutputKw: Number.POSITIVE_INFINITY,
        roundTripEfficiency: 0.9,
        dispatchMode: inputs.battery.dispatchMode,
        minSocReservePct: getMonthReservePct(inputs.battery, 6),
        importOffPeakRate: inputs.rates.importOffPeak,
        importPeakRate: inputs.rates.importPeak,
        exportOffPeakRate: inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportOffPeak,
        exportPeakRate: inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportPeak,
        evEnabled: false,
        evDayTargetKwh: 0,
        evNightTargetKwh: 0,
        haEnabled: false,
        ha: { ...inputs.ha, enabled: false },
        haSuccessRate: 0,
        haPreCoolStartHour: 12,
        haPreCoolEndHour: 16,
        haMaxShiftHoursPerDay: 4,
        haSummerSetpointF: inputs.load.summerSetpointF,
        haWinterSetpointF: inputs.load.winterSetpointF,
        haMaxPrecoolOffsetF: 0,
        haMaxPreheatOffsetF: 0,
        whfEnabled: false,
        whfActiveMonth: false,
        whfFanWatts: 0,
        whfDisplacedAcWatts: 0,
        whfSuccessRate: 0,
        whfStartMinuteOfDay: 0,
        whfEndMinuteOfDay: 0
      });
      const clipProbePw1 = simulateRepresentativeDay({
        monthIndex: 6,
        dayHomeLoadKwh: 15,
        daySolarKwh: 200,
        peakShare: inputs.load.peakShare,
        powerwallCount: 1,
        usableKwhPerBattery: BATTERY_USABLE_KWH,
        cyclesPerDay: 0.8,
        solarToHomeEfficiency: inputs.production.solarToHomeEfficiency,
        maxAcOutputKw: POWERWALL3_AC_KW,
        roundTripEfficiency: 0.9,
        dispatchMode: inputs.battery.dispatchMode,
        minSocReservePct: getMonthReservePct(inputs.battery, 6),
        importOffPeakRate: inputs.rates.importOffPeak,
        importPeakRate: inputs.rates.importPeak,
        exportOffPeakRate: inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportOffPeak,
        exportPeakRate: inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportPeak,
        evEnabled: false,
        evDayTargetKwh: 0,
        evNightTargetKwh: 0,
        haEnabled: false,
        ha: { ...inputs.ha, enabled: false },
        haSuccessRate: 0,
        haPreCoolStartHour: 12,
        haPreCoolEndHour: 16,
        haMaxShiftHoursPerDay: 4,
        haSummerSetpointF: inputs.load.summerSetpointF,
        haWinterSetpointF: inputs.load.winterSetpointF,
        haMaxPrecoolOffsetF: 0,
        haMaxPreheatOffsetF: 0,
        whfEnabled: false,
        whfActiveMonth: false,
        whfFanWatts: 0,
        whfDisplacedAcWatts: 0,
        whfSuccessRate: 0,
        whfStartMinuteOfDay: 0,
        whfEndMinuteOfDay: 0
      });
      checks.push({
        name: "Clipping disabled when Powerwalls = 0",
        ok: clipProbeNoPw.clippedSolarKwh <= 1e-6
      });
      checks.push({
        name: "Clipping appears when Powerwalls >= 1 under oversized solar",
        ok: clipProbePw1.clippedSolarKwh > 0.01
      });

      const passCount = checks.filter((c) => c.ok).length;
      const rows = [];
      rows.push("<div class='check-row'>Passing: <strong>" + passCount + "/" + checks.length + "</strong></div>");
      checks.forEach((check) => {
        rows.push(
          "<div class='check-row'><span class='" + (check.ok ? "check-ok" : "check-warn") + "'>" +
          (check.ok ? "OK" : "WARN") + "</span> " + check.name + "</div>"
        );
      });
      el.checksOutput.innerHTML = rows.join("");
    }

    function runRegressionProbe(inputs, bestV2) {
      const objectiveMode = inputs.sizing.objectiveMode || "return_npv";
      if (objectiveMode === "return_npv") {
        el.regressionOutput.textContent = "Regression probe skipped in NPV mode to keep interactivity fast. Switch objective to outflow or utility knee-point for v1/v2 comparison.";
        return;
      }
      const moduleGridCandidates = buildSolarCandidates(inputs.sizing.solarSearchMinKw, inputs.sizing.solarSearchMaxKw, MODULE_KW);
      if (!moduleGridCandidates.length) {
        el.regressionOutput.textContent = "Regression probe unavailable: no v1-like module-grid candidates in this search range.";
        return;
      }

      const moduleGridScenarios = [];
      const probeBatteryCandidates = inputs.sizing.lockPowerwallCount
        ? [inputs.sizing.powerwallCount]
        : [0, 1, 2, 3, 4];
      probeBatteryCandidates.forEach((pw) => {
        moduleGridCandidates.forEach((kw) => {
          moduleGridScenarios.push(evaluateScenario(inputs, kw, pw));
        });
      });
      const bestModuleGridByV2 = [...moduleGridScenarios].sort((a, b) => compareObjective(a, b, objectiveMode))[0];
      const bestV1Like = [...moduleGridScenarios].sort((a, b) => {
        const v1LikeA = (a.mortgageMonthly - a.utilitySavingsMonthly) + (a.financedPrincipal * V1_LIKE_OPPORTUNITY_RATE / 12);
        const v1LikeB = (b.mortgageMonthly - b.utilitySavingsMonthly) + (b.financedPrincipal * V1_LIKE_OPPORTUNITY_RATE / 12);
        if (Math.abs(v1LikeA - v1LikeB) > 1e-9) return v1LikeA - v1LikeB;
        if (Math.abs(a.financedPrincipal - b.financedPrincipal) > 1e-9) return a.financedPrincipal - b.financedPrincipal;
        return a.idealSolarKw - b.idealSolarKw;
      })[0];

      const gridDeltaKw = bestV2.idealSolarKw - bestModuleGridByV2.idealSolarKw;
      const objectiveDeltaKw = bestV2.idealSolarKw - bestV1Like.idealSolarKw;
      const gridDeltaPw = bestV2.powerwallCount - bestModuleGridByV2.powerwallCount;
      const objectiveDeltaPw = bestV2.powerwallCount - bestV1Like.powerwallCount;
      const julReservePct = getMonthReservePct(inputs.battery, 6);

      const lines = [];
      lines.push("Shared baseline probe:");
      lines.push("Objective mode: " + objectiveLabel(objectiveMode) + ".");
      lines.push("Dispatch mode: " + inputs.battery.dispatchMode + " with reserve policy " + inputs.battery.reservePolicy + " (Jul reserve " + fmt(julReservePct * 100, 0) + "%).");
      lines.push("v2 continuous-step best: " + fmt(bestV2.idealSolarKw, 3) + " kW / " + bestV2.powerwallCount + " PW.");
      lines.push("Module-grid (0.395 kW step) best: " + fmt(bestModuleGridByV2.idealSolarKw, 3) + " kW / " + bestModuleGridByV2.powerwallCount + " PW.");
      lines.push("v1-like objective best (includes 5% opportunity term): " + fmt(bestV1Like.idealSolarKw, 3) + " kW / " + bestV1Like.powerwallCount + " PW.");
      lines.push("Expected differences: kW grid representation delta " + fmt(gridDeltaKw, 3) + " kW and " + gridDeltaPw + " PW; objective delta " + fmt(objectiveDeltaKw, 3) + " kW and " + objectiveDeltaPw + " PW.");
      el.regressionOutput.textContent = lines.join(" ");
    }

    function renderResultCards(result, inputs) {
      const objectiveMode = inputs.sizing.objectiveMode || "return_npv";
      const utilityBillChangeMonthly = result.utilityBillChangeMonthlyWholeHome;
      const utilityBillChangeMonthlySolarOnly = result.utilityBillChangeMonthlySolarOnly;
      const mortgageChangeMonthly = result.mortgageMonthly;
      const netPaymentChangeMonthly = utilityBillChangeMonthly + mortgageChangeMonthly;

      el.cardIdealSolarKw.textContent = fmt(result.idealSolarKw, 3) + " kW";
      el.cardPowerwallChoice.textContent = "Powerwalls: " + result.powerwallCount;
      el.cardPgeBefore.textContent = usdPrecise(result.pgeBaselineMonthlyNoControls);
      el.cardPgeAfter.textContent = usdPrecise(result.pgeAfterMonthlyTrueUp);
      el.cardTrueUpNote.textContent = "Annual true-up bill: " + usdPrecise(result.annualAfterRaw) + " | Energy net: " + usdPrecise(result.annualEnergyNetAfterTrueUp) + " | VPP: " + usdPrecise(result.annualVppCredit) + " | Battery->Grid: " + fmt(result.annualBatteryToGridExportKwh, 0) + " kWh/yr";
      el.cardClippedSolar.textContent = fmt(result.annualClippedSolarKwh, 0) + " kWh/yr";
      el.cardClippedSolarNote.textContent = "Clipped share: " + fmt(result.annualClippedSolarPct * 100, 1) + "% (PW3 cap " + fmt(POWERWALL3_AC_KW, 1) + " kW/PW)";
      renderDelta(el.cardSavings, utilityBillChangeMonthly);
      el.cardUtilityChangeFormula.textContent = "(PG&E After) - (PG&E Baseline No WHF/HA) = " + usdSigned(utilityBillChangeMonthly);
      el.cardSolarOnlyDelta.textContent = "Solar-only delta (same-load baseline): " + usdSigned(utilityBillChangeMonthlySolarOnly);
      el.cardFinanced.textContent = usd(result.financedPrincipal);
      el.cardFinancedNote.textContent = "Gross system cost: " + usd(result.systemCostGross) + " | NPV: " + usdPrecise(result.npv) + " | Payback: " + formatPaybackYears(result.paybackYears, inputs.analysis.years);
      renderDelta(el.cardMortgage, mortgageChangeMonthly);
      el.cardOutflow.textContent = "Total outflow/mo: " + usdPrecise(result.totalMonthlyOutflow);
      renderDelta(el.cardNetPaymentChange, netPaymentChangeMonthly);
      el.cardNetPaymentFormula.textContent = "(Primary Utility Bill Change / Month) + (Mortgage / Month) = " + usdSigned(netPaymentChangeMonthly);
      if (result.haGuardApplied) {
        el.cardTrueUpNote.textContent += " | HVAC guard applied (prevented " + usdPrecise(result.haGuardPreventedAnnualCost) + "/yr).";
      }
      const reasonText = result.selectionReason === "pareto-knee"
        ? "Selection reason: Pareto knee point."
        : (result.selectionReason === "user-selected"
          ? "Selection reason: user override."
          : (result.selectionReason === "preferred-powerwall"
            ? "Selection reason: best scenario within selected Powerwall count."
            : "Selection reason: objective minimum."));
      el.objectiveSummary.innerHTML = "Ideal size is selected by <strong>" + objectiveFormula(objectiveMode) + "</strong>. " + reasonText;
    }

    function renderScenarioMatrix(optimization, selectedScenario, inputs) {
      const table = el.scenarioMatrixTable;
      const objectiveMode = inputs.sizing.objectiveMode || "return_npv";
      table.innerHTML = "";
      const byKey = new Map();
      optimization.results.forEach((row) => {
        byKey.set(scenarioKey(row.idealSolarKw, row.powerwallCount), row);
      });

      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      headerRow.innerHTML = "<th>Solar kW</th>" + optimization.batteryCandidates.map((pw) => "<th>" + pw + " PW</th>").join("");
      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      optimization.solarCandidates.forEach((solarKw) => {
        const tr = document.createElement("tr");
        const label = document.createElement("td");
        label.textContent = fmt(solarKw, 3);
        tr.appendChild(label);
        optimization.batteryCandidates.forEach((pw) => {
          const td = document.createElement("td");
          td.className = "matrix-cell";
          const row = byKey.get(scenarioKey(solarKw, pw));
          if (!row) {
            td.textContent = "--";
          } else {
            td.innerHTML = "<div>" + usdPrecise(row.npv) + "</div><div class='sub'>" + formatPaybackYears(row.paybackYears, inputs.analysis.years) + "</div>";
            if (scenarioKey(row.idealSolarKw, row.powerwallCount) === scenarioKey(selectedScenario.idealSolarKw, selectedScenario.powerwallCount)) {
              td.classList.add("matrix-cell-selected");
            }
            td.addEventListener("click", () => {
              selectedScenarioKey = scenarioKey(row.idealSolarKw, row.powerwallCount);
              render();
            });
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      el.scenarioMatrixNote.textContent = "Matrix values show NPV with payback subtext. Objective: " + objectiveLabel(objectiveMode) + ".";
    }

    function renderTopScenarios(optimization, selectedScenario, inputs) {
      const rows = optimization.results.slice(0, 10);
      el.topScenariosBody.innerHTML = "";
      rows.forEach((row, idx) => {
        const tr = document.createElement("tr");
        if (scenarioKey(row.idealSolarKw, row.powerwallCount) === scenarioKey(selectedScenario.idealSolarKw, selectedScenario.powerwallCount)) {
          tr.className = "row-selected";
        }
        tr.innerHTML = [
          "<td>" + (idx + 1) + "</td>",
          "<td>" + fmt(row.idealSolarKw, 3) + "</td>",
          "<td>" + row.powerwallCount + "</td>",
          "<td>" + usdPrecise(row.npv) + "</td>",
          "<td>" + formatPaybackYears(row.paybackYears, inputs.analysis.years) + "</td>",
          "<td>" + usdPrecise(row.pgeAfterMonthlyTrueUp) + "</td>",
          "<td>" + usdPrecise(row.totalMonthlyOutflow) + "</td>",
          "<td>" + fmt(row.annualImportKwh, 0) + "</td>",
          "<td>" + fmt(row.annualExportKwh, 0) + "</td>"
        ].join("");
        tr.addEventListener("click", () => {
          selectedScenarioKey = scenarioKey(row.idealSolarKw, row.powerwallCount);
          render();
        });
        el.topScenariosBody.appendChild(tr);
      });
    }

    function renderHvacImpact(inputs, best, baseOptimization) {
      const haOnInputs = { ...inputs, ha: { ...inputs.ha, enabled: true } };
      const haOffInputs = { ...inputs, ha: { ...inputs.ha, enabled: false } };

      const fixedOn = evaluateScenario(haOnInputs, best.idealSolarKw, best.powerwallCount);
      const fixedOff = evaluateScenario(haOffInputs, best.idealSolarKw, best.powerwallCount);
      const fixedUtilityDelta = fixedOn.pgeAfterMonthlyTrueUp - fixedOff.pgeAfterMonthlyTrueUp;
      const fixedOutflowDelta = fixedOn.totalMonthlyOutflow - fixedOff.totalMonthlyOutflow;

      if (!inputs.ha.enabled) {
        el.hvacImpactOutput.textContent = "HVAC shift is OFF. Enable HVAC shift to compare ON vs OFF optimized outcomes.";
        return;
      }
      const optOn = baseOptimization || getOptimizationCached(haOnInputs);
      const optOff = getOptimizationCached(haOffInputs);
      if (optOn.error || optOff.error) {
        el.hvacImpactOutput.textContent = "HVAC impact analysis unavailable: " + (optOn.error || optOff.error);
        return;
      }
      const bestOn = optOn.best;
      const bestOff = optOff.best;
      const optUtilityDelta = bestOn.pgeAfterMonthlyTrueUp - bestOff.pgeAfterMonthlyTrueUp;
      const optOutflowDelta = bestOn.totalMonthlyOutflow - bestOff.totalMonthlyOutflow;
      const optKwDelta = bestOn.idealSolarKw - bestOff.idealSolarKw;
      const optPwDelta = bestOn.powerwallCount - bestOff.powerwallCount;

      const lines = [];
      lines.push("Fixed-size (same " + fmt(best.idealSolarKw, 3) + " kW / " + best.powerwallCount + " PW): PG&E delta (HA ON - HA OFF) = " + usdSigned(fixedUtilityDelta) + ", outflow delta = " + usdSigned(fixedOutflowDelta) + ".");
      lines.push("Re-optimized: PG&E delta (HA ON - HA OFF) = " + usdSigned(optUtilityDelta) + ", outflow delta = " + usdSigned(optOutflowDelta) + ", selected kW delta = " + fmt(optKwDelta, 3) + " kW, PW delta = " + optPwDelta + ".");
      if (fixedOn.haGuardApplied) {
        lines.push("Guard applied to prevent utility increase at fixed size.");
      }
      el.hvacImpactOutput.textContent = lines.join(" ");
    }

    function renderCalculationBreakdown(inputs, result, optimization) {
      const objectiveMode = inputs.sizing.objectiveMode || "return_npv";
      const utilityBillChangeMonthlyWholeHome = result.utilityBillChangeMonthlyWholeHome;
      const utilityBillChangeMonthlySolarOnly = result.utilityBillChangeMonthlySolarOnly;
      const netPaymentChangeMonthly = utilityBillChangeMonthlyWholeHome + result.mortgageMonthly;
      const evMonthlyKwh = inputs.ev.enabled ? inputs.ev.kwhPerMonth : 0;
      const evAnnualKwh = evMonthlyKwh * 12;
      const dayPct = inputs.ev.dayChargingShare * 100;
      const nightPct = inputs.ev.nightChargingShare * 100;
      const summerLoadMult = clamp(1 + ((BASE_SUMMER_SETPOINT_F - inputs.load.summerSetpointF) * SUMMER_SETPOINT_LOAD_SENSITIVITY_PER_DEG), 0.7, 1.4);
      const winterLoadMult = clamp(1 + ((inputs.load.winterSetpointF - BASE_WINTER_SETPOINT_F) * WINTER_SETPOINT_LOAD_SENSITIVITY_PER_DEG), 0.7, 1.4);
      const shoulderLoadMult = clamp(0.5 * summerLoadMult + 0.5 * winterLoadMult, 0.7, 1.4);
      const candidates = optimization ? optimization.solarCandidates : [];
      const topRows = optimization ? optimization.results.slice(0, 5) : [];

      const lines = [];
      lines.push("<p class='calc-line'><strong>" + getClimateSourceText(inputs.climate) + "</strong></p>");
      lines.push("<p class='calc-line'><strong>" + getTemperatureSourceText(inputs.production) + "</strong></p>");
      if (inputs.climate && inputs.climate.lastVerifiedAt) {
        lines.push("<p class='calc-line'>Last verified climate dataset: " + formatTimestampForUi(inputs.climate.lastVerifiedAt) + ".</p>");
      }
      lines.push("<p class='calc-line'><strong>1) Total load assumption</strong></p>");
      lines.push("<p class='calc-line'>Home load base (non-EV) = " + fmt(inputs.load.annualKwh, 0) + " kWh/year.</p>");
      lines.push("<p class='calc-line'>Setpoint-driven seasonal multipliers: summer x" + fmt(summerLoadMult, 2) + " (setpoint " + fmt(inputs.load.summerSetpointF, 0) + "F), winter x" + fmt(winterLoadMult, 2) + " (setpoint " + fmt(inputs.load.winterSetpointF, 0) + "F), shoulder x" + fmt(shoulderLoadMult, 2) + ".</p>");
      lines.push("<p class='calc-line'>Adjusted home load after seasonal setpoint multipliers = " + fmt(result.annualHomeLoadAdjustedKwh, 0) + " kWh/year.</p>");
      if (inputs.ev.enabled) {
        lines.push("<p class='calc-line'>EV load = " + fmt(inputs.ev.milesPerMonth, 0) + " miles/month x " + fmt(inputs.ev.kwhPerMile, 2) + " kWh/mile = " + fmt(evMonthlyKwh, 1) + " kWh/month (" + fmt(evAnnualKwh, 0) + " kWh/year).</p>");
        lines.push("<p class='calc-line'>EV charging split target: Day " + fmt(dayPct, 0) + "% / Night " + fmt(nightPct, 0) + "%.</p>");
        lines.push("<p class='calc-line'>Rule: daytime EV charging uses surplus solar after battery charging; unmet daytime EV energy shifts to night.</p>");
      } else {
        lines.push("<p class='calc-line'>EV load is OFF, so no EV kWh is added.</p>");
      }
      if (inputs.whf.enabled) {
        if (inputs.whf.mode === "auto") {
          const whfMonths = (inputs.whf.autoActiveMonths || []).map((idx) => MONTH_LABELS[idx]).join(", ");
          const janWindow = inputs.whf.autoWindowByMonth[0] || { startMinuteOfDay: 0, endMinuteOfDay: 0 };
          const julWindow = inputs.whf.autoWindowByMonth[6] || { startMinuteOfDay: 0, endMinuteOfDay: 0 };
          lines.push("<p class='calc-line'>WHF AUTO load replacement: fan " + fmt(inputs.whf.fanWatts, 0) + "W, displaced AC " + fmt(inputs.whf.displacedAcWatts, 0) + "W. Active months: " + (whfMonths || "none") + ".</p>");
          lines.push("<p class='calc-line'>AUTO WHF success: Jan " + fmt((inputs.whf.successRateByMonth[0] || 0) * 100, 0) + "%, Jul " + fmt((inputs.whf.successRateByMonth[6] || 0) * 100, 0) + "%. AUTO windows: Jan " + fmt(Math.floor(janWindow.startMinuteOfDay / 60), 0) + ":00-" + fmt(Math.floor(janWindow.endMinuteOfDay / 60), 0) + ":00, Jul " + fmt(Math.floor(julWindow.startMinuteOfDay / 60), 0) + ":00-" + fmt(Math.floor(julWindow.endMinuteOfDay / 60), 0) + ":00.</p>");
        } else {
          const whfMonths = inputs.whf.activeMonths.map((idx) => MONTH_LABELS[idx]).join(", ");
          lines.push("<p class='calc-line'>WHF MANUAL load replacement: fan " + fmt(inputs.whf.fanWatts, 0) + "W, displaced AC " + fmt(inputs.whf.displacedAcWatts, 0) + "W, success " + fmt(inputs.whf.successRate * 100, 0) + "%, active months: " + whfMonths + ".</p>");
        }
        lines.push("<p class='calc-line'>WHF annual effect at selected scenario: fan " + fmt(result.annualWhfFanKwh, 0) + " kWh/yr, displaced AC " + fmt(result.annualWhfDisplacedAcKwh, 0) + " kWh/yr, net reduction " + fmt(result.annualWhfNetReductionKwh, 0) + " kWh/yr, active hours " + fmt(result.annualWhfActiveHours, 0) + ".</p>");
      } else {
        lines.push("<p class='calc-line'>WHF load replacement is OFF.</p>");
      }

      lines.push("<p class='calc-line'><strong>2) Utility bill calculations</strong></p>");
      lines.push("<p class='calc-line'>PG&amp;E Baseline / Month (No WHF/HA) = Annual Baseline Before / 12 = " + usdPrecise(result.annualBeforeNoControls) + " / 12 = " + usdPrecise(result.pgeBaselineMonthlyNoControls) + ".</p>");
      lines.push("<p class='calc-line'>PG&amp;E Before / Month (same-load baseline) = Annual Before / 12 = " + usdPrecise(result.annualBefore) + " / 12 = " + usdPrecise(result.pgeBeforeMonthly) + ".</p>");
      lines.push("<p class='calc-line'>PG&amp;E After / Month (True-Up) = Annual After / 12 = " + usdPrecise(result.annualAfterRaw) + " / 12 = " + usdPrecise(result.pgeAfterMonthlyTrueUp) + ".</p>");
      lines.push("<p class='calc-line'>Primary Utility Bill Change / Month (whole-home) = (After - Baseline No WHF/HA) = " + usdPrecise(result.pgeAfterMonthlyTrueUp) + " - " + usdPrecise(result.pgeBaselineMonthlyNoControls) + " = " + usdSigned(utilityBillChangeMonthlyWholeHome) + ".</p>");
      lines.push("<p class='calc-line'>Solar-only delta / Month (same-load baseline) = (After - Before) = " + usdPrecise(result.pgeAfterMonthlyTrueUp) + " - " + usdPrecise(result.pgeBeforeMonthly) + " = " + usdSigned(utilityBillChangeMonthlySolarOnly) + ".</p>");
      lines.push("<p class='calc-line'>Note: solar-only delta can shrink when WHF/HA reduce load, because both \"Before\" and \"After\" move downward.</p>");
      if (result.haGuardApplied) {
        lines.push("<p class='calc-line'>HVAC guardrail active: configured annual after-bill exceeded the no-controls annual after-bill by " + usdPrecise(result.haGuardPreventedAnnualCost) + "/yr at this size, so effective financial outputs are constrained to non-worsening no-controls values.</p>");
      }

      lines.push("<p class='calc-line'><strong>3) System cost and financing</strong></p>");
      lines.push("<p class='calc-line'>Gross system cost = Solar base + (Solar kW x solar $/kW) + Battery tier cost.</p>");
      lines.push("<p class='calc-line'>= " + usdPrecise(inputs.pricing.solarBaseCost) + " + (" + fmt(result.idealSolarKw, 3) + " x " + usdPrecise(inputs.pricing.solarCostPerKw) + ") + " + usdPrecise(getBatteryCost(result.powerwallCount, inputs.pricing)) + " = " + usdPrecise(result.systemCostGross) + ".</p>");
      lines.push("<p class='calc-line'>Financed Principal = Gross system cost = " + usdPrecise(result.financedPrincipal) + ".</p>");
      lines.push("<p class='calc-line'>Mortgage / Month (loan payment) = " + usdSigned(result.mortgageMonthly) + ".</p>");
      lines.push("<p class='calc-line'>Return metrics: NPV = " + usdPrecise(result.npv) + ", payback = " + formatPaybackYears(result.paybackYears, inputs.analysis.years) + ", cumulative net savings at " + inputs.analysis.years + "y = " + usdPrecise(result.projectionCumulative15) + ".</p>");

      lines.push("<p class='calc-line'><strong>4) Net monthly payment impact</strong></p>");
      lines.push("<p class='calc-line'>Net Change In Payment / Month = Primary Utility Bill Change + Mortgage.</p>");
      lines.push("<p class='calc-line'>= " + usdSigned(utilityBillChangeMonthlyWholeHome) + " + " + usdSigned(result.mortgageMonthly) + " = " + usdSigned(netPaymentChangeMonthly) + ".</p>");
      lines.push("<p class='calc-line'>Interpretation: negative is a monthly decrease (green), positive is a monthly increase (red).</p>");

      lines.push("<p class='calc-line'><strong>5) Ideal solar size selection logic</strong></p>");
      if (candidates.length) {
        lines.push("<p class='calc-line'>Solar candidates are generated from min/max/step: " + fmt(inputs.sizing.solarSearchMinKw, 3) + " to " + fmt(inputs.sizing.solarSearchMaxKw, 3) + " kW at " + fmt(inputs.sizing.solarSearchStepKw, 3) + " kW increments (" + candidates.length + " candidates).</p>");
        lines.push("<p class='calc-line'>Battery sweep: 0-4 Powerwalls. Total scenarios = " + (candidates.length * 5) + ".</p>");
      }
      lines.push("<p class='calc-line'>Configured objective = " + objectiveLabel(objectiveMode) + ".</p>");
      lines.push("<p class='calc-line'>For each candidate, objective value = " + objectiveFormula(objectiveMode) + ".</p>");
      lines.push("<p class='calc-line'>Tie-breakers if objective ties: lower financed principal, then lower solar kW.</p>");
      lines.push("<p class='calc-line'>Selected ideal solar size = " + fmt(result.idealSolarKw, 3) + " kW (Powerwalls: " + result.powerwallCount + "). Selection reason = " + result.selectionReason + ".</p>");

      if (topRows.length) {
        const objectiveColLabel = objectiveMode === "return_npv"
          ? "Objective (NPV)"
          : (objectiveMode === "utility_bill_knee" ? "Objective (Pareto knee context)" : "Objective (After + Mortgage)");
        lines.push("<table class='calc-table'><thead><tr><th>Rank</th><th>Solar kW</th><th>PW</th><th>PG&E After/mo</th><th>Mortgage/mo</th><th>" + objectiveColLabel + "</th><th>Net Change/mo</th></tr></thead><tbody>");
        topRows.forEach((row, idx) => {
          const rowUtilityChange = row.utilityBillChangeMonthlyWholeHome;
          const rowNetChange = rowUtilityChange + row.mortgageMonthly;
          const objectiveValue = objectiveMode === "return_npv"
            ? usdPrecise(row.npv)
            : (objectiveMode === "utility_bill_knee" ? (usdPrecise(row.pgeAfterMonthlyTrueUp) + " @ " + usd(row.systemCostGross)) : usdPrecise(row.totalMonthlyOutflow));
          lines.push(
            "<tr>" +
            "<td>" + (idx + 1) + (idx === 0 ? " (Selected)" : "") + "</td>" +
            "<td>" + fmt(row.idealSolarKw, 3) + "</td>" +
            "<td>" + row.powerwallCount + "</td>" +
            "<td>" + usdPrecise(row.pgeAfterMonthlyTrueUp) + "</td>" +
            "<td>" + usdPrecise(row.mortgageMonthly) + "</td>" +
            "<td>" + objectiveValue + "</td>" +
            "<td>" + usdSigned(rowNetChange) + "</td>" +
            "</tr>"
          );
        });
        lines.push("</tbody></table>");
      }

      const avgDaySolarGen = result.annualSolarGenerationKwh / DAYS_PER_YEAR;
      const avgDayLoad = result.annualTotalLoadAfterEvKwh / DAYS_PER_YEAR;
      const avgDaySolarToLoad = result.annualDirectSolarToLoadKwh / DAYS_PER_YEAR;
      const avgDaySolarToBatteryStored = result.annualSolarToBatteryStoredKwh / DAYS_PER_YEAR;
      const avgDaySolarToEvDay = result.annualEvDaySolarServedKwh / DAYS_PER_YEAR;
      const avgDaySolarExport = result.annualExportKwh / DAYS_PER_YEAR;
      const avgDayBatteryToLoad = result.annualBatteryToLoadKwh / DAYS_PER_YEAR;
      const avgDayBatteryToLoadPeak = result.annualBatteryToLoadPeakKwh / DAYS_PER_YEAR;
      const avgDayBatteryToLoadPostPeak = result.annualBatteryToLoadPostPeakKwh / DAYS_PER_YEAR;
      const avgDayBatteryToGrid = result.annualBatteryToGridExportKwh / DAYS_PER_YEAR;
      const avgDayImportPeak = result.annualImportPeakKwh / DAYS_PER_YEAR;
      const avgDayImportOff = result.annualImportOffKwh / DAYS_PER_YEAR;
      const avgDayEvShift = result.annualEvDayShiftedToNightKwh / DAYS_PER_YEAR;
      const avgDayImportTotal = result.annualImportKwh / DAYS_PER_YEAR;
      const avgDayHvacShiftCapacity = result.annualHvacShiftCapacityKwh / DAYS_PER_YEAR;
      const avgDayHvacShiftScheduled = result.annualHvacShiftScheduledKwh / DAYS_PER_YEAR;
      const avgDayHvacShiftExecuted = result.annualHvacShiftExecutedKwh / DAYS_PER_YEAR;
      const avgDayHvacShiftToPreWindow = result.annualHvacShiftToPreWindowKwh / DAYS_PER_YEAR;
      const avgDayHvacPeakImportAvoided = result.annualHvacPeakImportAvoidedKwh / DAYS_PER_YEAR;
      const avgDayClippedSolar = result.annualClippedSolarKwh / DAYS_PER_YEAR;

      const genPct = (v) => (avgDaySolarGen > 0 ? (100 * v) / avgDaySolarGen : 0);
      const loadPct = (v) => (avgDayLoad > 0 ? (100 * v) / avgDayLoad : 0);
      const pctText = (value, base) => fmt(value, 1) + "% " + base;

      lines.push("<p class='calc-line'><strong>6) Daily Model Flow (NEM3/TOU/EV)</strong></p>");
      lines.push("<p class='calc-line'>Legend: <strong>Gen%</strong> = percent of solar generation. <strong>Load%</strong> = percent of total load.</p>");
      lines.push("<p class='calc-line'>Representative day shown here is annualized model output divided by 365 days (same day-engine logic used in calculations).</p>");
      lines.push("<p class='calc-line'>Dispatch mode: " + inputs.battery.dispatchMode + ". Reserve policy: " + inputs.battery.reservePolicy + " (Jan " + fmt(getMonthReservePct(inputs.battery, 0) * 100, 0) + "%, Jul " + fmt(getMonthReservePct(inputs.battery, 6) * 100, 0) + "%).</p>");
      lines.push("<p class='calc-line'>Flow order: HVAC shift (if enabled) -> WHF replacement (if enabled) -> solar generation -> inverter clipping cap -> direct solar to home/EV/export at solar-to-home efficiency -> battery charging (round-trip efficiency model) -> battery discharge to load (dispatch mode rules) -> optional battery-to-grid export in arbitrage mode when export rate &gt; import rate -> grid imports.</p>");
      lines.push("<p class='calc-line'>Efficiency assumptions: solar-to-home " + fmt(inputs.production.solarToHomeEfficiency * 100, 1) + "%, battery round-trip " + fmt(inputs.battery.roundTripEfficiency * 100, 1) + "%.</p>");

      lines.push("<table class='calc-table'><thead><tr><th>Metric</th><th>kWh/day</th><th>% (Gen or Load)</th><th>How computed</th></tr></thead><tbody>");
      lines.push("<tr><td>Solar generation</td><td>" + fmt(avgDaySolarGen, 2) + "</td><td>" + pctText(100, "Gen") + "</td><td>Annual solar generation / 365</td></tr>");
      lines.push("<tr><td>Solar clipped</td><td>" + fmt(avgDayClippedSolar, 2) + "</td><td>" + pctText(result.annualClippedSolarPct * 100, "Gen") + "</td><td>Generation discarded by PW3 inverter cap</td></tr>");
      lines.push("<tr><td>Solar -> home load</td><td>" + fmt(avgDaySolarToLoad, 2) + "</td><td>" + pctText(genPct(avgDaySolarToLoad), "Gen") + "</td><td>Direct solar consumed by home load</td></tr>");
      lines.push("<tr><td>Solar -> battery (stored)</td><td>" + fmt(avgDaySolarToBatteryStored, 2) + "</td><td>" + pctText(genPct(avgDaySolarToBatteryStored), "Gen") + "</td><td>Charge input x round-trip efficiency</td></tr>");
      lines.push("<tr><td>Solar -> daytime EV</td><td>" + fmt(avgDaySolarToEvDay, 2) + "</td><td>" + pctText(genPct(avgDaySolarToEvDay), "Gen") + "</td><td>Surplus solar to EV in 09:00-16:00</td></tr>");
      lines.push("<tr><td>Solar export</td><td>" + fmt(avgDaySolarExport, 2) + "</td><td>" + pctText(genPct(avgDaySolarExport), "Gen") + "</td><td>Remaining solar sent to grid</td></tr>");
      lines.push("<tr><td>Battery -> load (peak)</td><td>" + fmt(avgDayBatteryToLoadPeak, 2) + "</td><td>" + pctText(loadPct(avgDayBatteryToLoadPeak), "Load") + "</td><td>Cost-priority discharge in 16:00-21:00</td></tr>");
      lines.push("<tr><td>Battery -> load (non-peak)</td><td>" + fmt(avgDayBatteryToLoadPostPeak, 2) + "</td><td>" + pctText(loadPct(avgDayBatteryToLoadPostPeak), "Load") + "</td><td>Non-peak discharge (post-peak only in self-consumption mode)</td></tr>");
      lines.push("<tr><td>Battery -> load (total)</td><td>" + fmt(avgDayBatteryToLoad, 2) + "</td><td>" + pctText(loadPct(avgDayBatteryToLoad), "Load") + "</td><td>Peak + non-peak discharge</td></tr>");
      lines.push("<tr><td>Battery -> grid export</td><td>" + fmt(avgDayBatteryToGrid, 2) + "</td><td>" + pctText(genPct(avgDayBatteryToGrid), "Gen") + "</td><td>Arbitrage-only export when export rate &gt; import rate</td></tr>");
      lines.push("<tr><td>Grid import peak</td><td>" + fmt(avgDayImportPeak, 2) + "</td><td>" + pctText(loadPct(avgDayImportPeak), "Load") + "</td><td>Post-solar/battery unmet load in peak hours</td></tr>");
      lines.push("<tr><td>Grid import off-peak</td><td>" + fmt(avgDayImportOff, 2) + "</td><td>" + pctText(loadPct(avgDayImportOff), "Load") + "</td><td>Post-solar unmet load outside peak hours</td></tr>");
      lines.push("<tr><td>EV day shifted to night</td><td>" + fmt(avgDayEvShift, 2) + "</td><td>" + pctText(loadPct(avgDayEvShift), "Load") + "</td><td>Unserved daytime EV moved to night window</td></tr>");
      lines.push("<tr><td>Total grid import</td><td>" + fmt(avgDayImportTotal, 2) + "</td><td>" + pctText(loadPct(avgDayImportTotal), "Load") + "</td><td>Grid import peak + off-peak</td></tr>");
      lines.push("</tbody></table>");

      lines.push("<p class='calc-line'><strong>7) HVAC temperature-driven shift controls</strong></p>");
      if (!inputs.ha.enabled) {
        lines.push("<p class='calc-line'>HomeAssistant HVAC shift is OFF. Setpoints still affect seasonal load multipliers; only shifting behavior is disabled.</p>");
      } else if (inputs.ha.mode === "auto") {
        const janWindow = inputs.ha.autoPreWindowByMonth[0] || { startHour: 11, endHour: 15 };
        const julWindow = inputs.ha.autoPreWindowByMonth[6] || { startHour: 12, endHour: 16 };
        lines.push("<p class='calc-line'>HA AUTO mode is ON. Month-by-month success and pre-windows are inferred from temperature stress (cooling/heating) and bounded to deterministic defaults.</p>");
        lines.push("<p class='calc-line'>AUTO success examples: Jan " + fmt((inputs.ha.successRateByMonth[0] || 0) * 100, 0) + "%, Jul " + fmt((inputs.ha.successRateByMonth[6] || 0) * 100, 0) + "%.</p>");
        lines.push("<p class='calc-line'>AUTO pre-window examples: Jan " + janWindow.startHour + ":00-" + janWindow.endHour + ":00, Jul " + julWindow.startHour + ":00-" + julWindow.endHour + ":00.</p>");
        lines.push("<p class='calc-line'>Max shift caps still apply: maxShiftHoursPerDay " + fmt(inputs.ha.maxShiftHoursPerDay, 0) + ", maxShiftKwhPerDay " + fmt(inputs.ha.maxShiftKwhPerDay, 2) + ".</p>");
        lines.push("<p class='calc-line'>Representative day results: capacity " + fmt(avgDayHvacShiftCapacity, 2) + " kWh/day, scheduled " + fmt(avgDayHvacShiftScheduled, 2) + " kWh/day, executed " + fmt(avgDayHvacShiftExecuted, 2) + " kWh/day, shifted to pre-window " + fmt(avgDayHvacShiftToPreWindow, 2) + " kWh/day, shifted to post-peak recovery " + fmt(result.annualHvacShiftToPostPeakKwh / DAYS_PER_YEAR, 2) + " kWh/day, peak-import avoided estimate " + fmt(avgDayHvacPeakImportAvoided, 2) + " kWh/day.</p>");
      } else {
        const preWindowHours = buildHourRange(inputs.ha.preCoolStartHour, inputs.ha.preCoolEndHour, 24).slice(0, inputs.ha.maxShiftHoursPerDay).length;
        const seasonSummer = getSeasonDailyHvacShiftCapacity(inputs.ha, 6, preWindowHours);
        const seasonWinter = getSeasonDailyHvacShiftCapacity(inputs.ha, 0, preWindowHours);
        const seasonShoulder = getSeasonDailyHvacShiftCapacity(inputs.ha, 3, preWindowHours);
        lines.push("<p class='calc-line'>Season map: Summer May-Sep, Winter Nov-Feb, Shoulder Mar-Apr-Oct. Temperature units are Fahrenheit.</p>");
        lines.push("<p class='calc-line'>Summer setpoint " + fmt(inputs.ha.summerSetpointF, 0) + "F with max pre-cool offset " + fmt(inputs.ha.maxPrecoolOffsetF, 1) + "F. Winter setpoint " + fmt(inputs.ha.winterSetpointF, 0) + "F with max pre-heat offset " + fmt(inputs.ha.maxPreheatOffsetF, 1) + "F.</p>");
        lines.push("<p class='calc-line'>Peak-hours drift allowance from setpoint (4-9pm): " + fmt(inputs.ha.maxPeakRelaxOffsetF, 1) + "F.</p>");
        lines.push("<p class='calc-line'>Pre-window hours/day = min(maxShiftHoursPerDay, hours between start/end) = min(" + fmt(inputs.ha.maxShiftHoursPerDay, 0) + ", " + preWindowHours + ") = " + preWindowHours + ".</p>");
        lines.push("<p class='calc-line'>dailyShiftCapacity = (preOffsetF * sensitivity * preWindowHours) + (peakDriftF * sensitivity * peakHours), then capped by maxShiftKwhPerDay.</p>");
        lines.push("<p class='calc-line'>Summer daily cap: min(" + fmt(inputs.ha.maxShiftKwhPerDay, 2) + ", (" + fmt(inputs.ha.maxPrecoolOffsetF, 2) + "*" + fmt(inputs.ha.hvacSensitivityKwhPerDegHour, 2) + "*" + preWindowHours + ") + (" + fmt(inputs.ha.maxPeakRelaxOffsetF, 2) + "*" + fmt(inputs.ha.hvacSensitivityKwhPerDegHour, 2) + "*5)) = " + fmt(seasonSummer.seasonCap, 2) + " kWh/day.</p>");
        lines.push("<p class='calc-line'>Winter daily cap: min(" + fmt(inputs.ha.maxShiftKwhPerDay, 2) + ", (" + fmt(inputs.ha.maxPreheatOffsetF, 2) + "*" + fmt(inputs.ha.hvacSensitivityKwhPerDegHour, 2) + "*" + preWindowHours + ") + (" + fmt(inputs.ha.maxPeakRelaxOffsetF, 2) + "*" + fmt(inputs.ha.hvacSensitivityKwhPerDegHour, 2) + "*5)) = " + fmt(seasonWinter.seasonCap, 2) + " kWh/day.</p>");
        lines.push("<p class='calc-line'>Shoulder daily cap (50/50 blend): " + fmt(seasonShoulder.seasonCap, 2) + " kWh/day.</p>");
        lines.push("<p class='calc-line'>dailyShiftExecuted = dailyShiftCapacity * successRate. Success rate = " + fmt(inputs.ha.successRate * 100, 0) + "%.</p>");
        lines.push("<p class='calc-line'>Representative day results: capacity " + fmt(avgDayHvacShiftCapacity, 2) + " kWh/day, scheduled " + fmt(avgDayHvacShiftScheduled, 2) + " kWh/day, executed " + fmt(avgDayHvacShiftExecuted, 2) + " kWh/day, shifted to pre-window " + fmt(avgDayHvacShiftToPreWindow, 2) + " kWh/day, shifted to post-peak recovery " + fmt(result.annualHvacShiftToPostPeakKwh / DAYS_PER_YEAR, 2) + " kWh/day, peak-import avoided estimate " + fmt(avgDayHvacPeakImportAvoided, 2) + " kWh/day.</p>");
        lines.push("<p class='calc-line'>Annual HVAC shift totals: capacity " + fmt(result.annualHvacShiftCapacityKwh, 0) + " kWh/yr, scheduled " + fmt(result.annualHvacShiftScheduledKwh, 0) + " kWh/yr, executed " + fmt(result.annualHvacShiftExecutedKwh, 0) + " kWh/yr, shifted to pre-window " + fmt(result.annualHvacShiftToPreWindowKwh, 0) + " kWh/yr, shifted to post-peak " + fmt(result.annualHvacShiftToPostPeakKwh, 0) + " kWh/yr.</p>");
      }

      const exportPeakAnnual = Number(result.annualExportPeakKwh) || 0;
      const exportOffAnnual = Number(result.annualExportOffKwh) || 0;
      const exportPeakRate = inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportPeak;
      const exportOffRate = inputs.rates.exportRateMode === "nem3_override" ? inputs.rates.nem3ExportRate : inputs.rates.exportOffPeak;
      const annualAfterFromFlow = result.annualFixedChargeTotal + result.annualNbcAfter + result.annualEnergyNetAfterTrueUp - result.annualVppCredit;

      lines.push("<p class='calc-line'><strong>Annual rollup and TOU/NEM3 bill linkage</strong></p>");
      if (inputs.rates.exportRateMode === "nem3_override") {
        lines.push("<p class='calc-line'>Export mode: NEM3 override. All exported kWh credited at " + usdPrecise(inputs.rates.nem3ExportRate) + "/kWh.</p>");
      } else {
        lines.push("<p class='calc-line'>Export mode: TOU export. Export is bucketed hourly into peak/off-peak (peak rate " + usdPrecise(inputs.rates.exportPeak) + "/kWh, off-peak " + usdPrecise(inputs.rates.exportOffPeak) + "/kWh).</p>");
      }
      lines.push("<p class='calc-line'>Annual_Import_Cost_After = " + usdPrecise(result.annualImportEnergyCostAfter) + ".</p>");
      lines.push("<p class='calc-line'>Annual_Export_Value = exportPeakKwh*exportPeakRate + exportOffPeakKwh*exportOffPeakRate = (" + fmt(exportPeakAnnual, 0) + "*" + usdPrecise(exportPeakRate) + ") + (" + fmt(exportOffAnnual, 0) + "*" + usdPrecise(exportOffRate) + ") = " + usdPrecise(result.annualExportCreditValue) + ".</p>");
      lines.push("<p class='calc-line'>Battery_To_Grid_Export = " + fmt(result.annualBatteryToGridExportKwh, 0) + " kWh/year (included in annual export buckets).</p>");
      lines.push("<p class='calc-line'>Annual_Energy_Net = max(0, Annual_Import_Cost_After - Annual_Export_Value) = max(0, " + usdPrecise(result.annualImportEnergyCostAfter) + " - " + usdPrecise(result.annualExportCreditValue) + ") = " + usdPrecise(result.annualEnergyNetAfterTrueUp) + ".</p>");
      lines.push("<p class='calc-line'>Annual_Fixed_Total = " + usdPrecise(result.annualFixedChargeTotal) + ", Annual_NBC_After = " + usdPrecise(result.annualNbcAfter) + ".</p>");
      lines.push("<p class='calc-line'>Annual_VPP_Credit = " + fmt(result.powerwallCount, 0) + "*" + fmt(POWERWALL3_AC_KW, 1) + "*" + usdPrecise(VPP_CREDIT_PER_KW_YEAR) + " = " + usdPrecise(result.annualVppCredit) + ".</p>");
      lines.push("<p class='calc-line'>annualAfterRaw = Annual_Fixed_Total + Annual_NBC_After + Annual_Energy_Net - Annual_VPP_Credit = " + usdPrecise(result.annualFixedChargeTotal) + " + " + usdPrecise(result.annualNbcAfter) + " + " + usdPrecise(result.annualEnergyNetAfterTrueUp) + " - " + usdPrecise(result.annualVppCredit) + " = " + usdPrecise(annualAfterFromFlow) + ".</p>");
      if (annualAfterFromFlow < 0) {
        lines.push("<p class='calc-line'>Result is negative: modeled annual utility position is net-positive cashflow (VPP payout exceeds annual liability).</p>");
      }
      lines.push("<p class='calc-line'>Bridge checks: PG&amp;E After / Month = " + usdPrecise(result.pgeAfterMonthlyTrueUp) + ", Primary Utility Bill Change / Month = " + usdSigned(utilityBillChangeMonthlyWholeHome) + ", Solar-only delta / Month = " + usdSigned(utilityBillChangeMonthlySolarOnly) + ", Net Change / Month = " + usdSigned(netPaymentChangeMonthly) + ".</p>");

      el.calcBreakdown.innerHTML = lines.join("");
    }

    function renderInvalidState() {
      el.cardIdealSolarKw.textContent = "--";
      el.cardPowerwallChoice.textContent = "Powerwalls: --";
      el.cardPgeBefore.textContent = "--";
      el.cardPgeAfter.textContent = "--";
      el.cardTrueUpNote.textContent = "Annual true-up bill: --";
      el.cardClippedSolar.textContent = "--";
      el.cardClippedSolarNote.textContent = "Annual clipped solar: --";
      el.cardSavings.textContent = "--";
      el.cardUtilityChangeFormula.textContent = "(PG&E After) - (PG&E Baseline No WHF/HA)";
      el.cardSolarOnlyDelta.textContent = "Solar-only delta (same-load baseline): --";
      el.cardNetPaymentChange.textContent = "--";
      el.cardFinanced.textContent = "--";
      el.cardMortgage.textContent = "--";
      el.cardOutflow.textContent = "Total outflow/mo: --";
      el.cardNetPaymentFormula.textContent = "(Primary Utility Bill Change / Month) + (Mortgage / Month)";
      el.cardFinancedNote.textContent = "Based on gross system cost.";
      el.checksOutput.textContent = "Checks are unavailable until all input errors are resolved.";
      el.regressionOutput.textContent = "Regression probe unavailable until calculation is valid.";
      el.candidateNote.textContent = "Candidate set: --";
      el.hvacImpactOutput.textContent = "HVAC impact analysis is unavailable until all input errors are resolved.";
      el.calcBreakdown.textContent = "Enter valid inputs to see step-by-step calculations.";
      el.scenarioMatrixTable.innerHTML = "";
      el.scenarioMatrixNote.textContent = "Matrix is unavailable until all input errors are resolved.";
      el.topScenariosBody.innerHTML = "";
    }

    function syncControlStates() {
      applyRescueDefaults();
      const objectiveMode = el.sizingObjective.value === "total_outflow"
        ? "total_outflow"
        : (el.sizingObjective.value === "utility_bill_knee" ? "utility_bill_knee" : "return_npv");
      el.sizingObjectiveHint.textContent = objectiveMode === "return_npv"
        ? "Objective: maximize NPV. Tie-breakers: faster payback, then lower outflow."
        : (objectiveMode === "utility_bill_knee"
          ? "Objective: choose Pareto knee point on PG&E bill vs system cost."
          : "Objective: minimize mortgage + post-solar PG&E true-up.");
      el.sweepModeHint.textContent = el.lockPowerwallCount.checked
        ? ("Sweep mode: LOCKED to " + el.powerwallCount.value + " Powerwalls.")
        : "Sweep mode: all Powerwall counts (0-4).";
      el.objectiveSummary.innerHTML = "Ideal size is selected by <strong>" + objectiveFormula(objectiveMode) + "</strong>.";
      const nemMode = el.exportRateMode.value === "nem3_override";
      el.nem3ExportRate.disabled = !nemMode;
      el.exportOffPeak.disabled = nemMode;
      el.exportPeak.disabled = nemMode;
      const tariffPreset = el.tariffPreset.value === "pge_e_elec" ? "pge_e_elec" : "custom";
      el.exportModeNote.textContent = nemMode
        ? "NEM 3.0 override active: export credits use one rate and annual energy true-up rollover."
        : "TOU export mode active: modeled hourly export is bucketed by peak/off-peak.";
      if (tariffPreset === "pge_e_elec") {
        el.exportModeNote.textContent += " Tariff preset: PG&E E-ELEC reference.";
      }

      const whfEnabled = el.enableWhf.checked;
      const whfManualMode = el.whfMode.value === "manual";
      el.whfFields.classList.toggle("hidden", !whfEnabled);
      el.whfMode.disabled = !whfEnabled;
      el.whfManualFields.classList.toggle("hidden", !whfEnabled || !whfManualMode);
      el.whfFanWatts.disabled = !whfEnabled;
      el.whfDisplacedAcWatts.disabled = !whfEnabled;
      el.whfStartHour.disabled = !whfEnabled || !whfManualMode;
      el.whfStartMinute.disabled = !whfEnabled || !whfManualMode;
      el.whfEndHour.disabled = !whfEnabled || !whfManualMode;
      el.whfEndMinute.disabled = !whfEnabled || !whfManualMode;
      el.whfSuccessRatePct.disabled = !whfEnabled || !whfManualMode;
      el.whfMonthNodes.forEach((node) => {
        node.disabled = !whfEnabled || !whfManualMode;
      });
      if (!whfEnabled) {
        el.whfNote.textContent = "WHF: OFF.";
      } else if (!whfManualMode) {
        const fanW = Math.max(0, Number(el.whfFanWatts.value) || 0);
        const displacedW = Math.max(0, Number(el.whfDisplacedAcWatts.value) || 0);
        el.whfNote.textContent = "WHF: AUTO | Window/success/months are derived per month from temperature profile. Fan " + fmt(fanW, 0) + "W | Displaced AC " + fmt(displacedW, 0) + "W.";
      } else {
        const startHour = clamp(Number(el.whfStartHour.value) || 0, 0, 23);
        const startMinute = clamp(Number(el.whfStartMinute.value) || 0, 0, 59);
        const endHour = clamp(Number(el.whfEndHour.value) || 0, 0, 23);
        const endMinute = clamp(Number(el.whfEndMinute.value) || 0, 0, 59);
        const fanW = Math.max(0, Number(el.whfFanWatts.value) || 0);
        const displacedW = Math.max(0, Number(el.whfDisplacedAcWatts.value) || 0);
        const successPct = clamp(Number(el.whfSuccessRatePct.value) || 0, 0, 100);
        const monthCount = el.whfMonthNodes.filter((node) => node.checked).length;
        el.whfNote.textContent = "WHF: ON | Window " + fmt(startHour, 0) + ":" + String(startMinute).padStart(2, "0") + " to " + fmt(endHour, 0) + ":" + String(endMinute).padStart(2, "0") + " | Fan " + fmt(fanW, 0) + "W | Displaced AC " + fmt(displacedW, 0) + "W | Months " + monthCount + " | Success " + fmt(successPct, 0) + "%.";
      }

      const evEnabled = el.hasEvCharging.checked;
      el.evFields.classList.toggle("hidden", !evEnabled);
      el.evMilesPerMonth.disabled = !evEnabled;
      el.evKwhPerMile.disabled = !evEnabled;
      el.evDayChargingPct.disabled = !evEnabled;

      if (!evEnabled) {
        el.evLoadNote.textContent = "EV load: OFF.";
      } else {
        const miles = Number(el.evMilesPerMonth.value);
        const kwhPerMile = Number(el.evKwhPerMile.value);
        const dayPct = clamp(Number(el.evDayChargingPct.value), 0, 100);
        const monthlyKwh = (Number.isFinite(miles) ? Math.max(0, miles) : 0) * (Number.isFinite(kwhPerMile) ? Math.max(0, kwhPerMile) : 0);
        const annualKwh = monthlyKwh * 12;
        const nightPct = 100 - dayPct;
        el.evLoadNote.textContent = "EV load: " + fmt(monthlyKwh, 0) + " kWh/month, " + fmt(annualKwh, 0) + " kWh/year. Day " + fmt(dayPct, 0) + "% / Night " + fmt(nightPct, 0) + "%.";
      }

      const haEnabled = el.enableHaShift.checked;
      const haManualMode = el.haMode.value === "manual";
      el.haFields.classList.toggle("hidden", !haEnabled);
      el.haMode.disabled = !haEnabled;
      el.haManualFields.classList.toggle("hidden", !haEnabled || !haManualMode);
      el.tempUnitsDisplay.disabled = false;
      el.summerSetpointF.disabled = false;
      el.winterSetpointF.disabled = false;
      el.maxPrecoolOffsetF.disabled = !haEnabled;
      el.maxPreheatOffsetF.disabled = !haEnabled;
      el.maxPeakRelaxOffsetF.disabled = !haEnabled;
      el.hvacSensitivityKwhPerDegHour.disabled = !haEnabled;
      el.hvacShiftSuccessRatePct.disabled = !haEnabled || !haManualMode;
      el.preCoolStartHour.disabled = !haEnabled || !haManualMode;
      el.preCoolEndHour.disabled = !haEnabled || !haManualMode;
      el.maxShiftHoursPerDay.disabled = !haEnabled;
      el.maxShiftKwhPerDay.disabled = !haEnabled;

      const summerSetpoint = Number(el.summerSetpointF.value);
      const winterSetpoint = Number(el.winterSetpointF.value);
      const setpointSummerMult = clamp(1 + ((BASE_SUMMER_SETPOINT_F - (Number.isFinite(summerSetpoint) ? summerSetpoint : BASE_SUMMER_SETPOINT_F)) * SUMMER_SETPOINT_LOAD_SENSITIVITY_PER_DEG), 0.7, 1.4);
      const setpointWinterMult = clamp(1 + (((Number.isFinite(winterSetpoint) ? winterSetpoint : BASE_WINTER_SETPOINT_F) - BASE_WINTER_SETPOINT_F) * WINTER_SETPOINT_LOAD_SENSITIVITY_PER_DEG), 0.7, 1.4);

      if (!haEnabled) {
        el.haLoadShiftNote.textContent = "HVAC shift: OFF. Setpoint load multipliers active: summer x" + fmt(setpointSummerMult, 2) + ", winter x" + fmt(setpointWinterMult, 2) + ".";
      } else if (!haManualMode) {
        const climateContext = buildClimateContext(el.zipCode.value, el.nrelApiKey.value);
        const climateSnapshot = getClimateSnapshot(climateContext);
        const tempProfile = isValidTempHourlyByMonth(climateSnapshot.tempHourlyFByMonth)
          ? climateSnapshot.tempHourlyFByMonth
          : getSyntheticTempHourlyByMonthProfiles();
        const autoHaPreview = deriveAutoHaProfile(
          tempProfile,
          Number.isFinite(summerSetpoint) ? summerSetpoint : BASE_SUMMER_SETPOINT_F,
          Number.isFinite(winterSetpoint) ? winterSetpoint : BASE_WINTER_SETPOINT_F
        );
        const summerWindow = autoHaPreview.autoPreWindowByMonth[6];
        const winterWindow = autoHaPreview.autoPreWindowByMonth[0];
        el.haLoadShiftNote.textContent = "Setpoint multipliers: summer x" + fmt(setpointSummerMult, 2) + ", winter x" + fmt(setpointWinterMult, 2) + ". AUTO windows: Summer " + summerWindow.startHour + ":00-" + summerWindow.endHour + ":00, Winter " + winterWindow.startHour + ":00-" + winterWindow.endHour + ":00. AUTO success by month is temperature-stress weighted.";
      } else {
        const preStart = Number(el.preCoolStartHour.value);
        const preEnd = Number(el.preCoolEndHour.value);
        const maxHours = Number(el.maxShiftHoursPerDay.value);
        const preWindowHours = buildHourRange(preStart, preEnd, 24).slice(0, Math.max(0, Math.floor(maxHours))).length;
        const sensitivity = Math.max(0, Number(el.hvacSensitivityKwhPerDegHour.value) || 0);
        const summerOffset = Math.max(0, Number(el.maxPrecoolOffsetF.value) || 0);
        const winterOffset = Math.max(0, Number(el.maxPreheatOffsetF.value) || 0);
        const peakRelaxOffset = Math.max(0, Number(el.maxPeakRelaxOffsetF.value) || 0);
        const maxShift = Math.max(0, Number(el.maxShiftKwhPerDay.value) || 0);
        const summerCap = Math.min(maxShift, (summerOffset * sensitivity * preWindowHours) + (peakRelaxOffset * sensitivity * PEAK_WINDOW_HOURS.length));
        const winterCap = Math.min(maxShift, (winterOffset * sensitivity * preWindowHours) + (peakRelaxOffset * sensitivity * PEAK_WINDOW_HOURS.length));
        const shoulderCap = Math.min(maxShift, 0.5 * summerCap + 0.5 * winterCap);
        const successPct = clamp(Number(el.hvacShiftSuccessRatePct.value) || 0, 0, 100);
        el.haLoadShiftNote.textContent = "Setpoint multipliers: summer x" + fmt(setpointSummerMult, 2) + ", winter x" + fmt(setpointWinterMult, 2) + ". Daily shift cap: Summer " + fmt(summerCap, 2) + " kWh, Winter " + fmt(winterCap, 2) + " kWh, Shoulder " + fmt(shoulderCap, 2) + " kWh. Success " + fmt(successPct, 0) + "%.";
      }

      const reservePolicy = el.reservePolicy.value === "fixed"
        ? "fixed"
        : (el.reservePolicy.value === "custom_monthly" ? "custom_monthly" : "auto_seasonal");
      const fixedReserveMode = reservePolicy === "fixed";
      const customReserveMode = reservePolicy === "custom_monthly";
      el.fixedReserveField.classList.toggle("hidden", !fixedReserveMode);
      el.reserveMonthlyFields.classList.toggle("hidden", !customReserveMode);
      el.minSocReservePct.disabled = !fixedReserveMode;
      el.monthlyReservePctNodes.forEach((node) => {
        if (node) node.disabled = !customReserveMode;
      });

    }

    function showErrors(errors) {
      if (!errors.length) {
        el.errorBox.style.display = "none";
        el.errorBox.textContent = "";
        return;
      }
      el.errorBox.style.display = "block";
      el.errorBox.innerHTML = "<strong>Fix input issues:</strong><br>" + errors.join("<br>");
    }

    function setClimateBadge(className, text) {
      el.climateDataBadge.classList.remove("climate-badge-live", "climate-badge-cached", "climate-badge-fallback");
      if (className) el.climateDataBadge.classList.add(className);
      let dot = el.climateDataBadge.querySelector(".climate-badge-dot");
      let label = el.climateDataBadge.querySelector("span:last-child");
      if (!dot || !label) {
        el.climateDataBadge.innerHTML = "";
        dot = document.createElement("span");
        dot.className = "climate-badge-dot";
        label = document.createElement("span");
        el.climateDataBadge.appendChild(dot);
        el.climateDataBadge.appendChild(label);
      }
      label.textContent = text;
    }

    function renderClimateStatusUi(climate, climateContext) {
      const keyModeLabel = climate.keyMode === "user_key" ? "user key" : "DEMO_KEY";
      if (!climateContext.ok) {
        setClimateBadge("climate-badge-fallback", "Climate Data: invalid ZIP");
        el.climateAssumptionPill.textContent = "Climate source: unavailable (invalid ZIP)";
        el.climateFallbackBanner.classList.remove("visible");
        el.fallbackProceedBtn.style.display = "none";
        return;
      }

      const lastVerifiedText = formatTimestampForUi(climate.lastVerifiedAt);
      if (climate.pending && climate.status !== "verified_live" && climate.status !== "verified_cached") {
        setClimateBadge("", "Climate Data: fetching NREL for " + climate.locationLabel + "...");
        el.climateAssumptionPill.textContent = "Climate source: fetching NREL data";
        el.climateFallbackBanner.classList.remove("visible");
        el.fallbackProceedBtn.style.display = "none";
        return;
      }
      if (climate.status === "verified_live") {
        setClimateBadge("climate-badge-live", "Climate Data: " + climate.locationLabel + " (NREL Verified Live, " + lastVerifiedText + ")");
        el.climateAssumptionPill.textContent = "Climate source: NREL Live | " + climate.locationLabel + " | Verified " + lastVerifiedText;
      } else if (climate.status === "verified_cached") {
        const cachedNote = climate.fallbackReason === "rate_limit_429" ? " due to rate limit" : "";
        setClimateBadge("climate-badge-cached", "Climate Data: " + climate.locationLabel + " (NREL Verified Cached" + cachedNote + ", " + lastVerifiedText + ")");
        el.climateAssumptionPill.textContent = "Climate source: NREL Cached" + cachedNote + " | " + climate.locationLabel + " | Verified " + lastVerifiedText;
      } else {
        setClimateBadge("climate-badge-fallback", "Climate Data: Synthetic Fallback (" + climateFallbackReasonText(climate.fallbackReason) + ")");
        el.climateAssumptionPill.textContent = "Climate source: Synthetic fallback | " + climateFallbackReasonText(climate.fallbackReason) + " | Key " + keyModeLabel;
      }

      const fallbackActive = climate.status === "fallback_synthetic" || climate.status === "fetch_error";
      el.climateFallbackBanner.classList.toggle("visible", fallbackActive);
      if (!fallbackActive) {
        el.fallbackProceedBtn.style.display = "none";
        return;
      }

      const retryAfter = climate.nextRetryAt > Date.now()
        ? (" Auto retry after " + formatTimestampForUi(new Date(climate.nextRetryAt).toISOString()) + ".")
        : "";
      const parts = [
        "Synthetic fallback is active.",
        climateFallbackReasonText(climate.fallbackReason),
        "Key mode: " + keyModeLabel + ".",
        "Last verified NREL dataset: " + lastVerifiedText + ".",
        retryAfter,
        "Paste a personal NREL API key and retry for higher reliability."
      ];
      el.climateFallbackMessage.textContent = parts.join(" ").replace(/\s+/g, " ").trim();
      el.fallbackProceedBtn.style.display = "inline-block";
    }

    function render() {
      syncControlStates();
      const climateContext = buildClimateContext(el.zipCode.value, el.nrelApiKey.value);
      if (climateContext.ok) {
        ensureClimateProfile(climateContext, { forceRefresh: false });
      }
      const { errors, inputs, zipInfo } = collectInputs();
      const climateSnapshot = getClimateSnapshot(climateContext);

      el.zipYieldNote.textContent = zipInfo.ok
        ? ("Yield profile: " + zipInfo.annualYield + " kWh/kW-yr (" + zipInfo.label + "). Climate: " + (climateSnapshot.status === "verified_live"
          ? "NREL verified live"
          : (climateSnapshot.status === "verified_cached" ? "NREL verified cached" : "synthetic fallback")) + ". Temp source: " + (climateSnapshot.tempSource === "nrel_tamb" ? "NREL tamb" : "synthetic fallback") + ".")
        : "Yield profile: invalid ZIP.";
      el.yieldAssumptionPill.textContent = zipInfo.ok
        ? "Yield profile: " + zipInfo.label
        : "Yield profile: invalid ZIP";
      el.tariffAssumptionPill.textContent = "Tariff floor: annual export offsets energy only; fixed + NBC are non-offsettable. Preset: " + (el.tariffPreset.value === "pge_e_elec" ? "PG&E E-ELEC" : "Custom") + ".";
      renderClimateStatusUi(climateSnapshot, climateContext);
      if (inputs) {
        const clipCap = inputs.sizing.powerwallCount >= 1 ? (inputs.sizing.powerwallCount * POWERWALL3_AC_KW) : 0;
        el.vppAssumptionPill.textContent = inputs.vpp.enabled
          ? ("VPP: ON | " + usdPrecise(inputs.sizing.powerwallCount * POWERWALL3_AC_KW * VPP_CREDIT_PER_KW_YEAR) + "/yr proxy at selected PW.")
          : "VPP: OFF";
        el.tempAssumptionPill.textContent = getTemperatureSourceText(inputs.production);
        el.dispatchAssumptionPill.textContent = "Dispatch mode: " + inputs.battery.dispatchMode + ".";
        const janReserve = getMonthReservePct(inputs.battery, 0);
        const julReserve = getMonthReservePct(inputs.battery, 6);
        el.reserveAssumptionPill.textContent = "Reserve policy: " + inputs.battery.reservePolicy + " (Jan " + fmt(janReserve * 100, 0) + "%, Jul " + fmt(julReserve * 100, 0) + "%).";
        el.clipAssumptionPill.textContent = inputs.sizing.powerwallCount >= 1
          ? ("Clipping: ON at " + fmt(clipCap, 1) + " kW AC cap (" + fmt(POWERWALL3_AC_KW, 1) + " kW/PW).")
          : "Clipping: OFF for 0 Powerwalls.";
      } else {
        const pw = Math.max(0, Number(el.powerwallCount.value) || 0);
        const clipCap = pw >= 1 ? pw * POWERWALL3_AC_KW : 0;
        el.vppAssumptionPill.textContent = el.vppEnabled.checked
          ? ("VPP: ON | " + usdPrecise(pw * POWERWALL3_AC_KW * VPP_CREDIT_PER_KW_YEAR) + "/yr proxy at selected PW.")
          : "VPP: OFF";
        el.tempAssumptionPill.textContent = "Temperature source: pending climate profile.";
        el.dispatchAssumptionPill.textContent = "Dispatch mode: " + (el.dispatchMode.value || "self_consumption_peak_then_postpeak") + ".";
        const reservePolicyLabel = el.reservePolicy.value || "auto_seasonal";
        el.reserveAssumptionPill.textContent = "Reserve policy: " + reservePolicyLabel + ".";
        el.clipAssumptionPill.textContent = pw >= 1
          ? ("Clipping: ON at " + fmt(clipCap, 1) + " kW AC cap (" + fmt(POWERWALL3_AC_KW, 1) + " kW/PW).")
          : "Clipping: OFF for 0 Powerwalls.";
      }
      if (inputs && inputs.ev.enabled) {
        el.evAssumptionPill.textContent = "EV: ON | " + fmt(inputs.ev.milesPerMonth, 0) + " mi/mo | Day " + fmt(inputs.ev.dayChargingShare * 100, 0) + "% / Night " + fmt(inputs.ev.nightChargingShare * 100, 0) + "% | Solar-first day shift.";
      } else if (el.hasEvCharging.checked) {
        el.evAssumptionPill.textContent = "EV: ON (input invalid).";
      } else {
        el.evAssumptionPill.textContent = "EV: OFF";
      }
      if (inputs && inputs.ha.enabled) {
        if (inputs.ha.mode === "auto") {
          const summerWindow = inputs.ha.autoPreWindowByMonth[6] || { startHour: 12, endHour: 16 };
          const winterWindow = inputs.ha.autoPreWindowByMonth[0] || { startHour: 11, endHour: 15 };
          el.haAssumptionPill.textContent = "HA HVAC shift: AUTO | Setpoints S " + fmt(inputs.ha.summerSetpointF, 0) + "F / W " + fmt(inputs.ha.winterSetpointF, 0) + "F | Success Jan " + fmt((inputs.ha.successRateByMonth[0] || 0) * 100, 0) + "%, Jul " + fmt((inputs.ha.successRateByMonth[6] || 0) * 100, 0) + "% | Windows Winter " + winterWindow.startHour + "-" + winterWindow.endHour + ", Summer " + summerWindow.startHour + "-" + summerWindow.endHour + ".";
        } else {
          const preHours = buildHourRange(inputs.ha.preCoolStartHour, inputs.ha.preCoolEndHour, 24).slice(0, inputs.ha.maxShiftHoursPerDay).length;
          el.haAssumptionPill.textContent = "HA HVAC shift: MANUAL | Setpoints S " + fmt(inputs.ha.summerSetpointF, 0) + "F / W " + fmt(inputs.ha.winterSetpointF, 0) + "F | Peak drift " + fmt(inputs.ha.maxPeakRelaxOffsetF, 1) + "F | Pre-window " + preHours + "h | Success " + fmt(inputs.ha.successRate * 100, 0) + "%.";
        }
      } else if (el.enableHaShift.checked) {
        el.haAssumptionPill.textContent = "HA HVAC shift: ON (input invalid).";
      } else {
        const summerSet = Number(el.summerSetpointF.value);
        const winterSet = Number(el.winterSetpointF.value);
        el.haAssumptionPill.textContent = "HA HVAC shift: OFF | Setpoints S " + fmt(Number.isFinite(summerSet) ? summerSet : BASE_SUMMER_SETPOINT_F, 0) + "F / W " + fmt(Number.isFinite(winterSet) ? winterSet : BASE_WINTER_SETPOINT_F, 0) + "F";
      }
      if (inputs && inputs.whf.enabled) {
        if (inputs.whf.mode === "auto") {
          const activeMonths = (inputs.whf.autoActiveMonths || []).map((idx) => MONTH_LABELS[idx]).join(",");
          el.whfAssumptionPill.textContent = "WHF: AUTO | " + fmt(inputs.whf.fanWatts, 0) + "W fan | " + fmt(inputs.whf.displacedAcWatts, 0) + "W displaced AC | Success Jan " + fmt((inputs.whf.successRateByMonth[0] || 0) * 100, 0) + "%, Jul " + fmt((inputs.whf.successRateByMonth[6] || 0) * 100, 0) + "% | Active months " + (activeMonths || "none") + ".";
        } else {
          const activeMonths = inputs.whf.activeMonths.map((idx) => MONTH_LABELS[idx]).join(",");
          el.whfAssumptionPill.textContent = "WHF: MANUAL | " + fmt(inputs.whf.fanWatts, 0) + "W fan | " + fmt(inputs.whf.displacedAcWatts, 0) + "W displaced AC | Success " + fmt(inputs.whf.successRate * 100, 0) + "% | Months " + activeMonths;
        }
      } else if (el.enableWhf.checked) {
        el.whfAssumptionPill.textContent = "WHF: ON (input invalid).";
      } else {
        el.whfAssumptionPill.textContent = "WHF: OFF";
      }

      if (errors.length) {
        showErrors(errors);
        renderInvalidState();
        el.recalculateBtn.disabled = true;
        return;
      }

      if (inputs && inputs.climate && inputs.climate.blockedByFallbackAck) {
        showErrors(["NREL climate fetch is unavailable. Click \"Use Synthetic Fallback For Now\" to continue, or paste a personal NREL API key and retry."]);
        renderInvalidState();
        el.recalculateBtn.disabled = true;
        return;
      }

      const optimization = getOptimizationCached(inputs);
      if (optimization.error) {
        showErrors([optimization.error]);
        renderInvalidState();
        el.recalculateBtn.disabled = true;
        return;
      }

      showErrors([]);
      el.recalculateBtn.disabled = false;
      const best = optimization.best;
      const preferredPowerwallBest = optimization.results
        .filter((row) => row.powerwallCount === inputs.sizing.powerwallCount)
        .sort((a, b) => compareObjective(a, b, inputs.sizing.objectiveMode || "return_npv"))[0];
      const displayDefault = preferredPowerwallBest || best;
      const clickedSelection = optimization.results.find((row) => scenarioKey(row.idealSolarKw, row.powerwallCount) === selectedScenarioKey);
      const selected = clickedSelection || displayDefault;
      const selectedScenario = clickedSelection
        ? { ...selected, selectionReason: "user-selected" }
        : ((preferredPowerwallBest && scenarioKey(selected.idealSolarKw, selected.powerwallCount) !== scenarioKey(best.idealSolarKw, best.powerwallCount))
          ? { ...selected, selectionReason: "preferred-powerwall" }
          : selected);
      renderResultCards(selectedScenario, inputs);
      renderScenarioMatrix(optimization, selectedScenario, inputs);
      renderTopScenarios(optimization, selectedScenario, inputs);
      renderHvacImpact(inputs, selectedScenario, optimization);
      renderCalculationBreakdown(inputs, selectedScenario, optimization);
      el.candidateNote.textContent = "Candidate set: " + optimization.solarCandidates.length + " solar sizes x " +
        optimization.batteryCandidates.length + " battery options = " + optimization.results.length + " scenarios (" +
        fmt(optimization.solarCandidates[0], 3) + " to " + fmt(optimization.solarCandidates[optimization.solarCandidates.length - 1], 3) + " kW). Display preference: " + inputs.sizing.powerwallCount + " PW.";

      runModelChecks(inputs, best, optimization);
      runRegressionProbe(inputs, best);
    }

    function bindEvents() {
      let renderTimer = null;
      const scheduleRender = () => {
        if (renderTimer) clearTimeout(renderTimer);
        renderTimer = setTimeout(() => {
          renderTimer = null;
          render();
        }, 220);
      };
      document.querySelectorAll("input, select").forEach((node) => {
        node.addEventListener("input", scheduleRender);
      });
      el.hvacSensitivityKwhPerDegHour.addEventListener("input", () => {
        hvacSensitivityTouched = true;
      });
      el.powerwallCount.addEventListener("input", () => {
        selectedScenarioKey = null;
      });
      el.recalculateBtn.addEventListener("click", () => {
        if (renderTimer) {
          clearTimeout(renderTimer);
          renderTimer = null;
        }
        render();
      });
      el.fallbackProceedBtn.addEventListener("click", () => {
        const climateContext = buildClimateContext(el.zipCode.value, el.nrelApiKey.value);
        if (!climateContext.ok) return;
        acknowledgeSyntheticFallback(climateContext.signature);
        climateState.blockedByFallbackAck = false;
        render();
      });
      el.climateRetryBtn.addEventListener("click", () => {
        const climateContext = buildClimateContext(el.zipCode.value, el.nrelApiKey.value);
        if (!climateContext.ok) return;
        climateState.nextRetryAt = 0;
        ensureClimateProfile(climateContext, { forceRefresh: true });
        render();
      });
    }

    bindEvents();
    render();
  </script>
</body>
</html>
